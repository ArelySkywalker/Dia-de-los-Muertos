<!DOCTYPE HTML>
<html>

<!-- HEADER -->
<head>

<meta charset="UTF-8">

<title>Dia de los Muertos</title>

<script type="text/bitsyGameData" id="exportedGameData">
Dia de los Muertos

# BITSY VERSION 6.3

! ROOM_FORMAT 1

PAL 0
41,0,44
128,159,255
252,168,69

PAL 1
255,255,255
255,255,255
255,255,255

ROOM 0
h5,h6,h7,7,h8,6,7,h9,7,ha,41,hb,hc,6,hd,7
he,hf,hg,7,hh,3f,hi,1g,hj,hk,hl,1g,hm,hn,ho,7
hp,hq,hr,cw,p,hs,ht,7,hu,hv,4,7,cy,hw,7,7
hx,hy,hz,i0,16,i1,d3,d4,d5,43,3v,7,i2,i3,7,7
7,i4,i5,i6,i7,i8,3b,i9,ia,ib,ic,id,ie,dd,de,7
7,if,ig,7,ih,a8,dh,di,4g,7,ii,ij,ik,il,7,7
7,7,im,in,io,7,dn,do,7,ar,4m,as,7,dp,av,7
7,7,ax,dr,5v,6,b0,b1,b2,b3,5w,b4,7,b5,b6,7
7,7,b7,b8,b9,4s,bb,bc,bd,7,be,7,3b,bf,bg,7
5x,7,bh,bi,5z,60,bk,bl,61,62,63,7,7,bn,bo,64
65,bp,bq,br,bs,4w,bt,bu,bv,6a,bw,bx,2g,ip,c0,c1
c2,c3,0,c5,c6,c7,dx,c9,ca,cb,cf,cd,0,ce,cf,cg
ch,0,0,iq,0,ir,2r,0,is,cm,cn,co,0,cp,cq,cr
n1,n1,n1,n1,n1,n1,n1,n1,n1,n1,n1,n1,n1,n1,n1,n1
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME Cemetary
PAL 0

ROOM 1
16w,16x,0,0,0,0,0,16y,131,16z,0,0,0,0,170,171
172,173,0,0,0,0,174,175,176,177,178,0,0,0,179,17a
17b,cr,0,0,0,0,17c,17d,17e,17f,17g,0,0,0,0,17h
17i,0,qe,17j,17k,0,1h,17l,17m,17n,5,0,17o,17p,0,0
0,0,17q,17r,17s,17t,17u,17v,17w,17x,17y,17z,180,181,182,0
0,0,0,0,0,0,0,183,6e,184,0,0,0,0,0,0
0,0,0,185,186,187,188,189,18a,18b,18c,0,18d,0,0,0
0,0,0,0,18e,18f,18g,18h,18i,18j,18k,164,18l,0,0,0
0,0,0,18m,18n,18o,18p,18q,18r,14s,18s,18t,18u,18v,0,0
0,0,18w,18x,18y,18z,190,191,192,193,194,195,196,197,198,0
0,0,199,19a,19b,19c,19d,19e,19f,0,19g,19h,19i,19j,19k,0
0,0,19l,19m,19n,19o,19p,19q,19r,19s,19t,19u,19v,19w,19x,0
19y,0,19z,pn,pn,pn,1a0,1a1,1a2,1a3,pn,pn,pn,1a4,1a5,0
ii,13s,1a6,0,0,0,1a7,1a8,1a9,1aa,1ab,0,0,pr,12f,1ac
1ad,1ae,1af,0,0,0,1ag,1ah,0,1ai,1aj,0,0,0,1ak,1al
1am,1an,1ao,0,0,0,0,0,0,0,0,0,0,0,1ap,1aq
NAME splashf
ITM 3 3,1
ITM 3 12,1
ITM 3 14,6
ITM 3 12,14
ITM 3 4,14
ITM 3 1,6
PAL 0

ROOM 2
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,1f6,1ld,1le,1lf,1lg,16z,0,0,0,0,0
0,0,0,0,1lh,1li,1lj,1lk,1ll,1lm,1ln,1lo,0,0,0,0
0,0,0,1fj,1lp,1i2,vm,0,0,lu,1cv,1lq,1lr,0,0,0
0,0,0,1ls,1lt,1d0,1fq,1d2,1d3,1d4,1fr,1d6,1lu,j7,0,0
0,0,lu,1lv,1fu,15,5,1fv,1lw,f,1dc,0,1lx,1fx,0,0
0,0,1df,1ly,1fz,1lz,1g1,1m0,1m1,1m2,1m3,0,1m4,1il,0,0
0,0,1g8,1m5,1ga,1in,1io,1m6,1m7,1m8,1m9,j7,1ma,1gh,0,0
0,0,1gi,0,1mc,1gl,1md,1me,1mf,1mg,1mh,1mi,1mj,1j6,0,0
0,0,0,1n9,1n9,1n9,1n9,1n9,1n9,1n9,1n9,1n9,1n9,0,0,0
0,0,1ml,1nb,1nb,1nb,1nb,1nb,1nb,1nb,1nb,1nb,1nb,1mw,1jm,0
0,1ha,1mx,1my,1mz,1n0,1n1,1n2,1n3,1n4,1n5,1n6,1n7,1hm,1n8,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME Altar
ITM 1 6,7
ITM 1 5,7
ITM 1 9,7
ITM 1 10,7
ITM 1 3,10
ITM 1 12,10
ITM 1 11,10
ITM 1 4,10
PAL 0

TIL 1
01110000
01111000
11111000
11111000
11111000
11110000
11110000
01111100
NAME Cemetary 1

TIL 2
00000111
00000011
00000011
00000011
00000011
00000011
00000011
00000011
NAME Cemetary 2

TIL 3
11110000
11110000
11111100
11111000
11111000
11111100
11111000
11111000
NAME Cemetary 3

TIL 4
00001111
00001111
00001111
00001111
00001111
00001111
00001111
00001111
NAME Cemetary 4

TIL 5
11100000
11100000
11100000
11100000
11100000
11100000
11100000
11100000
NAME Cemetary 5

TIL 6
11111111
11111111
11111111
11111111
11111111
11111111
11111111
01111111
NAME Cemetary 6

TIL 7
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 7

TIL 8
00000001
00000011
10000110
11000100
11001000
10010000
10000000
00100000
NAME Cemetary 8

TIL 9
00000111
00001111
00001111
00011111
00111111
01111111
01111111
11111111
NAME Cemetary 9

TIL 10
01110001
01000100
00000000
00000000
00000000
00000000
00100000
00000000
NAME Cemetary 35

TIL 11
00000001
00000011
00000011
00000111
00001111
00001111
00011111
00111111
NAME Cemetary 36

TIL 12
10001111
10001111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 37

TIL 13
10111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 38

TIL 14
01111110
01111111
01111111
01111110
01111110
01111110
01111110
01111110
NAME Cemetary 39

TIL 15
00000001
00000001
00000001
00000001
00000001
00000001
00000001
00000001
NAME Cemetary 40

TIL 16
11111110
11111110
11111110
11111110
11111110
11111110
11111110
11111110
NAME Cemetary 41

TIL 17
11110000
11110000
11110000
11111000
11111000
11111000
11110000
11110000
NAME Cemetary 42

TIL 18
00000000
00000000
00000100
00011000
00110000
01100000
01000000
00000000
NAME Cemetary 43

TIL 19
00000000
00000000
00000000
00000000
00000000
00000111
00001111
00111111
NAME Cemetary 44

TIL 20
11111111
11111111
11111111
11111111
11111110
11111100
11111111
11111111
NAME Cemetary 71

TIL 21
00000000
00000000
00000000
00000000
00000000
00000000
11000000
11111000
NAME Cemetary 72

TIL 22
00011111
00011111
00011111
00011111
00011111
00011111
00111111
00111111
NAME Cemetary 73

TIL 23
10000000
10000001
00000011
10000111
10001111
10111111
00111111
01111111
NAME Cemetary 74

TIL 24
11011111
10011111
10011111
00011111
00001111
00000001
10000000
10000000
NAME Cemetary 75

TIL 25
11110000
10110000
11100000
11000000
01000001
10000001
00000011
00000011
NAME Cemetary 76

TIL 26
00111111
00111111
01111111
01111111
01111111
01111111
00111111
01101111
NAME Cemetary 77

TIL 27
11000000
11100000
11110000
11111000
11111000
11111100
11111110
11111110
NAME Cemetary 78

TIL 28
00000001
00000001
00000001
00000000
00000001
00000001
00000001
00000001
NAME Cemetary 79

TIL 29
00000000
00000000
00000000
00000000
00000001
00000001
00000011
00000111
NAME Cemetary 80

TIL 30
00000011
00000111
01111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 107

TIL 31
11111111
11111111
11111111
11111111
11111111
10111111
11111111
11111111
NAME Cemetary 108

TIL 32
11111011
11111011
11111011
11111011
11111101
11111101
11111101
11111101
NAME Cemetary 109

TIL 33
11100011
11100011
11100001
11110001
11110001
11111000
11111000
11111000
NAME Cemetary 110

TIL 34
11110011
11111111
11111111
11111110
11111101
11111101
11111001
11111011
NAME Cemetary 111

TIL 35
00000001
10000001
11000001
11000001
11100001
11100000
11100000
11100000
NAME Cemetary 112

TIL 36
11110011
11110111
11101111
11111111
11111111
10111111
10111111
01111111
NAME Cemetary 113

TIL 37
11000111
11000011
11000011
11000001
11100001
11100000
11100000
11110000
NAME Cemetary 114

TIL 38
00111111
10111111
10111111
10111111
10111111
10111111
00111111
01111111
NAME Cemetary 115

TIL 39
11000011
11000011
11100011
11110011
11110001
11111000
11111000
11111000
NAME Cemetary 116

TIL 40
00011111
10001111
11001111
11100111
00000001
11110001
11110001
11111001
NAME Cemetary 143

TIL 41
11111111
11111111
11111111
11111111
11111111
01111111
01111111
00011111
NAME Cemetary 144

TIL 42
01111000
01111001
00011011
01110011
01100111
01100111
01101111
00001111
NAME Cemetary 145

TIL 43
11111110
11111110
11111110
11111110
11111110
11111111
11111111
11111110
NAME Cemetary 146

TIL 44
11111100
11111001
11111111
11100111
11000111
11001111
10001111
10011111
NAME Cemetary 147

TIL 45
11111001
11111111
11111110
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 148

TIL 46
00001111
00001111
00001111
00000111
10000011
11100001
11111000
11111111
NAME Cemetary 149

TIL 47
11111110
11111110
11111110
11111110
11111110
11111110
00011110
11001110
NAME Cemetary 150

TIL 48
00111111
00111111
01111111
01111111
01111111
01111111
01111111
01111111
NAME Cemetary 151

TIL 49
11111111
11111111
11111111
11111111
11111111
11111111
11111110
11110010
NAME Cemetary 152

TIL 50
11111111
11111111
11111111
11111111
11111110
11111000
11111000
11110000
NAME Cemetary 179

TIL 51
11100000
11000000
10000000
00000000
00000001
00000001
00000001
00000011
NAME Cemetary 180

TIL 52
00111111
00111111
11111111
11111111
11111111
11111100
11111000
11110000
NAME Cemetary 181

TIL 53
11111000
11111000
11111000
11111000
11111000
11111000
11110000
11110000
NAME Cemetary 182

TIL 54
11100000
11100000
11000000
10000000
10000000
10000000
00000000
00001000
NAME Cemetary 183

TIL 55
00001111
00001111
00011111
00011111
01111111
11111111
11111111
11111111
NAME Cemetary 184

TIL 56
11110000
11110000
11110000
11110000
11110011
11111111
11111111
11111111
NAME Cemetary 185

TIL 57
00111111
01111111
01111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 186

TIL 58
10011110
10011110
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 187

TIL 59
00101111
01111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 188

TIL 60
11001111
11001111
11001111
11000111
11100111
11100111
11110111
11110001
NAME Cemetary 215

TIL 61
11111111
11111111
11111111
11111111
11111100
11111100
11111100
11111100
NAME Cemetary 216

TIL 62
11111111
11111111
11111111
11111111
01111111
01111111
01111111
01111110
NAME Cemetary 217

TIL 63
11000001
11000011
11000011
00000111
00000111
00001111
00001111
00011111
NAME Cemetary 218

TIL 64
11111111
11111111
11111111
11111111
10001111
10001111
10001111
10001111
NAME Cemetary 219

TIL 65
11110001
00000000
00000000
00000000
11110001
11110001
11110001
11110001
NAME Cemetary 220

TIL 66
11111111
00011111
00011111
00011111
11111111
11111111
11111111
11111111
NAME Cemetary 221

TIL 67
11111110
11100000
11100000
11100000
11111110
11111110
11111110
11111110
NAME Cemetary 222

TIL 68
00111111
00000011
00000011
00000011
00111111
00111111
00111111
00111111
NAME Cemetary 223

TIL 69
11111100
11000000
11000000
11000000
11111100
11111100
11111100
11111100
NAME Cemetary 224

TIL 70
11100000
11100000
11100000
11100010
11111111
11111111
11111111
11111111
NAME Cemetary 251

TIL 71
00000001
00000111
00000111
01111111
11111111
11111111
11111111
11111111
NAME Cemetary 252

TIL 72
11111111
11111111
11111111
11111111
11111111
11111111
11111100
10000011
NAME Cemetary 253

TIL 73
11111111
11111111
11111111
11111111
11111111
00000011
11111101
11111110
NAME Cemetary 254

TIL 74
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00011111
NAME Cemetary 255

TIL 75
11111111
11111111
11111111
11111111
11111111
11111111
11100000
11011111
NAME Cemetary 256

TIL 76
11111101
11111111
11111111
11111111
11111111
11111111
11111111
00000011
NAME Cemetary 257

TIL 77
11110000
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 258

TIL 78
10111111
10001111
11110111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 259

TIL 79
11111101
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 260

TIL 80
00000000
00000000
00000000
00000000
00000001
00000000
00000000
00000000
NAME Cemetary 287

TIL 81
00000000
00100000
00100000
01110000
11111100
01110000
00100000
00100000
NAME Cemetary 288

TIL 82
00000100
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Cemetary 289

TIL 83
00000000
00100000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Cemetary 290

TIL 84
00000000
10000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Cemetary 291

TIL 85
11110001
11110001
11110001
11110000
11111000
11111000
11111000
11111000
NAME Cemetary 292

TIL 86
11100001
11100000
11100000
11000000
11100000
11100000
11110000
10010000
NAME Cemetary 293

TIL 87
11100000
11111000
11111000
11111100
01111000
01110000
01110000
01110000
NAME Cemetary 294

TIL 88
11111110
11111111
11111111
11111111
01111111
11111111
11111111
11111111
NAME Cemetary 295

TIL 89
00000000
00000000
00000000
10000000
10000000
10000000
11000000
11100000
NAME Cemetary 296

TIL 90
11111111
11111111
11111111
11111111
11111111
10011111
00011111
00011111
NAME Cemetary 323

TIL 91
11111000
11111000
11111000
11111000
11111000
11111000
11111000
11111000
NAME Cemetary 324

TIL 92
01111111
01111111
01111111
01111111
01111000
01111000
01111000
01111000
NAME Cemetary 325

TIL 93
10000011
00000011
00000011
00001111
00001111
00001111
00011111
00011111
NAME Cemetary 326

TIL 94
11110001
11110000
11110000
11110000
11111111
10111111
10111111
10111111
NAME Cemetary 327

TIL 95
11111111
11111100
11101100
00000000
10000000
10000000
11111000
11111100
NAME Cemetary 328

TIL 96
00001110
00001111
00001111
00001111
00001111
00001111
00001111
00001111
NAME Cemetary 329

TIL 97
11111111
11111011
11111110
11011111
11000111
11111111
11111111
11111111
NAME Cemetary 330

TIL 98
01111110
01111111
00111111
00011100
00001100
00001100
10001100
10000000
NAME Cemetary 331

TIL 99
00011111
00011111
00011111
00011111
00010000
00010000
00010000
01100001
NAME Cemetary 332

TIL 100
11110001
11111111
11111111
11111111
11111111
11111111
11111011
11111111
NAME splashf 466

TIL 101
10011111
11111111
11111111
11111111
11111111
11111111
11111001
11111111
NAME splashf 467

TIL 102
11111110
11111110
11111000
10000000
10000000
10000000
10000000
10000000
NAME splashf 468

TIL 103
00000000
00000001
00000010
00000010
00000011
00000001
00000000
00000000
NAME splashf 469

TIL 104
00000011
00000111
00001111
00011110
11111100
11111000
00000000
00000000
NAME splashf 470

TIL 105
11100000
11000000
00000000
00000000
00000100
00000111
00000011
00000000
NAME splashf 471

TIL 106
00111000
00011100
00011100
00011100
00111000
11111000
11110000
00000000
NAME splashf 472

TIL 107
00000011
00000001
00000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 473

TIL 108
11111111
11111111
11111111
11111100
00000000
00000000
00000000
00000000
NAME splashf 474

TIL 109
00000000
00000000
00000000
00000000
00011100
00011110
00001110
00001111
NAME splashf 475

TIL 110
00111000
00111000
00110000
00000000
00000000
00000000
00000000
00000000
NAME splashf 502

TIL 111
11100000
11100000
11100000
00000000
00000000
00000000
00000000
00000000
NAME splashf 503

TIL 112
00000111
00000111
00000011
00001111
00000111
00000110
00000111
00000011
NAME splashf 504

TIL 113
10000000
11000000
10000001
10000001
10000001
11000001
11000001
11100001
NAME splashf 505

TIL 114
11111011
11111001
11110000
11110000
11110000
11110000
11100000
11110000
NAME splashf 506

TIL 115
11100011
11100011
11000001
11000000
11000000
11000000
11000000
11000000
NAME splashf 507

TIL 116
11101111
11001111
11000111
11000111
11000110
11000110
11000110
11000110
NAME splashf 508

TIL 117
01101110
11111110
11111110
00000000
00000000
00000000
00000000
00001100
NAME splashf 509

TIL 118
11111111
01111111
01111111
00100000
00100000
00100000
00100000
00100000
NAME splashf 510

TIL 119
00000000
11000000
11110001
01110000
00111000
00111000
00111000
01101000
NAME splashf 511

TIL 120
00110000
01111000
01111000
01111000
00000000
00000000
00000000
00000000
NAME splashf 538

TIL 121
01110000
01111000
01111100
01111100
00000000
00000000
00000000
11000000
NAME splashf 539

TIL 122
00000110
00001111
00001111
00001111
00000000
00000000
00000000
00000000
NAME splashf 540

TIL 123
00000000
00000000
10000000
10000000
00000000
00000000
00000000
00000000
NAME splashf 541

TIL 124
01110001
01111111
00001111
00000110
00000000
00000000
00000000
00000000
NAME splashf 542

TIL 125
11100011
10000001
00000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 543

TIL 126
11001111
11111100
00111000
00011000
00000000
00000000
00000000
00000000
NAME splashf 544

TIL 127
11000000
11100000
11100000
11111111
11111111
11111111
11100000
11100000
NAME splashf 545

TIL 128
00000000
00000000
00000000
11000000
11000000
11000000
00000000
00000000
NAME splashf 546

TIL 129
00000001
00000001
00000001
00000001
00000011
00000111
00011111
01111111
NAME splashf 547

TIL 130
00000000
00000000
00000000
00000000
00000000
00000001
00000111
00011111
NAME splashf 574

TIL 131
00000000
00000000
00000000
00000000
00000000
11111111
11111111
11111111
NAME splashf 575

TIL 132
00000000
00000000
00000000
00000000
00000000
11000000
11111000
11111100
NAME splashf 576

TIL 133
00000000
00000000
00000000
00000000
00000000
11000000
11110000
11110001
NAME splashf 577

TIL 134
00000000
00000000
00000000
00000000
00000000
00000111
00001111
10001111
NAME splashf 578

TIL 135
00011111
10001111
11000000
11100000
01111000
01111100
01111000
11110000
NAME splashf 579

TIL 136
00111111
01111111
11111111
11111111
11111111
00011111
11111111
11111111
NAME splashf 580

TIL 137
11111111
10000001
10000001
11000011
11100011
11111111
11111111
11111111
NAME splashf 581

TIL 138
11111111
11110111
11000111
11111111
11111111
11111111
11111111
11110111
NAME splashf 582

TIL 139
00000000
10000000
11000000
11000000
11100000
11110000
11110000
11111000
NAME splashf 583

TIL 140
11111111
11111111
11111111
11111100
11111100
11111100
11001100
11111100
NAME splashf 610

TIL 141
11110000
11110000
11000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 611

TIL 142
00000000
00001000
00011000
00011000
00011111
00001111
00000000
00000000
NAME splashf 612

TIL 143
00011111
00111110
01111000
11110000
11100000
11000000
00000000
00000000
NAME splashf 613

TIL 144
00000001
00000000
00000000
00000000
00100001
00111111
00011111
00000000
NAME splashf 614

TIL 145
11000000
11100000
11100000
11100000
11000000
11000000
10000000
00000000
NAME splashf 615

TIL 146
00011111
00001111
00001111
00000011
00000000
00000000
00000000
00000000
NAME splashf 616

TIL 147
11111100
11111100
11111000
11100000
00000000
00000000
00000000
00000000
NAME splashf 617

TIL 148
00000000
00000000
00000000
00000000
11100000
11110000
01110000
01111000
NAME splashf 618

TIL 149
00000000
00000000
00000000
00000001
00000001
00000001
00000001
00000001
NAME splashf 619

TIL 150
00111100
00111110
00011100
00101100
00111100
00111110
00111110
00011110
NAME splashf 646

TIL 151
00000111
00000111
00001111
00001111
00001111
00001101
00001111
00001111
NAME splashf 647

TIL 152
11011111
11001111
10000110
10000110
10000110
00000110
00000110
00000110
NAME splashf 648

TIL 153
00011111
00011110
00001110
00000110
00000110
00000110
00000110
00000110
NAME splashf 649

TIL 154
01111111
01111111
00111111
00110000
00110000
00110000
00110000
00110000
NAME splashf 650

TIL 155
01110011
11110011
11110011
00000011
00000011
00000001
00000001
01100001
NAME splashf 651

TIL 156
11111000
10111110
11111111
11000011
10000001
10000001
10000001
10000001
NAME splashf 652

TIL 157
00000111
00000111
10001111
11000000
11000000
11000000
11000000
01000000
NAME splashf 653

TIL 158
10000001
11111111
11110001
01111100
01111100
00111000
00111000
00111000
NAME splashf 654

TIL 159
11000000
11000000
11000011
00000011
00000111
00000111
00000110
00000100
NAME splashf 655

TIL 160
00001110
00001111
00000001
00000000
00000000
00000000
00000000
00000000
NAME splashf 682

TIL 161
01111100
11100000
11000000
11000000
00000000
00000000
00000000
00000000
NAME splashf 683

TIL 162
00011110
00011111
00111111
00011111
00011111
00011111
00011111
00011111
NAME splashf 684

TIL 163
00000000
00000000
00000000
11111110
11111110
11111100
00000000
00000000
NAME splashf 685

TIL 164
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000111
NAME splashf 686

TIL 165
00001110
00001110
00001110
00001100
00011100
00111110
11111110
11111111
NAME splashf 687

TIL 166
00000000
00000000
00000000
11111111
11111111
01111111
00000000
00000000
NAME splashf 688

TIL 167
00000000
00000001
00000001
11111111
11111111
11111111
00000001
00000001
NAME splashf 689

TIL 168
11110000
11110000
11111000
11110000
11110000
11110000
11110000
11110000
NAME splashf 690

TIL 169
00000011
00000011
00000111
00000111
00001111
00011111
00011111
00111111
NAME splashf 691

TIL 170
00000000
00000000
00000000
00000000
00000000
00000011
00000111
00001111
NAME splashf 718

TIL 171
00000000
00000000
00000000
00000000
00000000
10000000
11000000
11000110
NAME splashf 719

TIL 172
10001100
10001110
00011111
00111111
11110001
11110001
11110001
11111111
NAME splashf 720

TIL 173
01111100
00111100
00000000
10000000
11100000
11110000
11100000
11000000
NAME splashf 721

TIL 174
00000000
00000001
00000011
00000111
00001111
00001100
00011111
00011111
NAME splashf 722

TIL 175
11111111
11111111
11111111
11111111
11111111
01111111
11111111
11111111
NAME splashf 723

TIL 176
11111111
00000111
00000111
00000111
10011111
11011111
11111111
11111111
NAME splashf 724

TIL 177
11111100
11011110
00011111
11111111
11111111
11111111
11111111
10011111
NAME splashf 725

TIL 178
00000000
00000000
00000000
10000000
10000000
11000000
11000000
11100000
NAME splashf 726

TIL 179
00001111
00000111
00000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 727

TIL 180
01111100
11111000
11100000
11000000
10000000
00000000
00000000
00000000
NAME splashf 754

TIL 181
00000111
00000011
00000011
10000011
10000011
11111111
01111110
00000000
NAME splashf 755

TIL 182
00000000
10000000
10000000
10000000
00000000
00000000
00000000
00000000
NAME splashf 756

TIL 183
00111111
00111111
00011111
00001111
00000000
00000000
00000000
00000000
NAME splashf 757

TIL 184
11110000
11100000
11100000
10000000
00000000
00000000
00000000
00000000
NAME splashf 758

TIL 185
00000000
00000000
00000000
00000000
00000011
00000011
00000001
00000001
NAME splashf 759

TIL 186
00000000
00000000
00000000
00000000
10000000
11000000
11000000
11100000
NAME splashf 760

TIL 187
00000000
00000000
00000000
00000111
00000111
00000111
00000111
00000111
NAME splashf 761

TIL 188
00000001
00000001
00000000
11100011
11110011
00111011
00111011
00111011
NAME splashf 762

TIL 189
10000000
00000000
00000000
10000111
10000111
10001111
10001111
10001101
NAME splashf 763

TIL 190
11111101
11111111
11111111
11010000
11000000
11000000
11000000
11000001
NAME splashf 790

TIL 191
11011111
11001111
11001111
01001111
00000110
00000110
00000110
10000110
NAME splashf 791

TIL 192
11100000
11111000
11111110
00001111
00000111
00000111
00000111
00000101
NAME splashf 792

TIL 193
00011110
00011111
00111111
00000001
00000001
00000000
00000000
00000000
NAME splashf 793

TIL 194
00000111
11111111
11000111
11110000
11110000
11100000
11100000
11100000
NAME splashf 794

TIL 195
00000011
00000011
00001111
00001110
00011110
00011100
00011100
00010000
NAME splashf 795

TIL 196
10000000
11000000
11110000
00111110
00011110
00011110
00001110
00001110
NAME splashf 796

TIL 197
00000011
00000111
00001111
00111100
01111000
00110000
01111000
00111100
NAME splashf 797

TIL 198
00000000
11000000
11110000
01110000
00110000
00110000
00010000
00000000
NAME splashf 798

TIL 199
01101100
01101100
01100110
01100110
01100111
01100111
01100011
01100011
NAME splashf 799

TIL a
11111111
10000001
10000001
10011001
10011001
10000001
10000001
11111111

TIL b
00000000
11111101
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 10

TIL c
11111111
00011111
11100111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 11

TIL d
11111111
11111111
11111111
11111111
11111111
11110000
11110000
11111111
NAME Cemetary 12

TIL e
01111100
01111100
11111100
11111100
11111100
11111100
11111110
11111110
NAME Cemetary 13

TIL f
00000011
00000011
00000011
00000011
00000011
00000011
00000011
00000011
NAME Cemetary 14

TIL g
11111000
11111000
11111100
11111100
11111100
11111000
11111000
11111100
NAME Cemetary 15

TIL h
00001111
00011111
00001111
00001111
00001111
00001111
00001111
00001111
NAME Cemetary 16

TIL i
11110000
11110000
11110000
11110000
11110000
11110000
11110000
11110000
NAME Cemetary 17

TIL j
11111110
11111110
11111100
11111101
11111001
11100010
10100000
11000100
NAME Cemetary 18

TIL k
01000001
01000001
10000011
10000011
00000111
00000111
00001111
00001111
NAME Cemetary 19

TIL l
11111110
11111110
11111110
11111100
11111000
11111001
11110000
11100000
NAME Cemetary 20

TIL m
01111111
11111111
11111111
11111111
11111111
11111011
11111111
11111111
NAME Cemetary 21

TIL n
11111110
01111110
01111110
11111110
11111110
01111100
01111110
11111110
NAME Cemetary 22

TIL o
00000011
00000011
00000011
00000011
00000001
00000001
00000011
00000011
NAME Cemetary 23

TIL p
11111100
11111100
11111100
11111100
11111100
11111100
11111100
11111100
NAME Cemetary 24

TIL q
11111111
11111111
11111111
11111111
11111110
11111100
11111000
11110001
NAME Cemetary 25

TIL r
11001100
10001000
10011000
00110000
01100000
01000000
11000000
10000000
NAME Cemetary 26

TIL s
00011111
00011111
00111111
00111111
01111111
01111111
11111111
11111111
NAME Cemetary 27

TIL t
11000000
11000000
11000000
01000000
11000000
11000001
11000011
11000011
NAME Cemetary 28

TIL u
11110111
00100011
00000011
00000011
00000011
00000011
10000111
10001111
NAME Cemetary 29

TIL v
01111110
01111110
11111100
01111100
01111110
01111110
01111110
01111110
NAME Cemetary 30

TIL w
00000011
00000011
00000001
00000001
00000001
00000001
00000001
00000001
NAME Cemetary 31

TIL x
11111100
11111100
11111100
11111110
11111110
11111100
11111110
11111110
NAME Cemetary 32

TIL y
00001111
00001111
00001111
00000111
00001111
00001111
00001111
00001111
NAME Cemetary 33

TIL z
11110000
11110000
11110000
11110000
11110000
11111000
11110000
11110000
NAME Cemetary 34

TIL 1a
01111111
01111111
01111111
01111111
11110111
11100111
11101111
11111111
NAME Cemetary 45

TIL 1b
00111110
00111111
01111111
01111111
01111111
01111111
01111111
01111111
NAME Cemetary 46

TIL 1c
11111110
11111110
11111110
11111110
11111110
11111110
11111110
11111111
NAME Cemetary 47

TIL 1d
00001111
00000111
00001111
00001011
00000111
00011111
00111111
01111111
NAME Cemetary 48

TIL 1e
11111000
01111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 49

TIL 1f
00000000
00000000
11100000
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 50

TIL 1g
01111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 51

TIL 1h
00111111
00111111
00111111
00111111
00111111
00111111
00111111
00111111
NAME Cemetary 52

TIL 1i
11111111
11111110
11111111
11111110
11111111
11111110
11111111
11111111
NAME Cemetary 53

TIL 1j
00000001
00000111
00001111
00011111
00111111
01111111
11111111
11111111
NAME Cemetary 54

TIL 1k
11111111
11111111
11111111
11111111
11000111
11111000
11111111
11111111
NAME Cemetary 55

TIL 1l
11111111
11111111
11111111
11111111
11001111
00000011
00000001
11100000
NAME Cemetary 56

TIL 1m
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11011111
NAME Cemetary 57

TIL 1n
00000001
00000001
00000000
00000001
00000001
00000000
00000000
00000001
NAME Cemetary 58

TIL 1o
11111111
11111111
11111111
11111111
01111111
11111111
11111111
11111111
NAME Cemetary 59

TIL 1p
11111111
11111111
11111111
11111111
11111111
11111101
11111111
11111111
NAME Cemetary 60

TIL 1q
11111111
11111111
11001001
11000000
11000000
11000000
11001000
11001000
NAME Cemetary 61

TIL 1r
11111111
11111111
11111111
01111111
00011111
00011111
00001111
00001111
NAME Cemetary 62

TIL 1s
11111000
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 63

TIL 1t
01101111
00011111
11100000
11111000
11111110
11111110
11111111
11111111
NAME Cemetary 64

TIL 1u
11111111
11111111
11111111
01111111
00111111
00000111
00000000
00000000
NAME Cemetary 65

TIL 1v
00111111
00111111
00111111
00111111
00111111
00111111
00111111
00011111
NAME Cemetary 66

TIL 1w
10000000
00000000
00000000
10000000
00000000
00000000
00000000
10000000
NAME Cemetary 67

TIL 1x
00000011
00000111
00001111
00001111
00011111
00111111
01111111
11111111
NAME Cemetary 68

TIL 1y
11000000
11100000
11110000
11111000
11111111
11111111
11111111
11111111
NAME Cemetary 69

TIL 1z
00000111
00001111
00001111
00111111
11011111
11111111
11111111
11111111
NAME Cemetary 70

TIL 2a
00011111
00111111
01111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 81

TIL 2b
00000001
10000001
10000001
10000001
10000011
10000011
10000011
00000111
NAME Cemetary 82

TIL 2c
00001111
00011111
00111111
00111111
01111111
11111111
11111111
11111111
NAME Cemetary 83

TIL 2d
00000111
00001111
10001110
10011100
10111110
10111110
11111110
11111110
NAME Cemetary 84

TIL 2e
11111111
11111110
11111100
11111110
11111110
11111100
11111110
11111110
NAME Cemetary 85

TIL 2f
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111110
NAME Cemetary 86

TIL 2g
11111111
11111111
11111111
11111111
11100000
10000000
00000000
00000000
NAME Cemetary 87

TIL 2h
11111111
11111111
11111111
11111111
11111111
00111111
00011111
00001111
NAME Cemetary 88

TIL 2i
11111111
11111111
11111111
11111111
11111111
11111110
11111100
11111000
NAME Cemetary 89

TIL 2j
11111111
11111111
11111111
11111111
10000011
00000000
00000000
00000000
NAME Cemetary 90

TIL 2k
11111111
11111111
11111111
11111111
11111111
11111111
01111111
00111111
NAME Cemetary 91

TIL 2l
11111111
11111111
11111111
11111111
11111111
11111100
11111000
11110000
NAME Cemetary 92

TIL 2m
11111111
11111111
11111111
11111111
00000111
00000001
00000000
00000000
NAME Cemetary 93

TIL 2n
11111110
11111100
11111100
11111100
11111100
11111100
11111100
11111100
NAME Cemetary 94

TIL 2o
00001111
00000111
00000111
00000111
00000111
00000111
00000111
00000111
NAME Cemetary 95

TIL 2p
11111000
11110000
11110000
11110000
11110000
11110000
11110000
11110000
NAME Cemetary 96

TIL 2q
00111111
00011111
00011111
00011111
00011111
00011111
00011111
00011111
NAME Cemetary 97

TIL 2r
11110000
11100000
11100000
11100000
11100000
11100000
11100000
11100000
NAME Cemetary 98

TIL 2s
01111111
00111111
00111111
00111111
00111111
00111111
00111111
00111111
NAME Cemetary 99

TIL 2t
11111100
11111100
11111100
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 100

TIL 2u
01000000
01000000
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 101

TIL 2v
00000111
01000111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 102

TIL 2w
11110000
11110000
11111001
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 103

TIL 2x
00000000
10000000
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 104

TIL 2y
10011111
10011111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 105

TIL 2z
11100000
11100000
11100010
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 106

TIL 3a
11111111
11111111
11111111
11111111
11111101
11111001
11111011
11111011
NAME Cemetary 117

TIL 3b
11111110
11111110
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 118

TIL 3c
10111000
00111100
00001000
10000000
11100000
11100000
11111000
11111000
NAME Cemetary 119

TIL 3d
11111011
11110111
11110111
11111111
01011111
01011111
00111111
00111111
NAME Cemetary 120

TIL 3e
11110000
11110000
11110000
11111000
11111000
11111000
11111000
11111100
NAME Cemetary 121

TIL 3f
01111111
01111111
01111111
01111111
01111111
01111111
01111111
01111111
NAME Cemetary 122

TIL 3g
11111111
11111110
11111111
11111101
11111011
11111011
11110111
11110111
NAME Cemetary 123

TIL 3h
11111111
11111111
11111111
11011111
11101111
11101111
11111111
11110111
NAME Cemetary 124

TIL 3i
11110000
11110000
11111000
11111000
11111000
11111110
11111111
11111111
NAME Cemetary 125

TIL 3j
00111110
00111101
00111101
00110111
00001111
00011111
00011111
00011111
NAME Cemetary 126

TIL 3k
11111100
11111100
11111100
11111110
11111110
11111110
11111110
11111110
NAME Cemetary 127

TIL 3l
01111111
01111111
01111111
00111111
00111001
00100111
00011111
00111111
NAME Cemetary 128

TIL 3m
11111011
11100111
10011111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 129

TIL 3n
11111111
11111111
11111111
11111111
11111111
10111111
10001111
11110011
NAME Cemetary 130

TIL 3o
11111000
11111000
11111000
11111000
11111000
11111000
11111100
10111110
NAME Cemetary 131

TIL 3p
01111111
00111111
00111111
00111111
00111111
00111111
00011111
00011111
NAME Cemetary 132

TIL 3q
11111100
11111100
11111100
11111100
11111100
11111100
11111100
11111110
NAME Cemetary 133

TIL 3r
01111111
01111111
01111111
01111111
01111111
01111110
01111110
01111100
NAME Cemetary 134

TIL 3s
11100111
11000111
10001111
10001111
00011111
00011111
00111111
01111111
NAME Cemetary 135

TIL 3t
11110111
11111011
11111111
11111100
11111111
11111111
11111111
11111111
NAME Cemetary 136

TIL 3u
11111111
11111111
11111110
00011110
11000000
11111100
11111110
11111110
NAME Cemetary 137

TIL 3v
00011111
00011111
00011111
00011111
00011111
00011111
00011111
00011111
NAME Cemetary 138

TIL 3w
11111110
11111111
11111111
11111111
11111110
11111110
11111110
11111110
NAME Cemetary 139

TIL 3x
00111111
00111111
00111111
00111111
00111111
00111111
01111111
01111111
NAME Cemetary 140

TIL 3y
11111101
11111110
11111110
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 141

TIL 3z
10111111
10001111
11110111
11111001
11111111
11111111
11111111
11111111
NAME Cemetary 142

TIL 4a
11111110
11111101
11111101
11111001
11111001
11111011
00000111
01111111
NAME Cemetary 153

TIL 4b
10011111
10001111
10001111
11000111
11000011
11000011
11000001
11110001
NAME Cemetary 154

TIL 4c
11111111
11111110
11111110
11111110
11111100
11111100
11111100
11111100
NAME Cemetary 155

TIL 4d
01011111
00111111
00111111
01111111
01111111
11111111
11111111
11111111
NAME Cemetary 156

TIL 4e
11000000
11100000
11111000
11111100
11111000
11111000
11110000
11100000
NAME Cemetary 157

TIL 4f
01111111
01111111
01111111
01111111
01111111
01111111
11111111
11111111
NAME Cemetary 158

TIL 4g
11001111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 159

TIL 4h
11111000
11111100
11111110
11111110
11111111
11111111
11111111
11111111
NAME Cemetary 160

TIL 4i
11111101
11111001
01111001
00110001
00100001
10000000
11000001
11000011
NAME Cemetary 161

TIL 4j
11111111
11111111
11111111
00111111
01111111
11111111
11111111
11111111
NAME Cemetary 162

TIL 4k
11111111
11111011
11111001
11111001
11111100
11111110
11111110
11111110
NAME Cemetary 163

TIL 4l
11000000
11000001
10000001
10000001
00001111
00001111
00001111
00000111
NAME Cemetary 164

TIL 4m
11111111
11111111
11111111
11110111
11110111
11111011
11111011
11111001
NAME Cemetary 165

TIL 4n
11000011
11000111
11000111
11001111
10001111
10011111
00011111
00011111
NAME Cemetary 166

TIL 4o
00000111
00000111
00000111
10000011
11100011
11100001
11110000
11111000
NAME Cemetary 167

TIL 4p
11111101
11111110
11111110
11111110
11111110
11111110
11111110
11111110
NAME Cemetary 168

TIL 4q
00111111
00111111
00111111
00111111
01111111
01111111
11111111
11111111
NAME Cemetary 169

TIL 4r
11111100
11111100
11111110
11111110
11111111
11111111
11111111
11111111
NAME Cemetary 170

TIL 4s
01111111
00111111
00111111
00111111
00011111
00011111
00011111
10001111
NAME Cemetary 171

TIL 4t
11111100
11111000
11111001
11110001
11110001
11110001
11100001
11100001
NAME Cemetary 172

TIL 4u
11101111
11101111
11101111
11000111
11100111
11100111
11110111
11110001
NAME Cemetary 173

TIL 4v
11100001
11000011
11000011
00000111
00000111
00001111
00001111
00011111
NAME Cemetary 174

TIL 4w
11111001
11111001
11111000
11111100
11111100
11111000
11111000
11111000
NAME Cemetary 175

TIL 4x
11111111
11111111
11111111
11111111
01111111
01111111
00111111
00111111
NAME Cemetary 176

TIL 4y
11111110
11111100
11111100
11111100
11111000
11111000
11111000
11111000
NAME Cemetary 177

TIL 4z
00011111
00011111
00011111
00111111
00111111
00111111
00111111
00111111
NAME Cemetary 178

TIL 5a
11111111
11111111
11111111
11111111
11111111
11010100
11111111
11111111
NAME Cemetary 189

TIL 5b
11111111
11111111
11111111
11111111
11111111
00000110
11111111
11111111
NAME Cemetary 190

TIL 5c
11111111
11111111
11111111
11111111
11111111
00100001
11111111
11111111
NAME Cemetary 191

TIL 5d
11110011
11111101
11111110
11111110
11111101
11111101
11111001
11111011
NAME Cemetary 192

TIL 5e
00000001
10000001
11000001
11000001
11000001
11100000
11100000
11100000
NAME Cemetary 193

TIL 5f
11110011
11110111
11101111
11011111
11011111
10111111
10111111
01111111
NAME Cemetary 194

TIL 5g
11111100
11111110
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 195

TIL 5h
11111011
11110111
11110111
01101111
01011111
01011111
00111111
00111111
NAME Cemetary 196

TIL 5i
11111111
11111110
11111101
11111101
11111011
11111011
11110111
11110111
NAME Cemetary 197

TIL 5j
11111111
11111111
11011111
11011111
11101111
11101111
11110111
11110111
NAME Cemetary 198

TIL 5k
00111110
00111101
00111101
00110011
00001111
00011111
00011111
00011111
NAME Cemetary 199

TIL 5l
01111111
01111111
01111111
00111110
00111001
00100111
00011111
00111111
NAME Cemetary 200

TIL 5m
11111011
11100111
10011111
01111111
11111111
11111111
11111111
11111111
NAME Cemetary 201

TIL 5n
11110111
11111011
11111101
11111100
11111111
11111111
11111111
11111111
NAME Cemetary 202

TIL 5o
11111110
11111111
11111111
11111111
11111110
11111110
11111110
11111100
NAME Cemetary 203

TIL 5p
10111111
10001111
01110111
11111001
11111111
11111111
11111111
11111111
NAME Cemetary 204

TIL 5q
01111000
01111001
00011011
01110011
01100111
01100111
01001111
00001111
NAME Cemetary 205

TIL 5r
11111100
11111001
11101111
11100111
11000111
11001111
10001111
10011111
NAME Cemetary 206

TIL 5s
00001111
00001111
00000111
00000111
10000011
11100001
11111000
11111111
NAME Cemetary 207

TIL 5t
11111111
11111111
11111111
11111111
11111111
11111111
11111100
11110010
NAME Cemetary 208

TIL 5u
10011111
10001111
10000111
11000111
11000011
11000011
11000001
11110001
NAME Cemetary 209

TIL 5v
00000111
00000111
00000011
10000011
11100011
11100001
11110000
11111000
NAME Cemetary 210

TIL 5w
11111101
11111100
11111100
11111100
11111100
11111100
11111100
11111100
NAME Cemetary 211

TIL 5x
11111111
11111111
11111111
11111111
11110001
11110001
11110001
11110001
NAME Cemetary 212

TIL 5y
11111111
11111111
11111111
11111111
11111110
11111110
11111110
11111110
NAME Cemetary 213

TIL 5z
11111111
11111111
11111111
11111111
00111111
00111111
00111111
00111111
NAME Cemetary 214

TIL 6a
01111110
00000100
00000100
00000100
01111000
01111000
01111000
01111000
NAME Cemetary 225

TIL 6b
11111111
11111000
11111000
11111000
11111111
11111111
11111111
11111111
NAME Cemetary 226

TIL 6c
10001111
00000000
00000000
00000000
10001111
10001111
10001111
10001111
NAME Cemetary 227

TIL 6d
11110001
11110001
11110001
11110001
11110001
11110001
11110001
11110001
NAME Cemetary 228

TIL 6e
11111111
11111111
11111111
11111111
00000000
00000000
00000000
00000000
NAME Cemetary 229

TIL 6f
11111110
11111110
11111110
11111110
11111110
11111110
01111110
00111110
NAME Cemetary 230

TIL 6g
00111111
00111111
00111111
00111111
00111110
00111000
00111000
00110000
NAME Cemetary 231

TIL 6h
00111111
00011111
11111111
11111111
11111110
11111100
11111000
11110000
NAME Cemetary 232

TIL 6i
11111100
11111100
11111100
11111100
11111100
11111100
11111100
01111100
NAME Cemetary 233

TIL 6j
01111000
01111000
01111000
01111000
01111000
01111000
01110000
01110000
NAME Cemetary 234

TIL 6k
00111111
00011111
00111111
00111111
00111111
00111111
00111111
00111111
NAME Cemetary 235

TIL 6l
10001111
10001111
10001111
10001111
10001111
10001111
10001111
10001111
NAME Cemetary 236

TIL 6m
11110001
11110001
11110001
11110001
11110001
11110001
11110001
11111111
NAME Cemetary 237

TIL 6n
00111110
00001110
00001110
00001110
00011110
00011110
00011110
00011110
NAME Cemetary 238

TIL 6o
00100000
00000000
00000000
00000000
00000000
00000000
00000000
00001000
NAME Cemetary 239

TIL 6p
01111100
00111100
00111100
00111100
00111100
00111100
00111111
00111111
NAME Cemetary 240

TIL 6q
01110000
01110000
01110000
01110000
01110001
01111111
11111111
11111111
NAME Cemetary 241

TIL 6r
00111111
01111111
01111111
01111111
11111111
11111111
11111111
11111111
NAME Cemetary 242

TIL 6s
11111100
11111100
11111100
11111100
11111111
11111111
11111111
11111111
NAME Cemetary 243

TIL 6t
00000000
01000000
01000000
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 244

TIL 6u
00000111
01000111
01000111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 245

TIL 6v
10001111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 246

TIL 6w
11110000
11110000
11110000
11111001
11111111
11111111
11100000
10011111
NAME Cemetary 247

TIL 6x
00000000
10000000
10000000
11111111
11111111
11111111
11111111
01111111
NAME Cemetary 248

TIL 6y
00011110
10011110
10011111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 249

TIL 6z
00001111
01111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 250

TIL 7a
11111111
11111111
11111111
11111111
11111100
11110001
00000111
11111111
NAME Cemetary 261

TIL 7b
11111111
11111111
11111111
11111111
00000011
11111100
11111111
11111111
NAME Cemetary 262

TIL 7c
11111111
11111111
11111111
11111111
11111111
00011111
11111111
11111111
NAME Cemetary 263

TIL 7d
11111111
11111111
11111111
11111111
11111111
11011111
11111111
11111111
NAME Cemetary 264

TIL 7e
11111111
11111100
11111101
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 265

TIL 7f
00111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 266

TIL 7g
11111001
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 267

TIL 7h
11111111
11011111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 268

TIL 7i
11111111
11111111
11111111
11111111
11101111
11010000
11011110
11111111
NAME Cemetary 269

TIL 7j
11111111
11111111
11111111
11111111
11111011
00000000
00100001
11111111
NAME Cemetary 270

TIL 7k
11111111
11111111
11111111
11111111
11011111
00000000
10100101
11111111
NAME Cemetary 271

TIL 7l
00000000
00000000
00000000
00000000
00000000
10000000
00000000
00000000
NAME Cemetary 272

TIL 7m
00000000
00000000
00100000
00000000
00000000
00000000
00000000
00000000
NAME Cemetary 273

TIL 7n
00000000
00000000
00000000
00000000
00000000
00100000
00000000
00000000
NAME Cemetary 274

TIL 7o
00000000
00000000
00000000
00000000
00000000
00100000
01110000
00100000
NAME Cemetary 275

TIL 7p
00000000
00000000
00000000
00000000
00000000
00010000
00010000
00111000
NAME Cemetary 276

TIL 7q
00000000
00000000
00000000
01000000
00000000
00000000
00000000
00000000
NAME Cemetary 277

TIL 7r
00000000
00001000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Cemetary 278

TIL 7s
00000000
00000000
00000000
00000000
00000000
00000001
00000011
00000001
NAME Cemetary 279

TIL 7t
00000000
00000000
00000000
00000000
00000000
00000000
10000000
00000000
NAME Cemetary 280

TIL 7u
11111110
00111000
00010000
00010000
00000000
00000000
00000000
00000000
NAME Cemetary 281

TIL 7v
00000000
00000000
00000000
00000000
00000000
00000000
01000000
00000000
NAME Cemetary 282

TIL 7w
00000000
00000000
00000000
00000000
00010000
00000000
00000000
00000000
NAME Cemetary 283

TIL 7x
00000000
00000000
00000000
00000000
00000000
01000000
11100000
01000000
NAME Cemetary 284

TIL 7y
00000000
00000000
00000000
00000010
00000000
00000000
00000000
00000000
NAME Cemetary 285

TIL 7z
00000000
00000000
00000000
00000000
00100000
00000000
00000000
00000000
NAME Cemetary 286

TIL 8a
11111111
10101111
11111111
11111111
11111111
11111111
11111111
11111110
NAME Cemetary 297

TIL 8b
11110001
11000011
11000011
10001111
10001111
00001111
10011111
00011111
NAME Cemetary 298

TIL 8c
11111111
11111111
11111111
11111111
11111111
11111111
10101111
11111111
NAME Cemetary 299

TIL 8d
10000000
10000001
10000001
10000000
10000000
11000000
11000000
11000000
NAME Cemetary 300

TIL 8e
11111111
11111111
11111111
01111111
01111111
01111111
01111111
00011110
NAME Cemetary 301

TIL 8f
10000001
10000001
11000001
11000000
11110000
11100000
11110000
11110000
NAME Cemetary 302

TIL 8g
11111111
11111111
11111111
11111111
01111111
01111111
01111111
01111111
NAME Cemetary 303

TIL 8h
11111111
11111111
11111111
11111001
11110000
11110000
11110000
11110001
NAME Cemetary 304

TIL 8i
11111111
11111111
11111111
11111111
01111111
01111111
11111111
11111111
NAME Cemetary 305

TIL 8j
11111000
11111110
11111110
11111110
11111111
11111111
11111111
11111111
NAME Cemetary 306

TIL 8k
00010000
00000000
00000000
00000000
01100000
11000000
11000000
11110000
NAME Cemetary 307

TIL 8l
01100001
01100111
11000011
00000111
00001111
00001111
00001111
00011111
NAME Cemetary 308

TIL 8m
11111111
11111111
11111111
11111111
11111111
11111111
11110111
01110111
NAME Cemetary 309

TIL 8n
11100000
11100000
11100000
11100000
11110000
11110000
11110000
11110000
NAME Cemetary 310

TIL 8o
11111110
11111100
11111000
11111000
11110000
11100001
11100001
11000011
NAME Cemetary 311

TIL 8p
11111111
10001111
10001111
10000111
10100111
11100011
11100011
11110011
NAME Cemetary 312

TIL 8q
11110000
11110000
11110000
11110000
11110000
11111000
11111110
11111111
NAME Cemetary 313

TIL 8r
00011000
00011000
00000000
00000000
00000101
00000111
00001111
00001111
NAME Cemetary 314

TIL 8s
01111111
11111111
01111111
01111111
11011111
11011111
11011111
11111110
NAME Cemetary 315

TIL 8t
11111000
11111000
11110000
11110000
11111100
11111100
11111100
11111100
NAME Cemetary 316

TIL 8u
01111111
01111111
01111110
00010000
00000000
00000000
00000001
00001111
NAME Cemetary 317

TIL 8v
11100000
00000101
00000011
00001111
10111111
11111111
11111111
11111111
NAME Cemetary 318

TIL 8w
11111111
11111111
01011111
11111111
00111111
11111111
11111111
11111111
NAME Cemetary 319

TIL 8x
11101111
11111011
11111111
11111111
00011111
00000111
00000111
00000000
NAME Cemetary 320

TIL 8y
11110000
11110000
11110000
11110000
11110000
10010000
10010000
00011000
NAME Cemetary 321

TIL 8z
00011111
00011111
00011111
00011111
00011111
00001111
00001111
00001111
NAME Cemetary 322

TIL 9a
11101000
11111000
11111000
11111110
11111111
11111111
11111111
11111111
NAME Cemetary 333

TIL 9b
00000000
00000000
00000000
01110000
11111110
11111110
11111110
11111110
NAME Cemetary 334

TIL 9c
00000111
00001110
00001110
00000000
00000000
00000000
11100000
01100000
NAME Cemetary 335

TIL 9d
00011111
01111111
01111111
01111111
01111111
01001111
01001111
00000111
NAME Cemetary 336

TIL 9e
11111100
11111100
11111100
11111100
11111100
11111100
01111100
01111100
NAME Cemetary 337

TIL 9f
01110000
00000000
00000001
00000001
01000111
00000011
00000011
00001111
NAME Cemetary 338

TIL 9g
01111111
11111111
11111011
11110001
11110000
11110000
11111000
11111000
NAME Cemetary 339

TIL 9h
11111111
11111111
11111111
10011111
00001111
00001111
10011111
00011111
NAME Cemetary 340

TIL 9i
11111100
11111100
11111100
11111100
11111100
11111001
11111111
11111100
NAME Cemetary 341

TIL 9j
00001111
00011111
00011111
00011111
00011111
00011111
00011111
00001111
NAME Cemetary 342

TIL 9k
11111111
11111111
11111111
11010111
11011111
11001111
11111111
11111110
NAME Cemetary 343

TIL 9l
11110000
11000000
11100000
10000000
10000000
00000000
00000000
00000000
NAME Cemetary 344

TIL 9m
00110111
01110111
01110111
11100011
00000001
00000111
00001111
00111110
NAME Cemetary 345

TIL 9n
11111111
11111111
11111111
11111111
11111111
11111110
11111110
00011110
NAME Cemetary 346

TIL 9o
11111111
11111111
11111111
11111111
01111111
11111111
11111111
11101111
NAME Cemetary 347

TIL 9p
11111011
11101011
11111011
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 348

TIL 9q
11111110
10001110
10001110
10001110
11100110
11100011
11000011
11110001
NAME Cemetary 349

TIL 9r
01110000
01111000
01111000
00011000
00011000
00010000
00010000
00000001
NAME Cemetary 350

TIL 9s
00001111
00000111
00000011
00000011
00000000
00100000
11000000
11111000
NAME Cemetary 351

TIL 9t
11111100
11111100
11111100
11111100
11111100
00000100
00000100
00000000
NAME Cemetary 352

TIL 9u
00010111
00011111
00011111
01111111
01111111
01111111
01111111
01111111
NAME Cemetary 353

TIL 9v
11111110
11111110
11111100
11111110
11111000
11111111
11111111
11111111
NAME Cemetary 354

TIL 9w
00011111
00011110
00011000
00011000
00011001
00011001
10001001
10001001
NAME Cemetary 355

TIL 9x
00111111
01111111
01111111
11111111
11111111
11110000
11100000
10000000
NAME Cemetary 356

TIL 9y
11111000
11110000
11111000
11110000
11110000
00000000
00000000
00000001
NAME Cemetary 357

TIL 9z
00000111
00000001
00000101
00000001
00000000
10000000
10000000
10000000
NAME Cemetary 358

TIL a0
11111000
11111100
11111100
11110000
11110000
11111000
11111000
01111000
NAME Cemetary 359

TIL a1
00001000
00000000
00000000
00000011
01110011
01110000
01100000
01110000
NAME Cemetary 360

TIL a2
01111100
00111100
00111100
00011100
00001100
10001100
10001100
01000000
NAME Cemetary 361

TIL a3
00011111
01111111
01111111
01111111
01111111
01111111
01111111
01111111
NAME Cemetary 362

TIL a4
11110001
11110000
11111000
11111000
11111110
11111110
11111110
11111110
NAME Cemetary 363

TIL a5
00000111
00000111
00000111
00011111
00011111
00011111
00011111
00011111
NAME Cemetary 364

TIL a6
11111111
11111111
11111111
10111111
10111111
11111111
11111111
11111111
NAME Cemetary 365

TIL a7
10000000
11000000
11100000
11110000
11110000
11100000
11100000
10000000
NAME Cemetary 366

TIL a8
01111111
01111111
01111111
01111111
01111111
01111111
01111111
11111111
NAME Cemetary 367

TIL a9
11000111
11101111
11101111
11101011
11010111
11100001
11100001
11110001
NAME Cemetary 368

TIL aa
10000001
10000111
10000011
10000111
10001011
10000111
10001111
10001110
NAME Cemetary 369

TIL ab
10001111
11111111
11111111
11111111
11111111
11111111
11111111
01111110
NAME Cemetary 370

TIL ac
11110000
11110000
11110000
11111000
11111001
11111110
11111111
11111111
NAME Cemetary 371

TIL ad
01111000
00110000
00010000
00010000
00000000
00000000
00000000
00000000
NAME Cemetary 372

TIL ae
01111010
11111110
10111111
00011111
01111111
00111111
01111111
11111111
NAME Cemetary 373

TIL af
01100000
00000100
00000100
00000100
11100000
11000000
11110000
11100000
NAME Cemetary 374

TIL ag
01111111
01111111
01111111
01111110
01111110
01111111
01111111
11111111
NAME Cemetary 375

TIL ah
11111111
11111111
11111111
10001111
11111001
11111111
11111111
11111111
NAME Cemetary 376

TIL ai
11111111
11111111
11111111
11111111
11111111
11111110
11111111
11111111
NAME Cemetary 377

TIL aj
11111111
11111111
01110111
11111111
11111111
11110101
11110111
11111111
NAME Cemetary 378

TIL ak
00001111
10001000
10001000
10001000
10001000
10001000
11101110
01100011
NAME Cemetary 379

TIL al
11110001
11110000
11110000
11110000
11110100
11111100
11111110
01111110
NAME Cemetary 380

TIL am
10000000
00000000
00000000
00000000
00001011
00001111
00001111
00000111
NAME Cemetary 381

TIL an
11111111
11111111
11111111
11111111
11110111
11111111
11111111
11111111
NAME Cemetary 382

TIL ao
11110000
11111000
10111000
10001100
10011111
11101111
11110011
11111001
NAME Cemetary 383

TIL ap
10001110
10001100
00011110
00011110
10011101
10011011
10010011
10010111
NAME Cemetary 384

TIL aq
00111111
10111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 385

TIL ar
11111111
11101111
11101111
11101111
11101111
11101111
11101111
11011111
NAME Cemetary 386

TIL as
11000001
11000111
11000111
11001111
10001111
10011111
00011111
00011111
NAME Cemetary 387

TIL at
00111111
11011111
11101000
11110111
11111111
11111111
11111111
11111111
NAME Cemetary 388

TIL au
11110000
11110000
11100000
11111000
11111100
11111100
11011100
11101100
NAME Cemetary 389

TIL av
10111111
10111111
10110111
01110111
01110111
01110111
11110111
11110111
NAME Cemetary 390

TIL aw
11100111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 391

TIL ax
01110111
10111011
11011011
11011101
11101101
11101100
11110010
11110100
NAME Cemetary 392

TIL ay
01111110
10111110
10111110
10111111
10111111
00111111
11111111
11111111
NAME Cemetary 393

TIL az
00000111
00000111
00000011
10000001
11100001
11100001
11100000
11111000
NAME Cemetary 394

TIL b0
11111100
11111110
01111111
01111111
01111111
01111111
10111111
10111111
NAME Cemetary 395

TIL b1
10001111
10011111
00011111
00111111
00111111
10111111
10111111
00111111
NAME Cemetary 396

TIL b2
11111111
11111110
11111101
11111011
11111011
11110111
11101111
11001111
NAME Cemetary 397

TIL b3
11011111
00111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 398

TIL b4
00111111
00111111
00111111
00111111
01111111
01111111
01111111
11111111
NAME Cemetary 399

TIL b5
11110100
11110100
11111000
11111000
11111100
11111100
11111100
11111100
NAME Cemetary 400

TIL b6
11110111
11110111
11110111
11110111
11110111
11101111
11101111
11101111
NAME Cemetary 401

TIL b7
11111000
11111000
11111100
01111100
01111110
01111110
01111111
01111111
NAME Cemetary 402

TIL b8
11111111
01111111
01111111
01111111
00111111
00111111
00111000
10010011
NAME Cemetary 403

TIL b9
11111100
11111100
11111110
11111110
10111111
01111111
11111111
11111111
NAME Cemetary 404

TIL ba
01111111
00011111
00011111
00011111
00011111
00011111
00011111
10001111
NAME Cemetary 405

TIL bb
10111111
11011111
11011111
11101111
11110001
11111110
11111111
11111111
NAME Cemetary 406

TIL bc
00111111
10111111
10111110
10011101
10011011
10010111
00001111
10011111
NAME Cemetary 407

TIL bd
10111111
01111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 408

TIL be
11111100
11111000
11111000
11110001
11110001
11110001
11100001
11100001
NAME Cemetary 409

TIL bf
11111100
11111100
01111100
01111100
01111100
01111100
10111100
10111100
NAME Cemetary 410

TIL bg
01101111
01011111
11011111
10111111
10111111
01111111
01111111
01111111
NAME Cemetary 411

TIL bh
00111111
10011111
11001111
11100111
11111001
11111100
11111110
11111110
NAME Cemetary 412

TIL bi
10010111
10001111
10001111
10001111
10011110
10011110
10011110
00011110
NAME Cemetary 413

TIL bj
11001111
11001111
11001111
11000111
11100111
11100111
11100111
11110001
NAME Cemetary 414

TIL bk
11111111
11111111
11111111
11111101
11111110
11111111
11111111
11111111
NAME Cemetary 415

TIL bl
10011110
11011110
11011101
11001011
11001011
01100111
01101111
10101111
NAME Cemetary 416

TIL bm
11000001
11000011
11000011
00000111
00000111
00001111
00001111
00001111
NAME Cemetary 417

TIL bn
10111100
10111100
11011100
11101100
11110100
11110000
11111000
11111100
NAME Cemetary 418

TIL bo
11111111
11111111
11111111
11111111
11011111
11011111
10111111
10111111
NAME Cemetary 419

TIL bp
11111111
00011111
00011111
00011111
11111111
11111111
10001111
10001111
NAME Cemetary 420

TIL bq
11111111
11111111
11111111
11111111
11111111
11111111
11111000
11111000
NAME Cemetary 421

TIL br
00011110
10000000
10000000
10000000
10011110
10011110
10011110
10001110
NAME Cemetary 422

TIL bs
00111111
00000011
00000011
00000011
00111111
00111111
00001111
00001111
NAME Cemetary 423

TIL bt
11111111
11111111
11111111
11111111
01111111
01111111
00111110
00111110
NAME Cemetary 424

TIL bu
11001111
11101111
11100111
11100111
11100111
11100111
00100011
00110011
NAME Cemetary 425

TIL bv
11111100
11000000
11000000
11000000
11111100
11111100
11100000
11100000
NAME Cemetary 426

TIL bw
00011111
00011111
00011111
00011111
00111111
00111111
00111111
00111111
NAME Cemetary 427

TIL bx
11111111
11111111
11111111
11111111
11111111
11111111
10001111
10001110
NAME Cemetary 428

TIL by
11111111
11111111
11111111
11111111
11100000
00000000
00000000
00000000
NAME Cemetary 429

TIL bz
11111100
11111100
11111100
11111100
01111100
00011100
00001100
00001100
NAME Cemetary 430

TIL c0
01111111
01111000
01111000
01111000
01111111
11111111
00111111
00111111
NAME Cemetary 431

TIL c1
10001111
00000000
00000000
00000000
10001111
10001111
10000001
10000001
NAME Cemetary 432

TIL c2
11110001
00000000
11110001
11110001
00000000
11110001
11110001
11110001
NAME Cemetary 433

TIL c3
10001111
00000000
10001111
10001111
00000000
10001110
10001100
10001000
NAME Cemetary 434

TIL c4
11111000
00000000
11111000
11111000
00000000
00000000
00000000
00000000
NAME Cemetary 435

TIL c5
11001110
00000000
11101110
11101110
00000000
11100110
01100110
00000110
NAME Cemetary 436

TIL c6
00001111
00000000
00001111
00001111
00000000
00001000
00001000
00000000
NAME Cemetary 437

TIL c7
11100000
00000000
10000000
00000000
00000000
00000001
00000001
00000001
NAME Cemetary 438

TIL c8
00011110
00000000
11111110
11111110
00000000
11111100
11111000
11110000
NAME Cemetary 439

TIL c9
00110011
00000000
00110011
00110011
00000000
00000001
00000000
00000000
NAME Cemetary 440

TIL ca
11100000
00000000
11100000
11100000
00000000
11100000
11100000
01100000
NAME Cemetary 441

TIL cb
01111000
00000000
01111000
01111000
00000000
01111000
01110000
01110000
NAME Cemetary 442

TIL cc
00011111
00000000
00011111
00111111
00000000
00111111
00111111
00111111
NAME Cemetary 443

TIL cd
10001110
00000000
10001100
10001100
00000000
10001100
10001100
10001100
NAME Cemetary 444

TIL ce
00001100
00000000
00000100
00000100
00000000
00000100
00000100
00000100
NAME Cemetary 445

TIL cf
00111111
00000000
00111111
00111111
00000000
00111111
00111111
00111111
NAME Cemetary 446

TIL cg
10000001
00000000
10000001
10000001
00000000
10000001
10000001
10000001
NAME Cemetary 447

TIL ch
11110001
11110001
11110001
11110001
11110001
11110001
11110001
01100000
NAME Cemetary 448

TIL ci
10000000
10000000
10000000
10000000
10000000
10000000
10000000
00000000
NAME Cemetary 449

TIL cj
00000110
00000010
00000010
00000010
00000010
00000010
00000010
00000010
NAME Cemetary 450

TIL ck
00001111
00001111
00001111
00011111
01111111
11111111
11111111
11111101
NAME Cemetary 451

TIL cl
01100000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Cemetary 452

TIL cm
01110000
01110000
01110000
01110000
01110000
00100000
00000000
00000000
NAME Cemetary 453

TIL cn
00111111
01111111
01111000
00000000
00000000
00000000
00000000
00000000
NAME Cemetary 454

TIL co
10001100
10001100
00001100
00000000
00000000
00000000
00000000
00000000
NAME Cemetary 455

TIL cp
00000100
00000100
00000000
00000000
00000000
00000000
00000000
00000000
NAME Cemetary 456

TIL cq
00101111
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Cemetary 457

TIL cr
10000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Cemetary 458

TIL cs
00000010
00000010
00000000
00000000
00000000
00000000
00000000
00000000
NAME Cemetary 459

TIL ct
00111101
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Cemetary 460

TIL cu
11100000
11100000
00100000
00000000
00000000
00000000
00000000
00000000
NAME Cemetary 461

TIL cv
11111000
11111000
11111000
11111000
11111000
11111000
11111100
10111100
NAME Cemetary 462

TIL cw
11111111
11111111
11111111
11111111
11111111
11111111
10111111
10111111
NAME Cemetary 463

TIL cx
11100111
11000111
10001111
10001111
00011111
00011111
00011111
01111111
NAME Cemetary 464

TIL cy
11111110
01111111
01111111
10111111
10111110
11011110
11011110
11101100
NAME Cemetary 465

TIL cz
00111111
00111111
00111111
00111111
00111111
00111011
01111011
01110011
NAME Cemetary 466

TIL d0
10111101
10001101
01110110
11111000
11111110
11111110
11111110
11111110
NAME Cemetary 467

TIL d1
00011111
10001111
11001111
11100111
00000000
11110000
11110000
11111000
NAME Cemetary 468

TIL d2
10111111
01111111
01111111
01111111
11111111
01111111
01111111
00011111
NAME Cemetary 469

TIL d3
01111111
11111111
11111111
11111011
11111011
11111101
11111101
11111100
NAME Cemetary 470

TIL d4
11111111
11111111
11111111
11111111
11111111
11111111
11111111
10111111
NAME Cemetary 471

TIL d5
11111111
11111111
11111111
11111111
11011111
10111111
10111111
01111111
NAME Cemetary 472

TIL d6
11110100
11110001
11100011
11100011
11000101
11001101
00001101
00011100
NAME Cemetary 473

TIL d7
11110111
11110111
11110111
11110111
11101111
00011111
01111111
11111111
NAME Cemetary 474

TIL d8
11111111
11111111
11011111
11011111
11101111
11101111
11110111
11111011
NAME Cemetary 475

TIL d9
01111000
01111100
01111100
01111101
00111101
10111101
10111011
10111011
NAME Cemetary 476

TIL da
10111111
00111110
10111110
10111101
10111101
11011101
11011111
11011011
NAME Cemetary 477

TIL db
01111111
11111111
11111111
11111111
11111111
11111111
11111100
11110010
NAME Cemetary 478

TIL dc
00011101
00011100
00101111
01101111
01110111
11110111
11111011
11111101
NAME Cemetary 479

TIL dd
11111110
11111110
01111110
10111110
10111110
11011110
11011110
11101111
NAME Cemetary 480

TIL de
00111111
11111111
11111111
11111111
11111111
11111111
11111111
01111111
NAME Cemetary 481

TIL df
11111011
11111011
11111101
11111101
11111110
11111110
11111110
11111111
NAME Cemetary 482

TIL dg
10100111
10001111
10011111
10111111
10111111
10111111
00111111
00111111
NAME Cemetary 483

TIL dh
11111111
11101111
11101111
11101111
11110111
11110111
11111011
11111011
NAME Cemetary 484

TIL di
11011011
11010111
11010111
11000111
11001111
11011111
11011111
11011111
NAME Cemetary 485

TIL dj
11111110
11111111
11111111
00111111
01111111
11111111
11111111
11111111
NAME Cemetary 486

TIL dk
11101110
01110110
10000110
11100110
11100010
11110010
11110010
11110000
NAME Cemetary 487

TIL dl
10111111
11011111
11011101
11011101
11011101
11101110
11101110
01110111
NAME Cemetary 488

TIL dm
11111111
11111011
11111001
11111001
11111100
11111110
11111110
01111110
NAME Cemetary 489

TIL dn
11111001
11111101
11111100
11011111
11011111
11101111
11110011
11111001
NAME Cemetary 490

TIL do
11011110
11011110
11011110
00011110
10011101
10011011
10010011
10010111
NAME Cemetary 491

TIL dp
11111000
11111000
11111000
11111000
11111100
11111100
11011100
11101100
NAME Cemetary 492

TIL dq
01110111
10111011
11111011
11011101
11101101
11101100
11110010
11110100
NAME Cemetary 493

TIL dr
01111110
10111110
10111111
10111111
10111111
00111111
11111111
11111111
NAME Cemetary 494

TIL ds
11111100
11111100
11111100
01111100
01111100
01111100
10111100
10111100
NAME Cemetary 495

TIL dt
10111100
10111100
11111100
11101100
11110100
11110000
11111000
11111100
NAME Cemetary 496

TIL du
11111100
11111100
11111100
11111100
11111100
00111100
00011100
00001100
NAME Cemetary 497

TIL dv
11001110
00000000
11101110
11101110
00000000
11100110
01100110
00100110
NAME Cemetary 498

TIL dw
11100000
00000000
10000000
00000000
00000000
00000001
00000001
00000011
NAME Cemetary 499

TIL dx
00111110
00000000
11111110
11111110
00000000
11111100
11111000
11110000
NAME Cemetary 500

TIL dy
11110001
11110001
11110001
11110001
11110001
11110001
11110001
01110000
NAME Cemetary 501

TIL dz
10001000
10000000
10000000
10000000
10000000
10000000
10000000
00000000
NAME Cemetary 502

TIL e0
00100110
00000010
00000010
00000010
00010010
00010010
00010010
00010010
NAME Cemetary 503

TIL e1
01100000
00100000
00100000
00100000
00100000
00100000
00100000
00100000
NAME Cemetary 504

TIL e2
00010010
00010010
00000000
00000000
00000000
00000000
00000000
00000000
NAME Cemetary 505

TIL e3
11111111
11111111
11111111
11111111
11111111
10111111
10111111
10111111
NAME Cemetary 506

TIL e4
11111111
11111111
11111111
11111111
11111111
01111111
01111111
01111110
NAME Cemetary 507

TIL e5
11111111
11111111
11111111
00010110
11111111
11111111
11111111
11111111
NAME Cemetary 508

TIL e6
11111111
11011111
11011111
00011111
11111111
11111111
11111111
11111111
NAME Cemetary 509

TIL e7
11111111
11111111
11111111
11110000
11111111
11111111
11111111
11111111
NAME Cemetary 510

TIL e8
10111111
11111111
11111111
10000111
11111111
10111111
10111111
11111111
NAME Cemetary 511

TIL e9
11111111
11111111
11111111
11100001
11111111
11111111
11111101
11111101
NAME Cemetary 512

TIL ea
01111110
01111100
11111100
00001100
01111000
01111000
01111000
01111000
NAME Cemetary 513

TIL eb
11111111
11111001
11111011
11111000
11111111
11111111
11111111
11111111
NAME Cemetary 514

TIL ec
11111111
01111111
11111111
01110000
10111111
11111111
11101111
11111111
NAME Cemetary 515

TIL ed
11111111
11111111
11111111
11111111
11110111
11110111
11111111
11111111
NAME Cemetary 516

TIL ee
11111111
11111111
11111111
11111111
10000001
00000000
00000000
00000000
NAME Cemetary 517

TIL ef
11111111
11111110
11111111
11111111
11111111
11111111
01111111
00111111
NAME Cemetary 518

TIL eg
11111101
11111101
11111101
11111101
11111101
11111101
11111101
01111101
NAME Cemetary 519

TIL eh
11111000
01111000
11111000
11111000
01111000
01111000
01110000
01110000
NAME Cemetary 520

TIL ei
10111111
10111111
10111111
10111111
10111111
11111111
11111111
11111111
NAME Cemetary 521

TIL ej
11111111
11111111
11111111
11111111
11111111
11110111
11111001
11111111
NAME Cemetary 522

TIL ek
11100000
10100000
10000000
00000000
00000000
00000000
00000000
00001000
NAME Cemetary 523

TIL el
01111101
00111101
00111101
00111101
00111101
00111101
00111111
00111111
NAME Cemetary 524

TIL em
01110000
01110000
01110000
01110000
01110011
01111111
11111111
11111111
NAME Cemetary 525

TIL en
11110000
11110000
11110000
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 526

TIL eo
11100000
11100000
11100000
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 527

TIL ep
11111111
11111111
11111111
11111111
11111111
11111111
11111110
11111111
NAME Cemetary 528

TIL eq
11111111
11111111
11111111
11111111
11111111
10000011
11111111
11111111
NAME Cemetary 529

TIL er
11111111
11111111
11111111
11111111
11111111
11110001
11110111
11111111
NAME Cemetary 530

TIL es
11111111
11111100
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 531

TIL et
11111111
11111111
11111111
11111111
11111111
11010000
11111111
11111111
NAME Cemetary 532

TIL eu
11111111
11111111
11111111
11111111
11111111
00000000
11111111
11111111
NAME Cemetary 533

TIL ev
11111111
11111111
11111111
11111111
11111111
00000001
11111111
11111111
NAME Cemetary 534

TIL ew
00111111
00111111
00111111
00111111
00111111
00111011
01111111
01111011
NAME Cemetary 535

TIL ex
10111111
10001111
01110111
11111000
11111111
11111111
11111111
11111111
NAME Cemetary 536

TIL ey
11111111
01111111
01111111
01111111
11111111
01111111
01111111
00011111
NAME Cemetary 537

TIL ez
11111100
11110001
11100011
11100111
11000101
11001111
10001111
00011111
NAME Cemetary 538

TIL f0
11111000
11111110
11111110
11111111
00111111
11111111
11111111
11111111
NAME Cemetary 539

TIL f1
11111111
01111110
11111110
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 540

TIL f2
00011111
00011111
00111111
01111111
01111111
11111111
11111111
11111111
NAME Cemetary 541

TIL f3
10111111
11001111
10011111
11111111
11111111
11111111
11111111
01111111
NAME Cemetary 542

TIL f4
11111011
11110111
11110111
11110111
11101111
11111111
11111111
11111111
NAME Cemetary 543

TIL f5
11111111
11111111
11111111
11111111
11110011
11111111
11111111
11111000
NAME Cemetary 544

TIL f6
11111101
11111111
11111111
11111111
11111111
11111111
11111111
11111001
NAME Cemetary 545

TIL f7
11111110
11111110
11111110
01011110
11011111
11011011
11011111
11010111
NAME Cemetary 546

TIL f8
11111111
11101111
11101111
11101111
11101111
11101111
11101111
11111111
NAME Cemetary 547

TIL f9
11111010
11111010
11111010
11111010
11111110
11111111
11111110
11111110
NAME Cemetary 548

TIL fa
01111111
11111111
11111111
11111111
11111111
11111110
11111111
11111111
NAME Cemetary 549

TIL fb
01111110
11111110
11111111
11111111
11111111
01111111
11111111
11111111
NAME Cemetary 550

TIL fc
11111110
11111111
11111111
01111111
01111111
11111111
11111111
10111111
NAME Cemetary 551

TIL fd
11101111
11011111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 552

TIL fe
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11101111
NAME Cemetary 553

TIL ff
11111110
11111110
11111110
11111000
11111110
11111110
11111110
11111110
NAME Cemetary 554

TIL fg
11111011
11111100
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 555

TIL fh
11111111
11111111
11111111
11111111
00111111
01111111
01111111
11110011
NAME Cemetary 556

TIL fi
11111100
11111100
11111110
11111110
10111111
11111111
11111111
11111111
NAME Cemetary 557

TIL fj
11111111
11111111
11111111
11111111
11110001
11111111
11111111
11111111
NAME Cemetary 558

TIL fk
11111111
11111111
11111111
10111111
11011111
11010111
11011111
11011111
NAME Cemetary 559

TIL fl
11111110
11111110
11111110
11111110
11111110
11111110
11111111
11111110
NAME Cemetary 560

TIL fm
10111111
11011111
11111111
11111111
11111101
11111111
11111111
11111111
NAME Cemetary 561

TIL fn
11011111
11011111
11111111
11001111
11011110
11111110
11111110
11111110
NAME Cemetary 562

TIL fo
10011111
11111111
11111111
11111111
11101111
01101111
01101111
11111111
NAME Cemetary 563

TIL fp
11111110
11111110
11111110
11111110
11111110
11111010
11111000
11111110
NAME Cemetary 564

TIL fq
11111111
11111111
11111111
11111111
11111111
11111111
11111001
11111000
NAME Cemetary 565

TIL fr
11011110
11000000
11000000
11000000
11011110
11111110
11011110
10011110
NAME Cemetary 566

TIL fs
11111111
11111111
11111111
11111111
01111111
01111111
00111111
00111110
NAME Cemetary 567

TIL ft
11101111
11101111
11111111
11111111
11111111
11111111
00110111
00110111
NAME Cemetary 568

TIL fu
11111111
11111111
11111111
11111111
11111110
00111110
00011110
00001110
NAME Cemetary 569

TIL fv
11111111
11111000
11111000
11111000
11111111
11111111
00111111
00111111
NAME Cemetary 570

TIL fw
11111110
00100000
11111110
11111110
00000000
11111110
01111110
00111110
NAME Cemetary 571

TIL fx
00110111
00000100
00110111
00110111
00000000
00000001
00000000
00000000
NAME Cemetary 572

TIL fy
00001110
00000000
00000110
00000110
00000100
00000110
00000110
00000110
NAME Cemetary 573

TIL fz
10001000
10000000
10000000
10000000
10000000
10000000
10000000
11000000
NAME Cemetary 574

TIL g0
00111110
00001110
00001110
00000110
00010110
00010110
00010110
00010110
NAME Cemetary 575

TIL g1
01100000
00100000
00100000
00100000
00100000
00110000
00110000
00110011
NAME Cemetary 576

TIL g2
01110000
01110000
01110000
01110000
01110000
00110001
00101111
10111111
NAME Cemetary 577

TIL g3
00111111
01111111
01111111
01111001
11111111
11111111
11111111
11111111
NAME Cemetary 578

TIL g4
10001100
10001100
10001100
00001100
11111111
11111111
11111111
11111111
NAME Cemetary 579

TIL g5
00000000
00000000
00000000
01111111
11111111
11111111
11111111
11111111
NAME Cemetary 580

TIL g6
00000110
00000110
00000100
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 581

TIL g7
00111111
00000000
01111111
11111111
11111111
11111111
11111111
11111000
NAME Cemetary 582

TIL g8
10000001
01110111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 583

TIL g9
01111111
11111111
11111111
11111111
11111111
11111111
11111111
11110111
NAME Cemetary 584

TIL ga
11000000
11100000
11100000
11110000
11111111
01111110
00000000
00000000
NAME Cemetary 585

TIL gb
00000000
00000000
00000000
11111111
11111111
01111111
01111111
00111111
NAME Cemetary 586

TIL gc
00010110
00010110
00010110
11111111
11111111
11111111
11111111
11111000
NAME Cemetary 587

TIL gd
00001000
01011111
01111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 588

TIL ge
11111111
10000000
11111110
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 589

TIL gf
11100000
11100000
11100000
10100000
11111111
11111111
11111111
11111111
NAME Cemetary 590

TIL gg
00000000
00000001
00000011
01111111
11111111
11111111
11111111
11111111
NAME Cemetary 591

TIL gh
00101111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 592

TIL gi
11111111
11111111
11111111
11111111
11111110
01111000
00000000
00000000
NAME Cemetary 593

TIL gj
11111111
11111111
11111111
11111111
00000000
00000000
00000000
01111000
NAME Cemetary 594

TIL gk
11111111
11111111
11111111
11111111
11111111
11111111
00001111
00001111
NAME Cemetary 595

TIL gl
11111111
11111111
11111111
11111111
11111111
11101110
10000000
10000000
NAME Cemetary 596

TIL gm
11111000
11111111
11111111
11111111
11111111
01111111
00000011
00000000
NAME Cemetary 597

TIL gn
11100000
11101111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 598

TIL go
00001110
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 599

TIL gp
00001111
00000011
00000011
11100011
11111111
11111111
11111111
11111111
NAME Cemetary 600

TIL gq
11111000
11111110
11111111
11111111
11111111
11111110
11111110
11111110
NAME Cemetary 601

TIL gr
11111111
11111111
11111111
11111101
11110000
00000000
00000000
00000011
NAME Cemetary 602

TIL gs
11111111
11111111
11111111
11111001
00000000
00000000
11111000
11111111
NAME Cemetary 603

TIL gt
11111111
11111111
11111111
11111111
00011111
00001111
00001111
11111111
NAME Cemetary 604

TIL gu
11111111
11111111
11111111
11111111
11111111
11111111
10101111
10001111
NAME Cemetary 605

TIL gv
00000000
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 606

TIL gw
11111110
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 607

TIL gx
00001111
11111111
11111111
11111111
10011111
10001111
11001111
11111111
NAME Cemetary 608

TIL gy
11111000
11111000
11111000
11111000
11111111
11111111
11111111
11111111
NAME Cemetary 609

TIL gz
00001110
01011111
01111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 610

TIL h0
10001111
10001111
10001111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 611

TIL h1
11111111
11111111
11111111
11000011
10000000
10000000
10000000
10011000
NAME Cemetary 612

TIL h2
11111111
11111111
11111111
11111110
00000000
00000000
00000000
00110001
NAME Cemetary 613

TIL h3
11111111
11111111
11111111
11101111
00000000
00000000
00000000
11101011
NAME Cemetary 614

TIL h4
11111111
11111111
11111111
01111111
01111111
00111111
11111111
11111111
NAME Cemetary 615

TIL h5
11110001
11110001
11110001
11110001
11111100
11111100
11111100
11111100
NAME Cemetary 616

TIL h6
11100001
11100001
11100000
11100000
11110000
11110000
11110000
11110000
NAME Cemetary 617

TIL h7
11110001
11111100
11111100
11111110
11111100
11111000
11110000
11110001
NAME Cemetary 618

TIL h8
00000000
10000000
10000000
11000000
11000000
11100000
11100000
11100000
NAME Cemetary 619

TIL h9
11110001
11100111
11100111
11001111
10011111
10011111
10011111
00111111
NAME Cemetary 620

TIL ha
11000011
11000001
11000001
11000001
11100000
11100000
11100000
11100000
NAME Cemetary 621

TIL hb
00011111
10011111
10011111
10011111
10011111
00011111
00011111
00111111
NAME Cemetary 622

TIL hc
10000001
11000001
11000001
11100001
11110000
11110000
11110000
11110000
NAME Cemetary 623

TIL hd
11111111
11111111
11111111
11111111
11111000
11110000
11110001
11110001
NAME Cemetary 624

TIL he
11111100
11111110
11111110
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 625

TIL hf
00010000
00001000
00001000
00000000
11100000
11100000
11100000
11110000
NAME Cemetary 626

TIL hg
11110001
11110111
11110111
01100111
00001111
00001111
00011111
00011111
NAME Cemetary 627

TIL hh
11110000
11110000
11110000
11110000
11111000
11111000
11111000
11111000
NAME Cemetary 628

TIL hi
11111110
11111110
11111100
11111000
11111001
11111001
11110011
11100111
NAME Cemetary 629

TIL hj
11111111
11011111
11011111
11001111
11101111
11101111
11100111
11110111
NAME Cemetary 630

TIL hk
11110000
11110000
11110000
11111000
11111000
11111110
11111110
11111111
NAME Cemetary 631

TIL hl
00011100
00011000
00011100
00010001
00001111
00001111
00001111
00001111
NAME Cemetary 632

TIL hm
11111000
11111000
11111000
11111100
11111110
11111110
11111110
11111110
NAME Cemetary 633

TIL hn
01111111
01111111
01111111
00011110
00000000
00000111
00000111
00011111
NAME Cemetary 634

TIL ho
11100001
11000111
00000111
00011111
11111111
11111111
11111111
11111111
NAME Cemetary 635

TIL hp
11111111
11111111
11111111
11111111
10111111
00011111
00001111
10000001
NAME Cemetary 636

TIL hq
11110000
11110000
11110000
11110000
11110000
11110000
11111000
00011100
NAME Cemetary 637

TIL hr
00111111
00011111
00011111
00011111
00011111
00011111
00001111
00001111
NAME Cemetary 638

TIL hs
01111111
01111111
01111111
01111111
01111110
01111110
01111110
01111000
NAME Cemetary 639

TIL ht
11000111
10000111
10000111
10001111
00011111
00011111
00011111
00111111
NAME Cemetary 640

TIL hu
11110011
11111001
11111001
11111100
11111111
11111111
11111111
11111111
NAME Cemetary 641

TIL hv
11111111
11111111
11111110
00001110
11000000
11111100
11111100
11111110
NAME Cemetary 642

TIL hw
00011111
00011111
00011111
00011111
00011111
00011011
00111011
01110011
NAME Cemetary 643

TIL hx
11111100
11111110
11111110
11111110
11111111
11111111
11111111
11111111
NAME Cemetary 644

TIL hy
00001101
00001101
00000110
01110000
11111110
11111110
11111110
11111110
NAME Cemetary 645

TIL hz
00001111
00001111
10001111
11000111
00000000
11110000
11110000
11110000
NAME Cemetary 646

TIL i0
10111111
01111111
01111111
01111111
11111111
01111111
01111111
00001111
NAME Cemetary 647

TIL i1
01111000
01111000
00001001
00000001
01100111
01100111
01000111
00001111
NAME Cemetary 648

TIL i2
11110000
11110000
11100001
11100011
11000101
10001101
00000101
00001100
NAME Cemetary 649

TIL i3
11110111
11110111
11110111
11110111
11101111
00011111
01011111
11111111
NAME Cemetary 650

TIL i4
11111111
11111111
11011111
11001111
11101111
11101111
11110111
11110001
NAME Cemetary 651

TIL i5
01110000
01111100
01111100
01111100
00111101
10111101
10111001
10111011
NAME Cemetary 652

TIL i6
00001111
00001111
00000111
00000011
10000001
11100000
11100000
11111000
NAME Cemetary 653

TIL i7
11111110
11111110
11111110
11111110
11111110
11111110
00001110
00001100
NAME Cemetary 654

TIL i8
00011111
00011111
00111111
01111111
01111111
01111111
01111111
01111111
NAME Cemetary 655

TIL i9
10111111
00111110
10111110
10111101
10111101
11011101
11011001
11011011
NAME Cemetary 656

TIL ia
01111111
11111111
11111111
11111111
11111111
11111111
11111100
11110000
NAME Cemetary 657

TIL ib
11111100
11111000
11111100
11111000
11111000
11111001
00000011
00000111
NAME Cemetary 658

TIL ic
00001111
10000111
10000111
10000111
11000001
11000001
11000000
11000000
NAME Cemetary 659

TIL id
11111111
11111110
11111110
11111110
11111000
11111000
11111000
11111000
NAME Cemetary 660

TIL ie
00001101
00011100
00001111
00101111
01110111
01110111
01110011
01111101
NAME Cemetary 661

TIL if
11111001
11111001
11111101
11111101
11111110
11111110
11111110
11111111
NAME Cemetary 662

TIL ig
10000111
10001111
10001111
10011111
10111111
10111111
00111111
00111111
NAME Cemetary 663

TIL ih
11000000
11100000
11100000
11111000
11110000
11110000
11110000
11100000
NAME Cemetary 664

TIL ii
11111000
11111000
11111100
11111110
11111111
11111111
11111111
11111111
NAME Cemetary 665

TIL ij
01111000
01111000
01110000
00010000
00000000
00000000
10000000
11000001
NAME Cemetary 666

TIL ik
11111110
11111111
11111111
00011111
01111111
01111111
11111111
11111111
NAME Cemetary 667

TIL il
11101110
01110110
00000110
11100110
11100010
11110010
11110010
11110000
NAME Cemetary 668

TIL im
10011111
11011111
11011101
11011101
11011101
11101110
11101110
01110111
NAME Cemetary 669

TIL in
11111111
11110001
11110000
11110000
11111100
11111110
11111110
01111110
NAME Cemetary 670

TIL io
11000000
10000000
10000000
00000000
00001111
00001111
00001111
00000111
NAME Cemetary 671

TIL ip
11111100
11111100
11111100
11111100
11111100
00011100
00001100
00001100
NAME Cemetary 672

TIL iq
00000110
00000010
00000010
00000010
00000010
00010010
00010010
00010010
NAME Cemetary 673

TIL ir
00001111
00001111
00011111
00011111
01111111
11111111
11111111
11111101
NAME Cemetary 674

TIL is
01100000
00000000
00000000
00000000
00000000
00100000
00100000
00000000
NAME Cemetary 675

TIL it
00010010
00000010
00000000
00000000
00000000
00000000
00000000
00000000
NAME Cemetary 676

TIL iu
00000000
00100000
00100000
01110000
11111100
01110000
01100000
00110000
NAME Cemetary 677

TIL iv
00000000
00000000
00000000
00010000
00010000
00000000
00000000
00000000
NAME Cemetary 678

TIL iw
00000110
00000000
00000000
00000000
00000000
00000000
10000000
00000000
NAME Cemetary 679

TIL ix
00001000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Cemetary 680

TIL iy
00000000
00000000
00000000
00000000
01000000
00000000
00000000
00000000
NAME Cemetary 681

TIL iz
00000000
00110000
00100000
00000000
00000000
00000000
00000000
00000000
NAME Cemetary 682

TIL j0
00000000
00000000
00110000
00000000
00000000
00000000
00000000
00000000
NAME Cemetary 683

TIL j1
00001000
00001000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Cemetary 684

TIL j2
00000000
10000000
10000000
00000000
00000000
00000000
00000000
00000000
NAME Cemetary 685

TIL j3
00000000
00000000
00000000
10000000
00000000
00000000
00000000
00000000
NAME Cemetary 686

TIL j4
00000000
00000000
00000000
00011111
00000000
00000000
00000000
00000000
NAME Cemetary 687

TIL j5
00000000
00000000
00000000
01110000
00000000
00000000
00000000
00000000
NAME Cemetary 688

TIL j6
00000000
00000000
00000000
00010000
00000000
00000000
00000000
00000000
NAME Cemetary 689

TIL j7
00000000
00000000
00000000
00000000
00000000
00000000
10000000
10000000
NAME Cemetary 690

TIL j8
00000000
00000000
00000000
00000000
00000000
00000000
01111111
11111111
NAME Cemetary 691

TIL j9
00000000
00000000
00000000
00000000
00000000
00000000
11100000
11111110
NAME Cemetary 692

TIL ja
00000000
00000000
00000000
00000000
00010000
00111111
01111111
11111111
NAME Cemetary 693

TIL jb
00000000
00000000
00000000
00000000
11110000
11111000
11111110
11111110
NAME Cemetary 694

TIL jc
00000000
00000000
00000000
00000000
00000001
00000000
00000000
00000001
NAME Cemetary 695

TIL jd
00000000
00100000
00100000
01110000
11111100
01110000
11110000
11111111
NAME Cemetary 696

TIL je
00000000
00000000
00000000
00000000
00000000
00000000
00000000
01100011
NAME Cemetary 697

TIL jf
00000000
00000000
00000000
00000000
00000000
01100000
01111110
01111110
NAME Cemetary 698

TIL jg
00000000
00000000
00000000
00000000
00000000
00000000
00001111
00000111
NAME Cemetary 699

TIL jh
00000000
00000000
00000000
00000000
00000000
00000111
11111111
11111111
NAME Cemetary 700

TIL ji
00000000
00000000
00000000
00000000
00011111
11101111
11110011
11111001
NAME Cemetary 701

TIL jj
00000000
00000000
00000010
00011110
10011101
10011001
10010011
10010111
NAME Cemetary 702

TIL jk
00000011
00111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 703

TIL jl
11111110
11111111
11111111
11110111
11110111
11110001
11111001
11111000
NAME Cemetary 704

TIL jm
01000000
11000111
11000111
10000111
10000111
00001111
00001111
00001111
NAME Cemetary 705

TIL jn
00000000
10000000
11000000
11110011
11111111
11111111
11111111
11111111
NAME Cemetary 706

TIL jo
00000000
00000000
00000000
11111000
11111100
11111100
11001100
11101100
NAME Cemetary 707

TIL jp
10111111
10111111
10110111
01110111
01110111
01110111
01110111
11110111
NAME Cemetary 708

TIL jq
00000011
00001111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 709

TIL jr
01110111
10011001
10011001
11011101
11101100
11101100
11100000
11110100
NAME Cemetary 710

TIL js
01111110
10111110
10111110
10111111
10111111
00111111
10111111
11111111
NAME Cemetary 711

TIL jt
00000111
00000011
00000001
00000001
11100001
11100000
11100000
11110000
NAME Cemetary 712

TIL ju
11111100
11111110
01111110
01111111
01111111
01111111
10111111
10111111
NAME Cemetary 713

TIL jv
11111111
11111110
11111100
11111001
11111001
11110111
11101111
11001111
NAME Cemetary 714

TIL jw
00011111
00011111
00011111
00011111
01111111
01111111
01111111
01111111
NAME Cemetary 715

TIL jx
11110100
11110100
11110000
11111000
11111100
11111100
11111100
11111100
NAME Cemetary 716

TIL jy
11111000
11111000
11111000
01111100
01111110
01111110
01111110
01111111
NAME Cemetary 717

TIL jz
11111111
01111111
01111111
01111111
00111111
00111111
00111000
10000001
NAME Cemetary 718

TIL k0
11111000
11111100
11111100
11111110
10111110
01111111
11111111
11111111
NAME Cemetary 719

TIL k1
01111111
00011111
00011111
00011111
00001111
00001111
00001111
00001111
NAME Cemetary 720

TIL k2
10011111
11011111
11011111
11101111
11110001
11111110
11111111
11111111
NAME Cemetary 721

TIL k3
00111111
10111111
10011100
10011101
10011001
10010111
00001111
10011111
NAME Cemetary 722

TIL k4
10011111
01111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 723

TIL k5
11111000
11111000
11111000
11110000
11110000
11110000
11100000
11100000
NAME Cemetary 724

TIL k6
01111111
01111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 725

TIL k7
11111100
11111100
01111100
01111100
01111100
01111100
00111100
10111100
NAME Cemetary 726

TIL k8
01101111
01001111
01001111
10011111
00111111
01111111
01111111
01111111
NAME Cemetary 727

TIL k9
11111111
11111111
11111111
11111111
11110000
11110000
11110000
11110000
NAME Cemetary 728

TIL ka
00011111
10001111
10001111
11100111
11111001
11111100
11111110
11111110
NAME Cemetary 729

TIL kb
10000111
10001111
10001111
10001111
10001110
10011110
10011110
00011110
NAME Cemetary 730

TIL kc
11111111
11111111
11111111
11111111
00011111
00011111
00011111
00011111
NAME Cemetary 731

TIL kd
10001111
11001111
11001111
11000111
11100111
11100111
11100111
11110000
NAME Cemetary 732

TIL ke
10011110
11011110
11011101
11001001
11001011
01100111
01101111
10101111
NAME Cemetary 733

TIL kf
11000000
11000001
11000001
00000111
00000111
00000111
00000111
00001111
NAME Cemetary 734

TIL kg
10111100
10111100
10001100
11101100
11110100
11110000
11110000
11111100
NAME Cemetary 735

TIL kh
11111111
11111111
11111111
11111111
11001111
11001111
00011111
10011111
NAME Cemetary 736

TIL ki
11111111
11111111
11111111
11111111
00001111
10001111
10001111
10001111
NAME Cemetary 737

TIL kj
11110000
00000000
00000000
00000000
11110000
11110000
11110000
11110000
NAME Cemetary 738

TIL kk
11111111
00001111
00001111
00001111
11111111
11111111
10001111
10001111
NAME Cemetary 739

TIL kl
00001110
10000000
10000000
10000000
10001110
10011110
10011110
10001110
NAME Cemetary 740

TIL km
00011111
00000001
00000001
00000001
00011111
00011111
00001111
00001111
NAME Cemetary 741

TIL kn
11110000
11111000
11111000
11111000
11111000
11111000
11111000
11111000
NAME Cemetary 742

TIL ko
11111111
11111111
11111111
11111111
01111111
01111111
00011110
00011110
NAME Cemetary 743

TIL kp
11001111
11101111
11100111
11100111
11100111
11100111
00000011
00010011
NAME Cemetary 744

TIL kq
11111100
11000000
11000000
11000000
11111000
11111100
11100000
11100000
NAME Cemetary 745

TIL kr
01111110
00000100
00000100
00000100
01110000
01111000
01111000
01111000
NAME Cemetary 746

TIL ks
00001111
00001111
00001111
00011111
00011111
00011111
00011111
00011111
NAME Cemetary 747

TIL kt
11111111
11111111
11111111
11111111
10000000
00000000
00000000
00000000
NAME Cemetary 748

TIL ku
11111100
11111100
11111100
11111100
00111100
00011100
00001100
00000100
NAME Cemetary 749

TIL kv
00001111
00000000
00000000
00000000
00001111
10001111
10000001
10000000
NAME Cemetary 750

TIL kw
11110000
00000000
11100000
11110000
00000000
11110000
11110000
11110000
NAME Cemetary 751

TIL kx
00001111
00000000
00001111
10001111
00000000
10001110
10001000
10000000
NAME Cemetary 752

TIL ky
11110000
00000000
11110000
11111000
00000000
00000000
00000000
00000000
NAME Cemetary 753

TIL kz
10001110
00000000
11101110
11101110
00000000
11100110
01100110
00000110
NAME Cemetary 754

TIL l0
11100000
00000000
00000000
00000000
00000000
00000000
00000000
00000001
NAME Cemetary 755

TIL l1
00011110
00000000
00011110
11111110
00000000
11111000
11111000
11110000
NAME Cemetary 756

TIL l2
00010001
00000000
00010001
00110011
00000000
00000000
00000000
00000000
NAME Cemetary 757

TIL l3
01110000
00000000
01110000
01111000
00000000
01110000
01110000
01110000
NAME Cemetary 758

TIL l4
00011111
00000000
00011111
00011111
00000000
00011111
00011111
00011111
NAME Cemetary 759

TIL l5
00001100
00000000
00000000
10001000
00000000
10001000
10001000
10001000
NAME Cemetary 760

TIL l6
00000000
00000000
00000100
00000100
00000000
00000100
00000100
00000100
NAME Cemetary 761

TIL l7
00011111
00000000
00011111
00111111
00000000
00011111
00111111
00011111
NAME Cemetary 762

TIL l8
00000000
00000000
00000000
10000000
00000000
00000000
10000000
10000001
NAME Cemetary 763

TIL l9
11110000
11110000
11110000
11110000
11110000
11110000
11110000
01100000
NAME Cemetary 764

TIL la
10000000
10000000
10000000
10000000
10000000
10000000
00000000
00000000
NAME Cemetary 765

TIL lb
00000110
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Cemetary 766

TIL lc
00001011
00001111
00001111
00001111
00011111
11111111
11111111
11111101
NAME Cemetary 767

TIL ld
00100000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Cemetary 768

TIL le
01110000
01110000
01110000
01110000
01110000
00000000
00000000
00000000
NAME Cemetary 769

TIL lf
00011111
01111111
01111000
00000000
00000000
00000000
00000000
00000000
NAME Cemetary 770

TIL lg
10001000
10001000
00001000
00000000
00000000
00000000
00000000
00000000
NAME Cemetary 771

TIL lh
00001111
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Cemetary 772

TIL li
00000010
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Cemetary 773

TIL lj
00011101
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Cemetary 774

TIL lk
11100000
11100000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Cemetary 775

TIL ll
00000000
00000000
00000000
00000000
10000000
10000000
10000000
00000000
NAME Cemetary 776

TIL lm
00000000
00000000
10000000
00000000
00000000
00000000
00000000
00000000
NAME Cemetary 777

TIL ln
00000000
00000000
00110000
00100000
00000000
00000000
00000000
00000000
NAME Cemetary 778

TIL lo
00000000
00000000
01000000
00000000
10000000
00000000
00000000
00000000
NAME Cemetary 779

TIL lp
00000000
00000000
00000000
00000000
00100000
01110000
00100000
00000000
NAME Cemetary 780

TIL lq
00000001
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Cemetary 781

TIL lr
00000000
00000000
00000000
00000000
01100000
00000000
00000000
00000000
NAME Cemetary 782

TIL ls
00000000
00000000
00000000
00000000
00100000
01110000
11110000
01110000
NAME Cemetary 783

TIL lt
00000000
00000000
00000000
00000000
00000000
00000000
00100000
00000000
NAME Cemetary 784

TIL lu
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000001
NAME Cemetary 785

TIL lv
00000000
00000000
00000000
00000000
00010000
00011000
00011000
01111110
NAME Cemetary 786

TIL lw
00000000
00000000
01000000
00000000
00000000
00000000
00000000
00000000
NAME Cemetary 787

TIL lx
00000000
00000000
00000000
00000000
10000000
00000000
00000000
00000000
NAME Cemetary 788

TIL ly
00000000
00000000
00000000
11100000
00000000
00000000
00000000
00000000
NAME Cemetary 789

TIL lz
00001000
00001000
00001000
00000000
00000000
00000000
00000000
00000000
NAME Cemetary 790

TIL m0
00000000
00000000
00000000
00000000
00000001
00000011
00000111
00000011
NAME Cemetary 791

TIL m1
00000000
00000000
00000000
00000000
00000001
10000000
10000000
10000000
NAME Cemetary 792

TIL m2
00000001
00000000
00100000
00000000
10000000
00000000
00000000
00000000
NAME Cemetary 793

TIL m3
11111111
01111000
00111000
00011000
00000000
00000000
00000000
00000000
NAME Cemetary 794

TIL m4
00000000
00000001
00000001
00000000
00000000
00000000
00000000
00000000
NAME Cemetary 795

TIL m5
00000000
00000000
00000000
00000000
00000110
00000000
00000000
00000000
NAME Cemetary 796

TIL m6
00000000
00000000
00000000
00000000
00000000
01000000
01100000
01000000
NAME Cemetary 797

TIL m7
00000000
00000000
00000000
00000000
00000000
00000000
00000001
00000000
NAME Cemetary 798

TIL m8
00000000
00000000
00000000
00010000
00011000
00000000
00000001
00000000
NAME Cemetary 799

TIL m9
00000000
00000000
00000000
00000000
01000000
11100000
11110000
11100000
NAME Cemetary 800

TIL ma
00000000
00001000
00001000
00000000
00000000
00000000
00000000
00000000
NAME Cemetary 801

TIL mb
00001000
00000100
00000000
00000000
00000000
00000000
00000000
00000000
NAME Cemetary 802

TIL mc
00010000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Cemetary 803

TIL md
00000000
00000000
00000000
00000110
00000000
00000000
00000000
00000000
NAME Cemetary 804

TIL me
00000000
00000000
00000000
00000000
01010000
00000000
00000000
00000000
NAME Cemetary 805

TIL mf
00000000
00000000
00000000
00000000
00000010
00000000
00000000
00000000
NAME Cemetary 806

TIL mg
00000000
00000000
00000000
00000000
00110000
00000000
00000000
00000000
NAME Cemetary 807

TIL mh
00000000
00000000
00000000
00000000
00000000
00000000
00000000
10000000
NAME Cemetary 808

TIL mi
00000000
00001000
00001000
00001000
00000000
00000000
00000000
00000000
NAME Cemetary 809

TIL mj
00000000
00000000
00000000
00000000
00001000
00000000
00000000
00000000
NAME Cemetary 810

TIL mk
00000101
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Cemetary 811

TIL ml
00000000
00000000
00000000
00000000
00000001
00000000
11100000
11111110
NAME Cemetary 812

TIL mm
00000000
00000000
00000000
00000000
11110000
11111000
11111111
11111111
NAME Cemetary 813

TIL mn
00000000
00110000
00110000
11110000
11111110
11110000
11110000
11111111
NAME Cemetary 814

TIL mo
00000000
00000000
00000000
00000000
00000000
00001000
00001000
01100011
NAME Cemetary 815

TIL mp
00000000
00000000
00000000
00000000
00000000
01110000
11111110
01111110
NAME Cemetary 816

TIL mq
00000000
00000000
00000000
00000000
00001000
00001000
00001111
00000111
NAME Cemetary 817

TIL mr
00000000
00000000
00000010
00011110
10011101
10011011
10010011
10010111
NAME Cemetary 818

TIL ms
01000000
11000111
11000111
11001111
10001111
10011111
00011111
00011111
NAME Cemetary 819

TIL mt
00000000
00000000
00000000
11111000
11111100
11111100
11011100
11101100
NAME Cemetary 820

TIL mu
00000111
11101111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cemetary 821

TIL mv
00000111
00000111
00000001
10000001
11100001
11100000
11100000
11111000
NAME Cemetary 822

TIL mw
11110001
00000000
11110000
11110001
00000000
11110001
11110001
11110001
NAME Cemetary 823

TIL mx
10001111
00000000
10001111
10001111
00000000
10001110
10001100
10000000
NAME Cemetary 824

TIL my
00011110
00000000
11111110
11111110
00000000
11111000
11111000
11110000
NAME Cemetary 825

TIL mz
00011111
00000000
00011111
00111111
00000000
00011111
00111111
00111111
NAME Cemetary 826

TIL n0
00000100
00000000
00000100
00000100
00000000
00000100
00000100
00000100
NAME Cemetary 827

TIL n1
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
WAL true

TIL n2
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL n3
00000000
00000000
00000000
00000000
00000000
00000000
00000001
00000111
NAME splashf 1

TIL n4
00000000
00000000
00000000
00000000
00000000
00111111
11111111
11111111
NAME splashf 2

TIL n5
00000000
00000000
00000000
00000000
00000000
11000000
11111100
11111110
NAME splashf 3

TIL n6
00000000
00000000
00000000
00000000
00000000
00000000
00000001
00000001
NAME splashf 4

TIL n7
00001111
00011111
00111111
01111111
11100001
11000000
11011111
11111111
NAME splashf 5

TIL n8
11110000
11100000
11100000
11100000
11111000
01111001
11111111
11111111
NAME splashf 6

TIL n9
01111111
00111000
00100000
01001111
11111110
11111111
11111101
11111000
NAME splashf 7

TIL na
10000000
11000000
11100000
11110000
01110000
11011000
10011100
11111100
NAME splashf 8

TIL nb
00000001
00000011
00000011
00000011
00000011
00000011
00000011
00000011
NAME splashf 9

TIL nc
11111100
11110000
11100000
11100000
11000000
11000000
11000000
11100000
NAME splashf 10

TIL nd
11111111
00111111
00011111
00011111
00001111
00001110
00001111
00011111
NAME splashf 11

TIL ne
10011000
10000000
11000000
10000000
00000000
00000000
00000000
10000000
NAME splashf 12

TIL nf
10001100
00001100
00011110
00011110
00000110
00000110
00000110
00011110
NAME splashf 13

TIL ng
00000000
00000000
00000000
00000000
00000000
00000111
00001111
00011000
NAME splashf 14

TIL nh
00000000
00000000
00000000
00000000
00000000
11110000
11111100
00001110
NAME splashf 15

TIL ni
00000011
00000011
00000011
00000011
00000011
00000011
00000011
00000001
NAME splashf 16

TIL nj
11100000
11110000
11111111
11111111
11111111
11111111
11111111
11111111
NAME splashf 17

TIL nk
00011111
00111111
11111101
11111000
11110000
11100000
11100000
11000010
NAME splashf 18

TIL nl
10000000
10000000
11111000
11111000
01111111
00111111
00011111
00011111
NAME splashf 19

TIL nm
00011110
00001110
11011110
11111110
11111110
11111110
11111100
11111100
NAME splashf 20

TIL nn
00000000
00000000
00000000
00000000
00000000
00111111
01111111
11000000
NAME splashf 21

TIL no
00000000
00000000
00000000
00000000
00000000
10000000
11000000
01100000
NAME splashf 22

TIL np
00110000
00110000
00110000
00110000
00010000
00011000
00000110
00000000
NAME splashf 23

TIL nq
00000111
00000001
00000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 24

TIL nr
00000000
10000000
11000000
01100000
00110000
00011110
00000000
00000000
NAME splashf 25

TIL ns
11111111
11111111
00111111
00000111
00000111
00000111
00000111
00000111
NAME splashf 26

TIL nt
11100010
11110111
11111111
11111111
11111111
11111111
11110011
11111111
NAME splashf 27

TIL nu
00011111
00111111
11111111
11111111
11111110
11110010
10110010
11110010
NAME splashf 28

TIL nv
11111100
11111000
10000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 29

TIL nw
00000000
00000000
00000000
00000000
00000000
00000001
00000000
00000000
NAME splashf 30

TIL nx
00000011
00000110
00001100
00111000
00110000
11100000
00000000
00000000
NAME splashf 31

TIL ny
10000000
00000000
00000000
00000000
00000000
00000000
00000001
00000000
NAME splashf 32

TIL nz
00110000
00110000
00010000
00110000
00110000
01100000
00000000
00000000
NAME splashf 33

TIL o0
00000011
00000011
00000001
00000000
00000000
00000000
00000000
00000000
NAME splashf 34

TIL o1
11111111
11111111
11111111
00111111
00000000
00000000
00000000
00000000
NAME splashf 35

TIL o2
11111110
11111110
11111100
00000000
00000000
00000000
00000000
00000000
NAME splashf 36

TIL o3
00000000
00000000
00000000
00000000
00010000
00111000
00011000
00001100
NAME splashf 37

TIL o4
00000000
00000000
00000000
00111100
00111110
00100011
00100001
00100001
NAME splashf 38

TIL o5
00000000
00000000
00000000
00010000
00010000
00010000
00010000
00010000
NAME splashf 39

TIL o6
00000000
00000000
00000000
01110000
01110000
01010000
01010000
11010000
NAME splashf 40

TIL o7
00000000
00000000
00000000
00000000
00100000
01100000
11000000
11000000
NAME splashf 41

TIL o8
00000110
00000110
00000000
00000001
00000000
00000000
00000000
00000000
NAME splashf 42

TIL o9
00100001
00100001
00100001
00100001
00100001
00100001
00100001
00100001
NAME splashf 43

TIL oa
00010000
00010000
00010000
00010001
00010001
00010001
00010001
00010001
NAME splashf 44

TIL ob
11010000
10011000
10001000
10001000
10001000
10001000
11111100
11111100
NAME splashf 45

TIL oc
00000001
00000001
00000010
00000000
00000000
00000000
00000000
00000000
NAME splashf 46

TIL od
00000010
00001111
00000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 47

TIL oe
00000000
11100000
00000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 48

TIL of
00100011
00111110
00000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 49

TIL og
00010001
00010001
00000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 50

TIL oh
00001100
00000100
00000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 51

TIL oi
00000000
00011111
00000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 52

TIL oj
00001011
00001111
00000111
00001011
00001011
00001101
00000101
00000110
NAME splashf 53

TIL ok
00000001
00000000
00000000
00000001
00000001
00000011
10000011
10000011
NAME splashf 54

TIL ol
11100011
11100011
11100001
11000001
01000001
01000001
01000001
01000001
NAME splashf 55

TIL om
11000111
10000111
10000001
00000001
00000001
00000001
00000001
00000001
NAME splashf 56

TIL on
10011110
10001100
10001101
00001100
00001100
00001100
00001100
00001100
NAME splashf 57

TIL oo
10001100
11111000
10001100
00000000
00000000
00000000
00000000
00001000
NAME splashf 58

TIL op
11101100
11101111
01011011
01000000
01000000
01000000
01000000
01000000
NAME splashf 59

TIL oq
00000001
00000001
11100011
11100000
01100000
01100000
00110000
01000000
NAME splashf 60

TIL or
10000000
11111111
00000000
00011110
00001110
00001100
00000100
00000100
NAME splashf 61

TIL os
00110000
11100000
00100000
00000000
00000001
00000001
00000001
00000001
NAME splashf 62

TIL ot
00110000
00111000
11100110
01100011
10100001
10000001
10000000
00000000
NAME splashf 63

TIL ou
00000000
00000000
00000000
11000001
10000011
01100011
11100111
11100011
NAME splashf 64

TIL ov
00110000
01111000
01011110
10000011
00000011
00000001
00000000
10000000
NAME splashf 65

TIL ow
00000100
00000100
00000100
00000100
00000100
00000100
00000100
00000100
NAME splashf 66

TIL ox
10000110
11000110
01000100
01001100
01101100
00101100
00101000
00111100
NAME splashf 67

TIL oy
01000001
01000001
01000001
01000001
01000001
01000011
01000000
01000011
NAME splashf 68

TIL oz
00000001
00000001
00000001
10000001
10000011
11000011
01000100
10000011
NAME splashf 69

TIL p0
00001111
00001101
00001101
10001100
10001100
10001100
00001100
10000110
NAME splashf 70

TIL p1
00111000
11110000
00011000
00000000
00000000
00000000
00000000
00000000
NAME splashf 71

TIL p2
01000000
01011111
01011111
01011001
01000111
01000001
01000000
01000000
NAME splashf 72

TIL p3
11100000
11100000
00000000
10000000
10000000
10000000
10000000
11000000
NAME splashf 73

TIL p4
00000100
00000100
00000100
00000100
00000100
00000100
00000100
00001100
NAME splashf 74

TIL p5
00000001
00000011
00000010
00000011
00000011
00000001
00000000
00000000
NAME splashf 75

TIL p6
00000000
10000000
00000000
00000000
10000000
10000001
10000001
10000001
NAME splashf 76

TIL p7
01000000
01000000
01000000
11000000
11000000
01000010
10000010
11000011
NAME splashf 77

TIL p8
11000000
01111000
00111100
00001110
00000110
00000011
00000001
00001111
NAME splashf 78

TIL p9
00000100
00000110
00001111
00000000
00000000
00000000
00000000
00000000
NAME splashf 79

TIL pa
00010100
00010000
00011000
00000000
00000000
00000000
00000000
00000000
NAME splashf 80

TIL pb
01100001
11100000
11100000
10000000
00000000
00000000
00000000
00000000
NAME splashf 81

TIL pc
11000111
01101100
00111000
00010000
00000000
00000000
00000000
00000000
NAME splashf 82

TIL pd
00001010
00001111
00001111
00001000
00000000
00000000
00000000
00000000
NAME splashf 83

TIL pe
00001100
11111100
11111100
00000000
00000000
00000000
00000000
00000000
NAME splashf 84

TIL pf
01000000
01100000
11110000
00000000
00000000
00000000
00000000
00000000
NAME splashf 85

TIL pg
11000000
11100000
11111000
10011000
00000000
00000000
00000000
00000000
NAME splashf 86

TIL ph
00001100
00001110
00011111
00010000
00000000
00000000
00000000
00000000
NAME splashf 87

TIL pi
11000001
00111110
00011100
00000000
00000000
00000000
00000000
00000000
NAME splashf 88

TIL pj
10000011
00000010
00000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 89

TIL pk
10001110
01111000
01110000
00100000
00000000
00000000
00000000
00000000
NAME splashf 90

TIL pl
00000011
00000111
00000111
00000111
00000011
00000111
00000111
00000111
NAME splashf 91

TIL pm
00000000
10000000
11000000
11111111
11111111
11111111
11000000
11000000
NAME splashf 92

TIL pn
00000000
00000000
00000000
11111111
11111111
11111111
00000000
00000000
NAME splashf 93

TIL po
00000000
00000000
00000000
00000000
00000000
00000010
00000111
00000010
NAME splashf 94

TIL pp
00000000
00000000
00000000
00011111
00111111
00011111
00000000
00000000
NAME splashf 95

TIL pq
00111000
01111100
01111100
11111100
11111000
11111100
01111100
01111100
NAME splashf 96

TIL pr
00000011
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 97

TIL ps
00000000
00110000
00001000
00000000
11000000
00000000
00000001
00000001
NAME splashf 98

TIL pt
00000000
00000000
00000000
00000000
00000000
00000000
00000110
00000110
NAME splashf 99

TIL pu
00000000
01100000
00000000
00000000
00011000
00000000
00000000
00100000
NAME splashf 100

TIL pv
00111000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 101

TIL pw
00000000
00000000
00000000
00000000
00000001
00000110
00000100
00000000
NAME splashf 102

TIL px
00100001
01100000
01000000
10000000
10000000
00000000
00000000
00000000
NAME splashf 103

TIL py
00100000
00010000
10011000
00001000
00000100
00000011
00000001
00000000
NAME splashf 104

TIL pz
00000000
00000000
00000000
00000000
00000000
01111111
11111111
11111111
NAME splashf 105

TIL q0
00000000
00000000
00000000
00000000
00000000
11100000
11111100
11111111
NAME splashf 106

TIL q1
00001111
00011111
00111111
01111111
11111011
11000011
11111111
11111111
NAME splashf 107

TIL q2
11110010
11100000
11100000
11110000
11111000
01111101
11111111
11111111
NAME splashf 108

TIL q3
01111111
01111000
01100000
01001111
11111111
11111111
11111111
11111001
NAME splashf 109

TIL q4
10000000
11000000
11100000
11110000
11111000
11111000
11111100
11111100
NAME splashf 110

TIL q5
11111111
11110000
11100000
11100000
11000000
11000000
11000000
11100000
NAME splashf 111

TIL q6
11011000
10000000
11000000
10000000
00000000
00000000
10000000
11000000
NAME splashf 112

TIL q7
10011100
00011110
00011110
00111110
00000110
00000110
00001110
00111110
NAME splashf 113

TIL q8
00000000
00000000
00000000
00000000
00000011
00001111
00011111
00011100
NAME splashf 114

TIL q9
00000000
00000000
00000000
00000000
11100000
11111000
11111110
00111111
NAME splashf 115

TIL qa
11100000
11111000
11111111
11111111
11111111
11111111
11111111
11111111
NAME splashf 116

TIL qb
00011111
00111111
11111101
11111000
11110000
11110000
11100000
11100010
NAME splashf 117

TIL qc
10000000
10000000
11111000
11111001
01111111
00111111
00111111
00011111
NAME splashf 118

TIL qd
00011110
00011110
11111110
11111110
11111110
11111110
11111110
11111100
NAME splashf 119

TIL qe
00000000
00000000
00000000
00000000
00000000
00000000
00000001
00000011
NAME splashf 120

TIL qf
00000000
00000000
00000000
00000000
00011111
01111111
11111111
11110000
NAME splashf 121

TIL qg
00000000
00000000
00000000
00000000
00000000
11000000
11100000
11110000
NAME splashf 122

TIL qh
00111000
00110000
00110000
00110000
00110000
00011100
00001111
00000000
NAME splashf 123

TIL qi
00001111
00000011
00000001
00000000
01000000
11000000
00000000
00000000
NAME splashf 124

TIL qj
10000000
11000000
11100000
11110000
00111001
00011111
00000000
00000000
NAME splashf 125

TIL qk
00000001
00000000
10000000
10000000
10000000
00000000
00000000
00000000
NAME splashf 126

TIL ql
11111111
11111111
01111111
00000111
00000111
00000111
00000111
00000111
NAME splashf 127

TIL qm
11100010
11111111
11111111
11111111
11111111
11111111
11110111
11111111
NAME splashf 128

TIL qn
00111111
01111111
11111111
11111111
11111111
11111111
11110011
11111111
NAME splashf 129

TIL qo
11111100
11111000
11100000
00000000
00000000
00000000
00000000
00000000
NAME splashf 130

TIL qp
00000000
00000000
00000000
00000100
00000110
00000011
00000000
00000000
NAME splashf 131

TIL qq
00000111
00001111
00011110
00111100
01111000
11100000
00000000
00000000
NAME splashf 132

TIL qr
11000000
00000000
00000000
00000000
00001000
00000100
00000011
00000000
NAME splashf 133

TIL qs
01110000
00110000
00111000
00110000
00110000
11100000
11000000
00000000
NAME splashf 134

TIL qt
11111111
11111111
11111111
01111111
00000000
00000000
00000000
00000000
NAME splashf 135

TIL qu
11111110
11111110
11111100
11110000
00000000
00000000
00000000
00000000
NAME splashf 136

TIL qv
00000000
00000000
00000000
00000000
00110000
00111000
00011100
00011110
NAME splashf 137

TIL qw
00000000
00000000
00000000
00111110
00111111
00100011
00100011
00100011
NAME splashf 138

TIL qx
00011000
00010000
00000000
00110000
00110000
00110000
10110000
10110000
NAME splashf 139

TIL qy
00000000
00000000
00000000
01110000
01110000
11110000
11010000
11010000
NAME splashf 140

TIL qz
00000000
00000000
00000000
00000000
01100000
11110000
11100000
11000000
NAME splashf 141

TIL r0
00001110
00000110
00000011
00000001
00000000
00000000
00000000
00000000
NAME splashf 142

TIL r1
00000000
00000000
00000000
10000000
10000000
00000000
00000000
00000000
NAME splashf 143

TIL r2
00100011
00100011
00100011
00100011
00100011
00100011
00100011
00100011
NAME splashf 144

TIL r3
10110000
10110000
10110001
10110001
10110001
10110001
10110001
10110001
NAME splashf 145

TIL r4
11011000
11011000
10011000
10011000
10011000
10011100
11111100
11111100
NAME splashf 146

TIL r5
00000001
00000011
00000011
00000110
00000000
00000000
00000000
00000000
NAME splashf 147

TIL r6
11000000
10000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 148

TIL r7
00001111
00001111
00001111
00000000
00000000
00000000
00000000
00000000
NAME splashf 149

TIL r8
10000000
11110000
11111110
00000000
00000000
00000000
00000000
00000000
NAME splashf 150

TIL r9
00100011
00111111
00111110
00000000
00000000
00000000
00000000
00000000
NAME splashf 151

TIL ra
00110001
00110001
00010001
00000000
00000000
00000000
00000000
00000000
NAME splashf 152

TIL rb
00001100
00001100
00001100
00000000
00000000
00000000
00000000
00000000
NAME splashf 153

TIL rc
00000000
00000000
00000001
00000000
00000000
00000000
00000000
00000000
NAME splashf 154

TIL rd
00000111
00111111
11111111
00000000
00000000
00000000
00000000
00000000
NAME splashf 155

TIL re
10000000
11000000
10000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 156

TIL rf
00001111
00001111
00000111
00001011
00001011
00001101
00001111
00000111
NAME splashf 157

TIL rg
00000001
00000001
00000001
00000001
00000011
00000011
10000011
10000011
NAME splashf 158

TIL rh
11110111
11100011
11100001
11100001
01000001
01000001
11000001
01000001
NAME splashf 159

TIL ri
11000111
10000111
10000011
10000001
00000001
00000001
00000001
00000001
NAME splashf 160

TIL rj
11011111
10011111
10001111
10001100
10001100
10001100
10001100
10001100
NAME splashf 161

TIL rk
10011100
11111100
10011100
00000000
00000000
00000000
00000000
00001000
NAME splashf 162

TIL rl
11101110
11101111
11111111
11000000
01000000
01000000
01000000
01000000
NAME splashf 163

TIL rm
00000001
00000001
11100011
11100000
01100000
01110000
00110000
01010000
NAME splashf 164

TIL rn
11000000
11111111
10000000
00011111
00011110
00001110
00001100
00001100
NAME splashf 165

TIL ro
01110000
11110000
00100000
00000000
00000001
00000001
00000001
00000001
NAME splashf 166

TIL rp
00110000
00111100
11100111
01100011
11100001
10000001
10000000
00000000
NAME splashf 167

TIL rq
00000000
00000000
00000000
11000001
10100111
01100011
11100111
11100011
NAME splashf 168

TIL rr
00110000
01111000
11111111
10000111
10000011
00000011
00000000
10000000
NAME splashf 169

TIL rs
00000110
00000100
00000100
00000100
00000100
00000100
00000100
00000100
NAME splashf 170

TIL rt
11000110
11000110
01000100
01101100
01111100
00101100
00111100
00111100
NAME splashf 171

TIL ru
01000001
01000001
01000001
01000001
01000011
01000011
01000000
01100011
NAME splashf 172

TIL rv
00000001
00000001
10000001
10000001
10000011
11000111
11000110
11000111
NAME splashf 173

TIL rw
10001111
10001101
10001111
10001100
10001100
10001100
00001110
10001110
NAME splashf 174

TIL rx
10111000
11111000
00011000
00000000
00000000
00000000
00000000
00000100
NAME splashf 175

TIL ry
01000000
01011111
01011111
01111001
01000111
01000011
01000001
01000000
NAME splashf 176

TIL rz
11100000
11100000
10000000
10000000
10000000
10000000
10000000
11000000
NAME splashf 177

TIL s0
00001100
00001100
00001100
00001100
00001100
00001100
00001100
00001100
NAME splashf 178

TIL s1
00000011
00000011
00000011
00000011
00000011
00000001
00000001
00000001
NAME splashf 179

TIL s2
00000000
10000000
10000000
10000000
10000000
10000001
10000011
10000001
NAME splashf 180

TIL s3
01100001
01000000
01000000
11000000
11000000
01100010
10000010
11000011
NAME splashf 181

TIL s4
11000000
01111000
01111100
00001110
00000111
00000111
00000001
00001111
NAME splashf 182

TIL s5
00000110
00000110
00001111
00000001
00000000
00000000
00000000
00000000
NAME splashf 183

TIL s6
00111100
00111100
00111001
00001000
00000000
00000000
00000000
00000000
NAME splashf 184

TIL s7
11000111
01111110
00111000
00010000
00000000
00000000
00000000
00000000
NAME splashf 185

TIL s8
10011010
00001111
00011111
00001000
00000000
00000000
00000000
00000000
NAME splashf 186

TIL s9
00001100
11111100
11111100
00000100
00000000
00000000
00000000
00000000
NAME splashf 187

TIL sa
11100000
11100000
11110001
10110000
00000000
00000000
00000000
00000000
NAME splashf 188

TIL sb
00001100
00001110
00011111
00011011
00000000
00000000
00000000
00000000
NAME splashf 189

TIL sc
11000011
01111110
00011100
00001100
00000000
00000000
00000000
00000000
NAME splashf 190

TIL sd
11000011
00000011
00000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 191

TIL se
10011110
11111000
01110000
00100000
00000000
00000000
00000000
00000000
NAME splashf 192

TIL sf
00000111
00000111
00000111
00000111
00000111
00000111
00000111
00000111
NAME splashf 193

TIL sg
10000000
10000000
11000000
11111111
11111111
11111111
11000000
11000000
NAME splashf 194

TIL sh
00000000
00000000
00000000
00000000
00000000
00000111
00000111
00000111
NAME splashf 195

TIL si
00000000
00000000
00000000
00111111
00111111
00011111
00000000
00000000
NAME splashf 196

TIL sj
00000111
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 197

TIL sk
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000010
NAME splashf 198

TIL sl
00000000
00111000
00111100
00000000
11100001
00000001
00010011
00110001
NAME splashf 199

TIL sm
00000000
00000000
00000001
00000000
00000100
00000110
00000110
00001110
NAME splashf 200

TIL sn
00000000
11100000
11100000
00000000
00111100
01000000
01000000
01100010
NAME splashf 201

TIL so
00000000
00000000
00000000
00000001
00000011
00001111
00001110
00000000
NAME splashf 202

TIL sp
01100001
01100000
11100100
11000000
10000000
00100000
00000000
00000000
NAME splashf 203

TIL sq
00001100
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 204

TIL sr
00110000
10110000
10011001
00011100
00001110
00000111
00000001
00000000
NAME splashf 205

TIL ss
00000000
00000000
00000000
00000000
00000000
10000000
10000000
00000000
NAME splashf 206

TIL st
00000000
00000000
00000000
00000000
00000000
00000000
00000011
00000011
NAME splashf 207

TIL su
00000000
00000000
00000000
00000000
00000000
00000000
11000000
11000000
NAME splashf 208

TIL sv
00000000
00000000
00000000
00000000
00000000
11110000
11111100
11111111
NAME splashf 209

TIL sw
00000000
00000000
00000000
00000000
00000000
00000000
01111000
01111000
NAME splashf 210

TIL sx
01000011
11000011
11100000
10110000
00011000
00011110
00011100
11111000
NAME splashf 211

TIL sy
00001111
00011111
00111111
01111111
11111111
11000111
11111111
11111111
NAME splashf 212

TIL sz
11110110
11100000
11100000
11110000
11111000
11111101
11111111
11111111
NAME splashf 213

TIL t0
11111111
01111001
01100001
01011111
11111111
11111111
11111111
11111001
NAME splashf 214

TIL t1
11000000
11000000
11110000
11110000
11111000
11111000
11111100
11111100
NAME splashf 215

TIL t2
01111000
00111000
00000000
00000001
00000011
00000111
00000011
00000001
NAME splashf 216

TIL t3
01000011
01100001
11110000
10011000
00001100
00001111
00001111
11111111
NAME splashf 217

TIL t4
11111000
11110000
11100000
11000000
10000000
10000000
00000000
00000000
NAME splashf 218

TIL t5
11111111
11111000
11100000
11100000
11000000
11000000
11100000
11100000
NAME splashf 219

TIL t6
11111111
00111111
00011111
00011111
00001111
00001111
00011111
00011111
NAME splashf 220

TIL t7
11011001
11000000
11000000
11000000
00000000
00000000
10000000
11000000
NAME splashf 221

TIL t8
11011110
00011110
00011110
00111110
00000110
00000110
00011110
00111110
NAME splashf 222

TIL t9
11111111
11111111
01111111
00111111
00011111
00011111
00001111
00000111
NAME splashf 223

TIL ta
00000000
00000000
00000000
00000000
00000011
00001111
00011111
00111110
NAME splashf 224

TIL tb
00011111
01111111
11111101
11111000
11110000
11110000
11100000
11100010
NAME splashf 225

TIL tc
11000000
10000000
11111000
11111101
01111111
00111111
00111111
00011111
NAME splashf 226

TIL td
00011110
00011110
11111110
11111110
11111110
11111110
11111110
11111110
NAME splashf 227

TIL te
00000000
00000000
00000000
00000000
00011111
01111111
11111111
11110001
NAME splashf 228

TIL tf
00000111
00000011
00000011
00000001
00000000
00000000
00000000
00000000
NAME splashf 229

TIL tg
00111000
00110000
01110000
00110000
00111000
00011101
00001111
00000000
NAME splashf 230

TIL th
00001111
00000011
00000001
00100000
01000000
11000000
10000000
00000000
NAME splashf 231

TIL ti
10000000
11000000
11100000
11110000
01111111
00011111
00000000
00000000
NAME splashf 232

TIL tj
00000001
00000001
10000000
10000000
10000000
00000000
00000000
00000000
NAME splashf 233

TIL tk
11100011
11111111
11111111
11111111
11111111
11111111
11110111
11111111
NAME splashf 234

TIL tl
00111111
11111111
11111111
11111111
11111111
11111111
11110011
11111111
NAME splashf 235

TIL tm
11111100
11111100
11110000
00000000
00000000
00000000
00000000
00000000
NAME splashf 236

TIL tn
00000000
00000000
00000100
00000100
00000111
00000011
00000000
00000000
NAME splashf 237

TIL to
00000111
00001111
00011110
00111100
11111000
11100000
00000000
00000000
NAME splashf 238

TIL tp
11000000
10000000
00000000
00000000
00001000
00001110
00000011
00000000
NAME splashf 239

TIL tq
01110000
00111000
00111000
00111000
00110000
11110000
11000000
00000000
NAME splashf 240

TIL tr
00000011
00000011
00000011
00000000
00000000
00000000
00000000
00000000
NAME splashf 241

TIL ts
11111111
11111110
11111100
11110000
00000000
00000000
00000000
00000000
NAME splashf 242

TIL tt
00000000
00000000
00000000
00000000
00111000
00111000
00111100
00011110
NAME splashf 243

TIL tu
00000000
00000000
00000000
01111110
01111111
01100011
01100011
01100011
NAME splashf 244

TIL tv
00011000
00010000
00000000
00111000
00111000
00111000
10111000
10111000
NAME splashf 245

TIL tw
00000000
00000000
00000000
01110000
01110000
11110000
11110000
11011000
NAME splashf 246

TIL tx
00000000
00000000
00000000
00001111
00001111
00001000
00001000
00001000
NAME splashf 247

TIL ty
00000000
00000000
00000000
00000111
11000111
01000110
01100110
01100110
NAME splashf 248

TIL tz
00000000
00000000
00000000
11100000
11100000
00000000
00000000
00000000
NAME splashf 249

TIL u0
00000000
00000000
00000000
00000000
01110000
11110000
11100000
11000000
NAME splashf 250

TIL u1
00001110
00000111
00000011
00000001
00000000
00000000
00000000
00000000
NAME splashf 251

TIL u2
00000000
00000000
00000000
10000000
10000000
00000000
00000000
00110000
NAME splashf 252

TIL u3
01100011
01100011
01100011
01100011
01100011
01100011
01100011
01100011
NAME splashf 253

TIL u4
10111000
10111000
10111001
10111001
10111001
10111001
10111001
10111001
NAME splashf 254

TIL u5
11011000
11011000
10011000
10011000
10011100
10011100
11111100
11111100
NAME splashf 255

TIL u6
00001000
00001000
00001000
00001000
00001000
00001000
00001000
00001000
NAME splashf 256

TIL u7
01100110
01100110
01100111
01100111
01100110
01100110
01100110
01100110
NAME splashf 257

TIL u8
00000000
00000000
11000000
11000000
00000000
00000000
00000000
00000000
NAME splashf 258

TIL u9
00000011
00000011
00000011
00000110
00000100
00000000
00000000
01100000
NAME splashf 259

TIL ua
10000000
11111000
11111110
00000000
00000000
00000000
00000000
00000000
NAME splashf 260

TIL ub
00111000
00111000
00000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 261

TIL uc
01100011
01111111
01111110
00000000
00000000
00000000
00000000
00000000
NAME splashf 262

TIL ud
00111011
00111011
00110011
00000000
00000000
00000000
00000000
00000000
NAME splashf 263

TIL ue
00001000
00001111
00000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 264

TIL uf
01000110
11000111
00000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 265

TIL ug
01110000
01110000
00000001
00000000
00000000
00000000
00000000
00000000
NAME splashf 266

TIL uh
00000111
01111111
11111111
00000000
00000000
00000000
00000000
00000000
NAME splashf 267

TIL ui
00000001
10000001
00000011
00000011
00000011
10000011
10000011
10000111
NAME splashf 268

TIL uj
11110111
11110011
11100001
11100001
01000001
01000001
11000001
01000001
NAME splashf 269

TIL uk
11000111
11000111
10000011
10000001
10000001
10000001
10000001
00000001
NAME splashf 270

TIL ul
11011101
11111100
10011100
00000000
00000000
00000000
00000000
00011000
NAME splashf 271

TIL um
11101110
11101111
11111111
11110000
11000000
11000000
01000000
01000000
NAME splashf 272

TIL un
00000001
00000001
11100011
11100000
01110000
01110000
00110000
01010000
NAME splashf 273

TIL uo
11000000
11111111
10001000
00011111
00011110
00001110
00001100
00001100
NAME splashf 274

TIL up
01110000
11110000
00110000
00000000
00000001
00000001
00000001
00000001
NAME splashf 275

TIL uq
00111000
00111100
11111111
01100011
11100001
11000001
10000000
00000000
NAME splashf 276

TIL ur
00000000
00000000
00000000
11000011
10100111
01100011
11100111
11100011
NAME splashf 277

TIL us
11000110
11000110
11000110
01101100
01111100
01101100
00111100
00111100
NAME splashf 278

TIL ut
00000001
10000001
10000001
10000011
10000011
11000111
11000110
11000111
NAME splashf 279

TIL uu
10111000
11111000
10111000
00000000
00000000
00000000
00000000
00000100
NAME splashf 280

TIL uv
01000000
01111111
01111111
01111001
01100111
01000011
11100001
11100000
NAME splashf 281

TIL uw
11100000
11100000
10000000
10000000
10000000
10000000
11000000
11000000
NAME splashf 282

TIL ux
00000011
00000011
00000111
00000011
00000011
00000001
00000001
00000001
NAME splashf 283

TIL uy
00000000
10000000
10000000
10000000
11000000
10000001
10000011
11000011
NAME splashf 284

TIL uz
11100001
01000000
01000000
11000000
11000000
11100110
10100010
11000011
NAME splashf 285

TIL v0
11000000
11111000
01111100
00111110
00000111
00000111
00000111
00001111
NAME splashf 286

TIL v1
00000110
00001110
00001111
00001001
00000000
00000000
00000000
00000000
NAME splashf 287

TIL v2
01100001
11100000
11110000
11100000
00000000
00000000
00000000
00000000
NAME splashf 288

TIL v3
11000111
11111110
00111000
00110000
00000000
00000000
00000000
00000000
NAME splashf 289

TIL v4
10011010
00001111
00011111
00011100
00000000
00000000
00000000
00000000
NAME splashf 290

TIL v5
11000000
11100000
11111000
11111000
00000000
00000000
00000000
00000000
NAME splashf 291

TIL v6
11000011
11111111
00011100
00001100
00000000
00000000
00000000
00000000
NAME splashf 292

TIL v7
00000111
00000111
00001111
00000111
00000111
00000111
00000111
00000111
NAME splashf 293

TIL v8
10000000
11000000
11000000
11111111
11111111
11111111
11000000
11000000
NAME splashf 294

TIL v9
00000000
00000000
00000000
00000000
00000111
00001111
00001111
00001111
NAME splashf 295

TIL va
00000000
00000000
00000000
00111111
00111111
00111111
00000000
00000000
NAME splashf 296

TIL vb
00111100
01111100
01111100
11111100
11111100
11111100
01111100
01111100
NAME splashf 297

TIL vc
00000000
00000000
00000000
00000001
00000011
00000011
00000111
00000111
NAME splashf 298

TIL vd
00000000
10000000
10000000
11000000
11100000
11110000
11111000
11111000
NAME splashf 299

TIL ve
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000011
NAME splashf 300

TIL vf
00000000
00111000
00111110
00000000
11100101
00011001
00010011
00110011
NAME splashf 301

TIL vg
00000010
00000000
00000000
00000000
00000000
00000000
10000000
10000000
NAME splashf 302

TIL vh
00000000
00000000
00000011
00000000
00000100
00000110
00001110
00001110
NAME splashf 303

TIL vi
00000000
11110000
11100000
00000000
00111100
11000000
01100000
01100110
NAME splashf 304

TIL vj
00111100
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 305

TIL vk
00001111
00011111
00011111
00111111
01111111
11111111
11111111
11111111
NAME splashf 306

TIL vl
11111100
00111110
00011111
00011110
00011000
11100000
11100000
11000011
NAME splashf 307

TIL vm
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11000000
NAME splashf 308

TIL vn
00000000
00000000
00000100
00000001
00000011
00001111
00001110
00000000
NAME splashf 309

TIL vo
01110001
01101000
11101100
11000100
10000000
10100000
00000000
00000000
NAME splashf 310

TIL vp
00001110
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 311

TIL vq
00110000
10111000
10111001
10011100
00001111
00100111
00000011
00000000
NAME splashf 312

TIL vr
00000011
00000111
00001111
00001111
00000011
00000001
00000000
01111000
NAME splashf 313

TIL vs
11111111
00011111
00011111
00001110
00011000
11110000
11100000
01100001
NAME splashf 314

TIL vt
11000000
11000000
10000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 315

TIL vu
01111000
01111000
00111000
00000000
00000000
00000000
00000000
00000000
NAME splashf 316

TIL vv
01000011
00000011
00000001
00000000
00000000
00000000
00000000
00000000
NAME splashf 317

TIL vw
00000000
00000000
00000000
00000000
00000000
00000011
00000111
01000111
NAME splashf 318

TIL vx
00000000
00000000
00000000
00000000
00000000
10000000
11000000
11000000
NAME splashf 319

TIL vy
00000000
00000000
00000000
00000000
00000000
00000000
00000011
00000111
NAME splashf 320

TIL vz
00000000
00000000
00000000
00000000
00000000
11110000
11111110
11111111
NAME splashf 321

TIL w0
00000000
00000000
00000000
00000000
00000000
00110000
01111100
11111100
NAME splashf 322

TIL w1
00000000
00000000
00000000
00000000
00000000
00000001
00000011
01000011
NAME splashf 323

TIL w2
11000111
11100011
11110000
11111000
00011110
00011111
00111110
11111100
NAME splashf 324

TIL w3
11000000
11000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 325

TIL w4
00000000
00000000
00000000
00000000
00000000
00000001
00000001
00000001
NAME splashf 326

TIL w5
11111111
11100000
11100000
11110000
11111001
11111111
11111111
11111111
NAME splashf 327

TIL w6
11111111
01111101
01110001
11111111
11111111
11111111
11111111
11111001
NAME splashf 328

TIL w7
11000000
11100000
11110000
11110000
11111000
11111100
11111100
11111100
NAME splashf 329

TIL w8
11111100
01111000
00000001
00000011
00000111
00001111
00000111
00000011
NAME splashf 330

TIL w9
01100011
11110011
11110000
11111000
10011110
00001111
10011111
11111111
NAME splashf 331

TIL wa
11111000
11110000
11100000
11100000
11000000
10000000
10000000
00000000
NAME splashf 332

TIL wb
11111111
11111000
11110000
11100000
11100000
11000000
11100000
11100000
NAME splashf 333

TIL wc
11111111
01111111
00011111
00011111
00011111
00001111
00011111
00011111
NAME splashf 334

TIL wd
11111001
11000000
11000000
11000000
00000000
00000000
10000000
11000000
NAME splashf 335

TIL we
11111110
00011110
00111110
00111110
00001110
00000110
00111110
00111110
NAME splashf 336

TIL wf
11111111
11111111
01111111
01111111
00111111
00011111
00011111
00001111
NAME splashf 337

TIL wg
00000000
00000000
00000000
00000000
00000011
00001111
00011111
00111111
NAME splashf 338

TIL wh
00000000
00000000
00000000
00000000
11100000
11111000
11111110
01111111
NAME splashf 339

TIL wi
11110000
11111000
11111111
11111111
11111111
11111111
11111111
11111111
NAME splashf 340

TIL wj
00011111
01111111
11111101
11111000
11111000
11110000
11100010
11100010
NAME splashf 341

TIL wk
11000000
11010000
11111001
11111101
01111111
01111111
00111111
00011111
NAME splashf 342

TIL wl
00011110
10011110
11111110
11111110
11111110
11111110
11111110
11111110
NAME splashf 343

TIL wm
00000000
00000000
00000000
00000000
00011111
01111111
11111111
11111111
NAME splashf 344

TIL wn
00000111
00000111
00000011
00000001
00000001
00000000
00000000
00000000
NAME splashf 345

TIL wo
00111000
01111000
01110000
01110000
00111000
00111111
00001111
00000000
NAME splashf 346

TIL wp
00001111
00000111
00000001
00100000
01000000
11000000
10000000
00000000
NAME splashf 347

TIL wq
10000000
11000001
11100000
11110000
01111111
00111111
00000000
00000000
NAME splashf 348

TIL wr
11100111
11111111
11111111
11111111
11111111
11111111
11110111
11111111
NAME splashf 349

TIL ws
00000000
00000010
00000100
00000100
00000111
00000011
00000000
00000000
NAME splashf 350

TIL wt
00000111
00001111
00011110
00111100
11111000
11110000
00000000
00000000
NAME splashf 351

TIL wu
11000000
10000000
00000000
00000000
00001000
00001111
00000111
00000000
NAME splashf 352

TIL wv
01110000
00111000
00111000
00111000
01110000
11110000
11100000
00000000
NAME splashf 353

TIL ww
00000111
00000011
00000011
00000000
00000000
00000000
00000000
00000000
NAME splashf 354

TIL wx
11111111
11111110
11111110
11111000
00000000
00000000
00000000
00000000
NAME splashf 355

TIL wy
00000000
00000000
00000000
00000000
00111000
00111100
00111100
00011110
NAME splashf 356

TIL wz
00011000
00010000
00000000
00111000
00111000
10111000
10111000
10111000
NAME splashf 357

TIL x0
00000000
00000000
00000000
01110000
11110000
11111000
11111000
11011000
NAME splashf 358

TIL x1
00000000
00000000
00000000
00001111
00001111
00001100
00001100
00001100
NAME splashf 359

TIL x2
00000000
00000000
00000000
10000111
11000111
11100110
01100110
01100110
NAME splashf 360

TIL x3
00000000
00000000
00000000
10000000
10000000
00000000
00000000
00111000
NAME splashf 361

TIL x4
10111000
10111000
10111001
10111001
10111001
10111001
10111001
10111011
NAME splashf 362

TIL x5
11011000
11011000
11011000
10011000
10011100
10011100
11111100
11111100
NAME splashf 363

TIL x6
00000011
00000011
00000111
00000110
00001100
00000000
00000000
01110000
NAME splashf 364

TIL x7
10000000
11111000
11111110
00000000
00000000
00000000
00000000
00000010
NAME splashf 365

TIL x8
01111000
00111000
00010000
00000000
00000000
00000000
00000000
00000010
NAME splashf 366

TIL x9
10111011
00111011
00111011
00000000
00000000
00000000
00000000
00000000
NAME splashf 367

TIL xa
00001100
00001110
00001110
00000000
00000000
00000000
00000000
00000000
NAME splashf 368

TIL xb
00001100
00001111
00001111
00000000
00000000
00000000
00000000
00000000
NAME splashf 369

TIL xc
11100110
11000111
10000111
00000000
00000000
00000000
00000000
00000000
NAME splashf 370

TIL xd
00000000
11100000
11100000
00000000
00000000
00000000
00000000
00000000
NAME splashf 371

TIL xe
11110000
11110000
00100011
00000000
00000000
00000000
00000000
00000000
NAME splashf 372

TIL xf
00001111
11111111
11111111
00000000
00000000
00000000
00000000
00000000
NAME splashf 373

TIL xg
10000000
11000000
11000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 374

TIL xh
00001111
00001111
00000111
00011011
00001111
00001111
00001111
00001111
NAME splashf 375

TIL xi
11110111
11110011
11100001
11100001
11000001
01000001
11000001
01000001
NAME splashf 376

TIL xj
11000111
11000111
10000011
10000001
10000001
10000001
10000001
10000001
NAME splashf 377

TIL xk
11011101
11111100
11111100
00000100
00000000
00000000
00000000
00011000
NAME splashf 378

TIL xl
11111110
11101111
11111111
11110000
11100000
11100000
11100000
11100000
NAME splashf 379

TIL xm
00000001
10000001
11100011
11110000
01110000
01110000
01110000
01010000
NAME splashf 380

TIL xn
11000000
11111111
11111100
00011111
00011110
00001110
00001110
00001100
NAME splashf 381

TIL xo
01110000
11110000
01110001
00000000
00000001
00000001
00000001
00000001
NAME splashf 382

TIL xp
00111000
01111100
11111111
11100011
11100011
11000001
10000001
00000000
NAME splashf 383

TIL xq
00000000
00000000
00000000
11000011
11100111
01100011
11100111
11100011
NAME splashf 384

TIL xr
00110000
01111100
11111111
10000111
10000011
00000011
10000001
11000000
NAME splashf 385

TIL xs
00001110
00000110
00000100
00000100
00000100
00000100
00000110
00000110
NAME splashf 386

TIL xt
11000111
11000110
11101110
01101100
01111100
01101100
00111100
00111100
NAME splashf 387

TIL xu
01000001
01000001
01000001
01000001
01100011
01100011
01100000
01100011
NAME splashf 388

TIL xv
10000001
10000001
10000001
10000011
10000011
11000111
11000110
11000111
NAME splashf 389

TIL xw
10001111
10001111
10001111
10001100
10001100
10001100
00011110
10001110
NAME splashf 390

TIL xx
11111000
11111000
10111000
00000000
00000000
00000000
00000000
00000100
NAME splashf 391

TIL xy
11100000
11111111
11111111
11111011
11100111
11100011
11100001
11100000
NAME splashf 392

TIL xz
11100000
11100000
10000000
10000000
10000000
11000000
11000000
11000000
NAME splashf 393

TIL y0
00000011
00000111
00000111
00000111
00000111
00000001
00000001
00000001
NAME splashf 394

TIL y1
00000000
10000000
10000000
11000000
11000000
10000001
10000011
11000011
NAME splashf 395

TIL y2
11100001
01100000
01000000
11000000
11000000
11100110
10100011
11000011
NAME splashf 396

TIL y3
11100000
11111000
01111110
00111110
00000111
00000111
00000111
00001111
NAME splashf 397

TIL y4
00000110
00001110
00001111
00001101
00000000
00000000
00000000
00000000
NAME splashf 398

TIL y5
00111100
00111100
00111001
00011001
00000000
00000000
00000000
00000000
NAME splashf 399

TIL y6
11100001
11100000
11110000
11110000
00000000
00000000
00000000
00000000
NAME splashf 400

TIL y7
11000111
11111110
00111100
00111000
00000000
00000000
00000000
00000000
NAME splashf 401

TIL y8
10011110
00001111
00011111
00011100
00000000
00000000
00000000
00000000
NAME splashf 402

TIL y9
00011100
11111100
11111100
00000100
00000000
00000000
00000000
00000000
NAME splashf 403

TIL ya
11100000
11100000
11111001
11110001
00000000
00000000
00000000
00000001
NAME splashf 404

TIL yb
11100000
11100000
11111000
11111000
00000000
00000000
00000000
00000000
NAME splashf 405

TIL yc
00001110
00011110
00011111
00011111
00000000
00000000
00000000
00000000
NAME splashf 406

TIL yd
11000011
11111111
00011110
00001100
00000000
00000000
00000000
00000000
NAME splashf 407

TIL ye
10011111
11111000
01110000
00110000
00000000
00000000
00000000
00000000
NAME splashf 408

TIL yf
00000111
00001111
00001111
00000111
00000111
00000111
00001111
00000111
NAME splashf 409

TIL yg
00000000
00000000
00000000
00000000
10000000
00000000
00000000
00000001
NAME splashf 410

TIL yh
00000011
00000011
00000011
00000011
00000111
00001111
00111111
11111111
NAME splashf 411

TIL yi
10000000
10000000
10000000
00000000
00000000
00000000
10000000
11000000
NAME splashf 412

TIL yj
00111100
01111100
11111100
11111100
11111100
11111100
01111100
01111100
NAME splashf 413

TIL yk
00000000
00000000
00000001
00000001
00000011
00000111
00000111
00001111
NAME splashf 414

TIL yl
10000000
10000000
11000000
11100000
11100000
11110000
11111000
11111100
NAME splashf 415

TIL ym
00010001
00111000
00111110
00000010
11100101
00011011
00110011
00110011
NAME splashf 416

TIL yn
11110111
11000000
00000000
00000000
00000000
00000000
10000000
10000000
NAME splashf 417

TIL yo
11100000
11110000
01110011
00000011
00000100
00000110
00001110
00001110
NAME splashf 418

TIL yp
00000000
11110000
11100000
00000000
10111100
11000000
01100000
01100110
NAME splashf 419

TIL yq
01111100
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 420

TIL yr
11111110
11111111
00111111
00011111
00111000
11110000
11100011
11100011
NAME splashf 421

TIL ys
00000000
00000000
10000000
11000000
00000000
00000000
10000000
11000100
NAME splashf 422

TIL yt
00000000
00000000
00000110
00000001
00000111
00001111
00001110
00000000
NAME splashf 423

TIL yu
01110001
11101000
11101100
11000100
11000000
10100000
00000000
00000000
NAME splashf 424

TIL yv
00001110
00000000
00000001
00000000
00000000
00000000
00000000
00000000
NAME splashf 425

TIL yw
00110000
10111000
10111101
10011100
00001111
00100111
00000011
00000000
NAME splashf 426

TIL yx
00000111
00001111
00011111
00011111
00000011
00000001
00111000
01111100
NAME splashf 427

TIL yy
11111111
11111111
00011111
00011111
10111100
11111000
11110001
11100011
NAME splashf 428

TIL yz
11000111
00000111
00000011
00000001
00000000
00000000
00000000
00000000
NAME splashf 429

TIL z0
11100010
11100010
11000000
10000000
00000000
00000000
00000000
00000000
NAME splashf 430

TIL z1
01111100
01111100
01111000
00010000
00000000
00000000
00000000
00000000
NAME splashf 431

TIL z2
01100011
01000011
00000001
00000000
00000000
00000000
00000000
00000000
NAME splashf 432

TIL z3
00000000
00000000
00000000
00000000
00000000
00000001
00000011
00100011
NAME splashf 433

TIL z4
00000000
00000000
00000000
00000000
00000000
11000000
11100001
11110000
NAME splashf 434

TIL z5
00000000
00000000
00000000
00000000
00000000
11111000
11111111
11111111
NAME splashf 435

TIL z6
00000000
00000000
00000000
00000000
00000000
00011000
00111100
01111110
NAME splashf 436

TIL z7
00000000
00000000
00000000
00000000
00000000
00000000
00000001
00110001
NAME splashf 437

TIL z8
01100011
01110001
11111000
11111100
10001111
10001111
10011111
11111110
NAME splashf 438

TIL z9
11100000
11100000
00000000
00000000
00000000
10000000
00000000
00000000
NAME splashf 439

TIL za
00000111
00001111
00011111
00111111
01111111
01100011
11111111
11111111
NAME splashf 440

TIL zb
11111111
11110000
11110000
11111000
11111100
11111110
11111111
11111111
NAME splashf 441

TIL zc
11111111
00111110
00111000
00111111
11111111
11111111
11111111
11111100
NAME splashf 442

TIL zd
11100000
11110000
11111000
11111000
11111100
11111110
11111110
11111110
NAME splashf 443

TIL ze
00111110
00111100
00000000
00000000
00000011
00000111
00000011
00000001
NAME splashf 444

TIL zf
00110001
01111001
01111000
11111100
11001111
10000111
11001111
11111111
NAME splashf 445

TIL zg
11111100
11111000
11110000
11110000
11100000
11000000
11000000
10000000
NAME splashf 446

TIL zh
11111111
11111100
11111000
11110000
11110000
11110000
11110000
11110000
NAME splashf 447

TIL zi
11111111
00111111
00001111
00001111
00000111
00000111
00000111
00001111
NAME splashf 448

TIL zj
11111100
11000000
11100000
11100000
10000000
10000000
11000000
11100000
NAME splashf 449

TIL zk
11111111
00001111
00001111
00011111
00000111
00000011
00011111
00011111
NAME splashf 450

TIL zl
00000000
00000000
00000000
10000000
10000000
10000000
10000000
00000000
NAME splashf 451

TIL zm
11111111
01111111
00111111
00111111
00011111
00001111
00000111
00000111
NAME splashf 452

TIL zn
00000000
00000000
00000000
00000000
00000001
00000111
00001111
00011111
NAME splashf 453

TIL zo
00000000
00000000
00000000
00000000
11110000
11111100
11111111
11111111
NAME splashf 454

TIL zp
11111000
11111100
11111111
11111111
11111111
11111111
11111111
11111111
NAME splashf 455

TIL zq
00001111
00111111
11111110
11111100
11111000
11111000
11110001
11110001
NAME splashf 456

TIL zr
11000000
11001000
11111100
01111110
00111111
00011111
00011111
00011111
NAME splashf 457

TIL zs
00001111
01001111
11111111
11111111
11111111
11111111
11111111
11111111
NAME splashf 458

TIL zt
00000000
00000000
00000000
00000000
00001111
00111111
11111111
11111111
NAME splashf 459

TIL zu
00000000
00000000
00000000
00000000
10000000
11100000
11110000
11111000
NAME splashf 460

TIL zv
00011100
00011000
00011000
00011000
00011100
00011111
00000111
00000000
NAME splashf 461

TIL zw
00000111
00000011
00000000
00010000
00100000
11100000
11000000
00000000
NAME splashf 462

TIL zx
11000000
11100000
11110000
01111000
00111111
00011111
00000000
00000000
NAME splashf 463

TIL zy
00000000
10000000
01000000
01000000
11000000
10000000
00000000
00000000
NAME splashf 464

TIL zz
11111111
11111111
00111111
00000011
00000011
00000011
00000011
00000011
NAME splashf 465

TIL 10a
00000000
00000000
00000000
00111111
00111111
00111001
00111001
00111001
NAME splashf 476

TIL 10b
00001100
00001000
00000000
00011100
10011100
11011100
11011100
11011100
NAME splashf 477

TIL 10c
00000000
00000000
00000000
01111000
01111000
01111000
01111100
01111100
NAME splashf 478

TIL 10d
00000000
00000000
00000000
00001111
00001111
00001110
00001110
00001110
NAME splashf 479

TIL 10e
00000000
00000000
00000000
11000011
11100011
01110011
00110011
00110011
NAME splashf 480

TIL 10f
00000000
00000000
00000000
11110000
11110000
00000000
00000000
00000000
NAME splashf 481

TIL 10g
00000000
00000000
00000000
00000000
00111000
01111000
11110000
11110000
NAME splashf 482

TIL 10h
00000111
00000011
00000001
00000000
00000000
00000000
00000000
00000000
NAME splashf 483

TIL 10i
00000000
10000000
10000000
11000000
01000000
00000000
00000000
00011100
NAME splashf 484

TIL 10j
00111001
00111001
00111001
00111001
00111001
00111001
00111001
00111001
NAME splashf 485

TIL 10k
11011100
11011100
11011100
11011100
11011100
11011100
11011100
11011100
NAME splashf 486

TIL 10l
01101100
01001100
11001100
11001110
11001110
11000110
11111110
11111110
NAME splashf 487

TIL 10m
00001110
00001110
00001110
00001110
00001110
00001110
00001110
00001110
NAME splashf 488

TIL 10n
00110011
00110011
00110011
00110011
00110011
00110011
00110011
00110011
NAME splashf 489

TIL 10o
00000000
00000000
11100000
11100000
00000000
00000000
00000000
00000000
NAME splashf 490

TIL 10p
00000001
00000001
00000011
00000011
00000010
00000000
00000000
00111000
NAME splashf 491

TIL 10q
11100000
11000000
10000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 492

TIL 10r
00000111
00000111
00000111
00000000
00000000
00000000
00000000
00000000
NAME splashf 493

TIL 10s
11000000
11111100
11111111
00000000
00000000
00000000
00000000
00000001
NAME splashf 494

TIL 10t
00011100
00011100
00001000
00000000
00000000
00000000
00000000
00000001
NAME splashf 495

TIL 10u
00111001
00111111
00111111
00000000
00000000
00000000
00000000
00000000
NAME splashf 496

TIL 10v
11011101
10011101
00011101
00000000
00000000
00000000
00000000
00000000
NAME splashf 497

TIL 10w
11000110
11000110
10000110
00000000
00000000
00000000
00000000
00000000
NAME splashf 498

TIL 10x
00001110
00001111
00000111
00000000
00000000
00000000
00000000
00000000
NAME splashf 499

TIL 10y
01110011
11100011
11000011
00000000
00000000
00000000
00000000
00000000
NAME splashf 500

TIL 10z
00000000
11110000
11110000
00000000
00000000
00000000
00000000
00000000
NAME splashf 501

TIL 11a
11110000
11111111
11111110
00001111
00001111
00000111
00000110
00000110
NAME splashf 512

TIL 11b
00111000
11111000
00111000
10000000
10000001
00000000
00000000
00000000
NAME splashf 513

TIL 11c
00011100
00011110
01111111
01110001
11110000
11000000
11000000
10000000
NAME splashf 514

TIL 11d
00000000
00000000
10000000
11100001
11110011
10111001
11110011
01110001
NAME splashf 515

TIL 11e
00011000
00111110
01111111
11100011
11000001
10000001
11000000
11100000
NAME splashf 516

TIL 11f
00000000
00000000
10000000
10000000
10000000
10000000
10000000
00000000
NAME splashf 517

TIL 11g
00000011
00000011
00000010
00000010
00000010
00000010
00000010
00000011
NAME splashf 518

TIL 11h
01100011
01100011
01100111
00110110
00111110
00111110
00011110
00011110
NAME splashf 519

TIL 11i
10110000
00110000
00110000
00110000
00110001
00110001
00110000
00110001
NAME splashf 520

TIL 11j
11000000
11000000
11000000
11000001
11000001
11100011
01100011
11100011
NAME splashf 521

TIL 11k
11000111
11000111
11000111
11000110
11000110
11100110
00000111
11000111
NAME splashf 522

TIL 11l
11111100
11111100
11011100
00000000
00000000
00000000
00000000
00000010
NAME splashf 523

TIL 11m
00100000
00101111
00101111
00101101
00100011
00100001
00100000
00110000
NAME splashf 524

TIL 11n
01111000
11110000
11000000
11000000
11000000
11000000
11100000
01100000
NAME splashf 525

TIL 11o
00000110
00000110
00000110
00000110
00000110
00000110
00000110
00000110
NAME splashf 526

TIL 11p
00000001
00000001
00000011
00000001
00000001
00000000
00000000
00000000
NAME splashf 527

TIL 11q
10000000
11000000
11000000
11000000
11100000
11000000
11000000
11100000
NAME splashf 528

TIL 11r
00110000
00110000
00100000
01100000
11100000
11110011
11110001
11100001
NAME splashf 529

TIL 11s
11110000
01111100
00111111
00010111
00000011
10000011
10000011
10000111
NAME splashf 530

TIL 11t
00000000
00000000
00000000
00000000
10000000
11000000
11000000
10000000
NAME splashf 531

TIL 11u
00000011
00000011
00000111
00000110
00000000
00000000
00000000
00000000
NAME splashf 532

TIL 11v
00011110
00011110
10011100
10001100
00000000
00000000
00000000
00000000
NAME splashf 533

TIL 11w
01110000
01110000
11111000
01111000
00000000
00000000
00000000
00000000
NAME splashf 534

TIL 11x
11100011
01111111
00011110
00011100
00000000
00000000
00000000
00000000
NAME splashf 535

TIL 11y
11001101
00000111
00001111
00000110
00000000
00000000
00000000
00000000
NAME splashf 536

TIL 11z
00001110
11111110
11111110
00000010
00000000
00000000
00000000
00000000
NAME splashf 537

TIL 12a
11000000
11000000
11000000
10000000
10000000
11000000
11000000
11100000
NAME splashf 548

TIL 12b
00000000
00000000
00000000
00011111
00011111
00001111
00000000
00000000
NAME splashf 549

TIL 12c
00011110
00111110
00111111
11111110
11111110
11111110
00111110
00111110
NAME splashf 550

TIL 12d
00000000
00000000
00000000
00000001
00000001
00000011
00000011
00000111
NAME splashf 551

TIL 12e
11000000
11000000
11100000
11110000
11110000
11111000
11111100
11111110
NAME splashf 552

TIL 12f
11000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 553

TIL 12g
00001000
00111100
00011111
00000001
11110010
00001101
00001001
10011001
NAME splashf 554

TIL 12h
11111011
01100000
00000000
00000000
10000000
10000000
11000000
11000000
NAME splashf 555

TIL 12i
11110000
01111000
00111001
00000010
00000010
00000011
00000011
00000111
NAME splashf 556

TIL 12j
00000000
01111000
11110000
10000000
01011110
00100000
00110000
00110011
NAME splashf 557

TIL 12k
00011110
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 558

TIL 12l
00000111
00001111
00011111
00111111
00111111
01111111
11111111
11111111
NAME splashf 559

TIL 12m
11111111
11111111
10011111
10001111
10011100
11111000
11110001
01100001
NAME splashf 560

TIL 12n
00000000
10000000
11000000
11000000
00000000
00000000
11000000
11100010
NAME splashf 561

TIL 12o
00000000
00000000
00000010
00000000
00000011
00000111
00000111
00000000
NAME splashf 562

TIL 12p
00111000
00110100
01110110
11100010
11100000
11000000
00000000
00000000
NAME splashf 563

TIL 12q
00111000
01011100
11011100
11001110
00000111
00010011
00000001
00000000
NAME splashf 564

TIL 12r
00000000
00000000
10000000
00000000
10000000
11000000
11000000
00000000
NAME splashf 565

TIL 12s
00000011
00000111
00001111
00001111
00000011
00000000
00011100
00111110
NAME splashf 566

TIL 12t
11111111
11111111
10001111
10001111
11001110
11111100
01111000
01110001
NAME splashf 567

TIL 12u
01100011
00100011
00000001
00000000
00000000
00000000
00000000
00000000
NAME splashf 568

TIL 12v
11110001
11110001
11100000
11000000
00000000
00000000
00000000
00000000
NAME splashf 569

TIL 12w
00000000
00000100
00000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 570

TIL 12x
00111110
00111110
00111100
00001000
00000000
00000000
00000000
00000000
NAME splashf 571

TIL 12y
00110001
00100001
00000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 572

TIL 12z
00000000
00000000
00000000
00000000
00000000
00001110
00011111
00011111
NAME splashf 573

TIL 13a
11110001
11100011
00000011
00000111
00011110
00111100
00011110
00001111
NAME splashf 584

TIL 13b
10001111
11001111
11000000
11100000
01111000
00111111
01111111
11111111
NAME splashf 585

TIL 13c
11100000
11000000
10000000
10000000
00000000
00000000
00000000
00000000
NAME splashf 586

TIL 13d
00000111
00001111
00001111
00001111
00001111
00001111
00001111
00001111
NAME splashf 587

TIL 13e
11111111
11100000
11000000
10000000
10000000
10000000
10000000
10000000
NAME splashf 588

TIL 13f
11111111
11111111
01111111
01111111
00111100
00111100
00111110
01111111
NAME splashf 589

TIL 13g
11100111
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 590

TIL 13h
11111000
01111000
01111000
11111000
00111100
00011100
11111100
11111000
NAME splashf 591

TIL 13i
00000111
00000011
00000001
00000001
00000000
00000000
00000000
00000000
NAME splashf 592

TIL 13j
11111111
11111111
11111111
11111111
11111111
01111111
00111111
00111111
NAME splashf 593

TIL 13k
00000000
00000000
00000000
00000000
00001111
00111111
01111111
11111101
NAME splashf 594

TIL 13l
00000000
00000000
00000000
00000000
10000000
11100000
11111000
11111100
NAME splashf 595

TIL 13m
11000000
11100001
11111111
11111111
11111111
11111111
11111111
11111111
NAME splashf 596

TIL 13n
01111111
11111111
11111111
11100011
11100001
11000001
10000000
10001000
NAME splashf 597

TIL 13o
00000000
01000010
11100111
11110111
11111111
11111111
11111111
01111111
NAME splashf 598

TIL 13p
01111000
01111000
11111000
11111000
11111000
11111000
11111000
11111000
NAME splashf 599

TIL 13q
00000000
00000000
00000000
00000000
00000000
00000001
00000111
00001111
NAME splashf 600

TIL 13r
00000000
00000000
00000000
00000000
01111100
11111111
11111111
11111111
NAME splashf 601

TIL 13s
00000000
00000000
00000000
00000000
00000000
00000000
10000000
11000000
NAME splashf 602

TIL 13t
00011111
00011111
00001111
00000111
00000111
00000011
00000011
00000001
NAME splashf 603

TIL 13u
11100000
11100000
11000000
11000000
11100001
01111111
00111110
00000000
NAME splashf 604

TIL 13v
00111110
00001111
00000111
10000011
00000001
00000000
00000000
00000000
NAME splashf 605

TIL 13w
00000000
00000100
10000010
11000010
11111110
01111100
00000000
00000000
NAME splashf 606

TIL 13x
00000111
00000111
00000001
00000000
00000000
00000000
00000000
00000000
NAME splashf 607

TIL 13y
11111111
11111111
11111111
00011111
00011111
00011111
00011111
00011111
NAME splashf 608

TIL 13z
10001100
11111111
11111111
11111111
11111111
11111111
11011111
11111111
NAME splashf 609

TIL 14a
00000000
00000000
00000000
11111000
11111100
11001110
11001110
11001110
NAME splashf 620

TIL 14b
01100000
01000000
00000000
11100011
11100011
11100011
11100011
11100011
NAME splashf 621

TIL 14c
00000000
00000000
00000000
11000000
11000000
11000000
11100000
11100000
NAME splashf 622

TIL 14d
00000000
00000000
00000000
00111110
00111111
00110011
00110001
00110001
NAME splashf 623

TIL 14e
00000000
00000000
00000000
00011111
00011111
10011000
10011000
10011000
NAME splashf 624

TIL 14f
00000000
00000000
00000000
00000000
00000001
00000011
00000011
00000111
NAME splashf 625

TIL 14g
00000000
00000000
00000000
00000000
11000000
11000000
10000000
10000000
NAME splashf 626

TIL 14h
00111000
00011100
00001100
00000110
00000010
00000000
00000000
00000000
NAME splashf 627

TIL 14i
00000001
00000001
00000001
00000001
00000001
00000001
00000001
11100001
NAME splashf 628

TIL 14j
11001110
11001110
11001110
11001110
11001110
11001110
11001110
11001110
NAME splashf 629

TIL 14k
11100011
11100011
11100011
11100110
11100110
11100110
11100111
11100111
NAME splashf 630

TIL 14l
01100000
01100000
01100000
01110000
01110000
01110000
11110000
11110000
NAME splashf 631

TIL 14m
00110001
00110001
00110001
00110001
00110001
00110001
00110001
00110001
NAME splashf 632

TIL 14n
10011000
10011000
10011111
10011111
10011000
10011000
10011000
10011000
NAME splashf 633

TIL 14o
00001111
00001110
00001100
00011000
00010000
00000000
00000000
11000000
NAME splashf 634

TIL 14p
00111110
00111111
00111111
00000000
00000000
00000000
00000000
00000000
NAME splashf 635

TIL 14q
00000000
11100000
11111000
00000000
00000000
00000000
00000000
00001000
NAME splashf 636

TIL 14r
11100001
11100001
01000001
00000000
00000000
00000000
00000000
00001000
NAME splashf 637

TIL 14s
11001110
11111100
11111000
00000000
00000000
00000000
00000000
00000000
NAME splashf 638

TIL 14t
11101110
11101100
11101100
00000000
00000000
00000000
00000000
00000000
NAME splashf 639

TIL 14u
00110000
00111000
00111000
00000000
00000000
00000000
00000000
00000000
NAME splashf 640

TIL 14v
00110011
00111111
00111110
00000000
00000000
00000000
00000000
00000000
NAME splashf 641

TIL 14w
10011000
00011111
00011111
00000000
00000000
00000000
00000000
00000000
NAME splashf 642

TIL 14x
00000011
10000001
10000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 643

TIL 14y
11000000
11000011
10000111
00000000
00000000
00000000
00000000
00000000
NAME splashf 644

TIL 14z
00111111
11111111
11111111
00000000
00000000
00000000
00000000
00000000
NAME splashf 645

TIL 15a
11100000
11110000
11111100
10001111
10000111
00000101
00000011
00000011
NAME splashf 656

TIL 15b
00000000
00000001
00000011
10001110
10011110
11001110
10011110
10001111
NAME splashf 657

TIL 15c
11000000
11110000
11111100
00011100
00001100
00001100
00000100
00000000
NAME splashf 658

TIL 15d
00011011
00011011
00010011
00010001
00010001
00011001
00011000
00011000
NAME splashf 659

TIL 15e
00011101
00011001
10111001
10110001
11110001
10110001
11110001
11110001
NAME splashf 660

TIL 15f
10000110
10000110
10000110
10000110
10001110
10001111
10000011
10001111
NAME splashf 661

TIL 15g
00000110
00000110
00000110
00001110
00001110
00011110
00011000
00011110
NAME splashf 662

TIL 15h
00111111
00110111
00111110
00110000
00110000
00110000
00111000
00111100
NAME splashf 663

TIL 15i
11100001
11100001
11100001
00000001
00000001
00000001
00000001
00010011
NAME splashf 664

TIL 15j
10000011
11111111
11111110
11101110
10011110
10001110
10000111
10000011
NAME splashf 665

TIL 15k
00110000
00110000
00110000
00110000
00110000
00110000
00110000
00110000
NAME splashf 666

TIL 15l
00001100
00001110
00011110
00001111
00001111
00000110
00000110
00000111
NAME splashf 667

TIL 15m
00000011
00000001
00000001
00000011
00000011
00000111
00000110
00000111
NAME splashf 668

TIL 15n
10000111
10000011
00000001
00000000
10000000
10001100
10001100
00001100
NAME splashf 669

TIL 15o
10000000
11100000
11111000
11111000
00011100
00011110
00011110
00111100
NAME splashf 670

TIL 15p
00011000
00111000
00111100
00110100
00000000
00000000
00000000
00000000
NAME splashf 671

TIL 15q
11110011
11110011
11100111
01100111
00000000
00000000
00000000
00000000
NAME splashf 672

TIL 15r
10000111
10000011
11000000
11000000
00000000
00000000
00000000
00000000
NAME splashf 673

TIL 15s
00011110
11111000
11110000
11100000
00000000
00000000
00000000
00000000
NAME splashf 674

TIL 15t
01111000
00111111
01111111
01110000
00000000
00000000
00000000
00000000
NAME splashf 675

TIL 15u
00110011
11110011
11110011
00010011
00000000
00000000
00000000
00000000
NAME splashf 676

TIL 15v
10000011
11000011
11100111
11000011
00000000
00000000
00000000
00000010
NAME splashf 677

TIL 15w
10000000
11000000
11100000
11100000
00000000
00000000
00000000
00000000
NAME splashf 678

TIL 15x
00111000
00111000
01111100
01111100
00000000
00000000
00000000
00000000
NAME splashf 679

TIL 15y
00000111
00000011
00000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 680

TIL 15z
10001111
11111100
01111000
00110000
00000000
00000000
00000000
00000000
NAME splashf 681

TIL 16a
00000000
00000000
00000000
10000000
10000000
11000000
11100000
11110000
NAME splashf 692

TIL 16b
00000000
00000000
00000000
00000000
00000011
00000000
00000000
00001100
NAME splashf 693

TIL 16c
01000111
11100011
11111000
00001000
10010100
01101100
01001110
11001110
NAME splashf 694

TIL 16d
11011111
00000011
00000001
00000000
00000000
00000000
00000000
00000000
NAME splashf 695

TIL 16e
10000000
11000011
11001111
00000100
00010010
00011011
00011001
00111001
NAME splashf 696

TIL 16f
10000000
11000000
11000000
00000000
11110000
00000000
10000000
11011000
NAME splashf 697

TIL 16g
11110000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 698

TIL 16h
00000000
00000000
00000000
00000001
00000001
00000011
00000111
00001111
NAME splashf 699

TIL 16i
00111111
01111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME splashf 700

TIL 16j
11111000
11111100
01111110
01111111
11100000
11000000
10001110
10001111
NAME splashf 701

TIL 16k
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00010000
NAME splashf 702

TIL 16l
00000001
00000001
00011011
00000111
00011111
00111110
00111000
00000000
NAME splashf 703

TIL 16m
11100110
10100000
10110000
00010000
00000000
10000000
00000000
00000000
NAME splashf 704

TIL 16n
00111010
00000010
00000010
00000010
00000000
00000000
00000000
00000000
NAME splashf 705

TIL 16o
11000000
11100000
11110100
01110000
00111100
10011110
00001110
00000000
NAME splashf 706

TIL 16p
00011111
00111111
00111100
01111100
00001110
00000111
11100011
11110011
NAME splashf 707

TIL 16q
11111111
11111111
01111111
01111111
01110000
11100000
11000111
10001111
NAME splashf 708

TIL 16r
00011111
00011111
00001111
00000010
00000000
00000000
00000000
00000000
NAME splashf 709

TIL 16s
10001000
10001000
00000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 710

TIL 16t
00000001
00100001
00000001
00000000
00000000
00000000
00000000
00000000
NAME splashf 711

TIL 16u
11110001
11110001
11100000
01000000
00000000
00000000
00000000
00000000
NAME splashf 712

TIL 16v
10001111
00001111
00000111
00000010
00000000
00000000
00000000
00000000
NAME splashf 713

TIL 16w
00000000
00000000
00000000
00000000
00000000
00000000
10000000
10000100
NAME splashf 714

TIL 16x
00000000
00000000
00000000
00000000
00000000
00111000
00111100
01111100
NAME splashf 715

TIL 16y
00000000
00000000
00000000
00000000
00000000
00000111
00011111
01111111
NAME splashf 716

TIL 16z
00000000
00000000
00000000
00000000
00000000
00000000
11100000
11110000
NAME splashf 717

TIL 17a
11000110
10001111
00001111
00011111
01111001
01111000
00111001
00111111
NAME splashf 728

TIL 17b
11111111
11111111
11111110
11111110
11111100
11111000
11111000
11110000
NAME splashf 729

TIL 17c
00011111
00111111
00111111
00111110
00111110
00111110
00111110
00111110
NAME splashf 730

TIL 17d
11111111
10000011
00000001
00000001
00000000
00000000
00000001
00000001
NAME splashf 731

TIL 17e
11111101
11111100
11111100
11111100
11110000
11110000
11111000
11111100
NAME splashf 732

TIL 17f
10011111
00000001
00000001
00000011
00000000
00000000
00000001
00000011
NAME splashf 733

TIL 17g
11100000
11100000
11100000
11100000
11100000
01100000
11100000
11100000
NAME splashf 734

TIL 17h
00011111
00001111
00000111
00000111
00000011
00000001
00000000
00000000
NAME splashf 735

TIL 17i
11100000
11100000
11000000
11000000
10000000
10000000
00000000
00000000
NAME splashf 736

TIL 17j
00000000
00000000
00000000
00000000
00111110
11111111
11111111
11110111
NAME splashf 737

TIL 17k
00000000
00000000
00000000
00000000
00000000
10000000
11100000
11110000
NAME splashf 738

TIL 17l
00000001
11000111
11111111
11111111
11111111
11111111
11111110
11111110
NAME splashf 739

TIL 17m
11111100
11111100
11011111
11001111
10000111
00000011
00100011
00110001
NAME splashf 740

TIL 17n
00000001
00001001
10001111
11011111
11111111
11111111
11111111
11111111
NAME splashf 741

TIL 17o
00000000
00000000
00000000
00000000
00000001
00000111
00011111
00111111
NAME splashf 742

TIL 17p
00000000
00000000
00000000
00000000
11110000
11111100
11111110
11111111
NAME splashf 743

TIL 17q
00000011
00000011
00000111
00000011
00000011
00000001
00000000
00000000
NAME splashf 744

TIL 17r
10000000
10000000
00000000
00000010
10000100
11111100
11111000
00000000
NAME splashf 745

TIL 17s
11111100
00111100
00011110
00001111
00000111
00000001
00000000
00000000
NAME splashf 746

TIL 17t
00000000
00000000
00001000
10001000
11111000
11110000
00000000
00000000
NAME splashf 747

TIL 17u
00011111
00011111
00000111
00000000
00000000
00000000
00000000
00000000
NAME splashf 748

TIL 17v
11111110
11111111
11111111
01111111
01111111
01111111
01111111
01111111
NAME splashf 749

TIL 17w
00110011
11111111
11111111
11111111
11111111
11111111
01111111
11111111
NAME splashf 750

TIL 17x
11111111
11111111
11111111
11110000
11110000
11110000
00110000
11110000
NAME splashf 751

TIL 17y
11100000
11000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 752

TIL 17z
00000000
00100000
01000001
01000011
01111111
00111111
00000000
00000000
NAME splashf 753

TIL 18a
00000000
00000000
00000000
00000000
10000000
10000000
10000000
10000000
NAME splashf 764

TIL 18b
00000000
00000000
00000000
11111000
11111100
11001110
11000110
11000110
NAME splashf 765

TIL 18c
00000000
00000000
00000000
01111110
01111110
01100000
01100000
01100000
NAME splashf 766

TIL 18d
00000000
00000000
00000000
00000000
00000111
00001111
00001110
00011110
NAME splashf 767

TIL 18e
11100000
01110000
00110000
00011000
00001000
00000000
00000000
00000011
NAME splashf 768

TIL 18f
00000111
00000111
00000111
00000111
00000111
00000111
00000111
10000111
NAME splashf 769

TIL 18g
00111011
00111011
00111011
00111011
00111011
00111011
00111011
00111011
NAME splashf 770

TIL 18h
10001101
10001101
10011101
10011001
10011001
10011001
10011111
10011111
NAME splashf 771

TIL 18i
10000000
10000000
10000000
10000000
11000000
11000000
11000000
11000000
NAME splashf 772

TIL 18j
11000110
11000110
11000110
11000110
11000110
11000110
11000110
11000110
NAME splashf 773

TIL 18k
01100000
01100000
01111110
01111110
01100000
01100000
01100000
01100000
NAME splashf 774

TIL 18l
00111100
00111000
00110000
01100000
01000000
00000000
00000000
00000000
NAME splashf 775

TIL 18m
11111100
11111111
11111111
00000000
00000000
00000000
00000000
00000000
NAME splashf 776

TIL 18n
00000011
11000011
11100001
00000000
00000000
00000000
00000000
00100000
NAME splashf 777

TIL 18o
10000111
10000111
00000011
00000000
00000000
00000000
00000000
00100000
NAME splashf 778

TIL 18p
00111011
11110011
11100011
00000000
00000000
00000000
00000000
00000000
NAME splashf 779

TIL 18q
10011000
10111000
10110000
00000000
00000000
00000000
00000000
00000000
NAME splashf 780

TIL 18r
11000000
11100000
11100000
00000000
00000000
00000000
00000000
00000000
NAME splashf 781

TIL 18s
01100000
01111110
01111110
00000000
00000000
00000000
00000000
00000000
NAME splashf 782

TIL 18t
00001111
00000111
00000010
00000000
00000000
00000000
00000000
00000000
NAME splashf 783

TIL 18u
00000000
00001111
00011111
00000000
00000000
00000000
00000000
00000000
NAME splashf 784

TIL 18v
11111100
11111100
11111100
00000000
00000000
00000000
00000000
00000000
NAME splashf 785

TIL 18w
11111000
11111000
11110000
10110000
11111000
11011000
11111000
01111000
NAME splashf 786

TIL 18x
00011111
00011111
00111110
00011110
00111110
00110100
00111100
00111100
NAME splashf 787

TIL 18y
01111100
00111100
00011000
00011000
00011000
00011000
00011000
00011000
NAME splashf 788

TIL 18z
01111101
01111001
00111000
00011000
00011000
00011000
00011000
00011000
NAME splashf 789

TIL 19a
01110100
01100100
01100110
11000110
11000110
11000110
11000110
11000110
NAME splashf 800

TIL 19b
00011000
00011000
00011000
00011000
00111000
00111100
00001100
00111100
NAME splashf 801

TIL 19c
00011000
00011000
00011000
00011000
00111000
01111100
01100000
01111000
NAME splashf 802

TIL 19d
11111111
11111111
11111011
11000000
11000000
11000000
11100000
11110000
NAME splashf 803

TIL 19e
10000110
10000111
10000111
00000111
00000110
00000110
00000110
01000110
NAME splashf 804

TIL 19f
00001111
11111110
11111000
10011100
01111100
00111100
00011100
00001100
NAME splashf 805

TIL 19g
11000000
11000000
11000000
11000000
11000000
11000000
11000000
11100000
NAME splashf 806

TIL 19h
00110000
00111000
00111000
00111100
00111100
00011000
00011000
00011100
NAME splashf 807

TIL 19i
00001110
00000110
00000110
00001100
00001110
00011110
00111010
00011100
NAME splashf 808

TIL 19j
00011110
00000111
00000111
00000011
00000000
01110000
00110000
00110000
NAME splashf 809

TIL 19k
00000000
10000000
11100000
11100000
01110000
01111000
01111000
11110000
NAME splashf 810

TIL 19l
01100011
01100011
11110011
11010001
00000000
00000000
00000000
00000000
NAME splashf 811

TIL 19m
11000110
11001110
10011111
10001111
00000000
00000000
00000000
00000000
NAME splashf 812

TIL 19n
00011110
00001111
00000011
00000011
00000000
00000000
00000000
00000000
NAME splashf 813

TIL 19o
01111001
11100000
11000001
10000000
00000000
00000000
00000000
00000000
NAME splashf 814

TIL 19p
11110000
11111111
11111111
11000000
00000000
00000000
00000000
00000000
NAME splashf 815

TIL 19q
11001110
11001111
11101111
01001111
00000000
00000000
00000000
00000000
NAME splashf 816

TIL 19r
00001110
00001111
10011111
00001111
00000000
00000000
00000000
00001000
NAME splashf 817

TIL 19s
00000000
00000000
10000001
10000001
00000000
00000000
00000000
00000000
NAME splashf 818

TIL 19t
11100000
11100000
11110000
11110000
00000000
00000000
00000000
00000000
NAME splashf 819

TIL 19u
00011110
00001111
00000001
00000000
00000000
00000000
00000000
00000000
NAME splashf 820

TIL 19v
00111100
11110000
11100000
11000000
00000000
00000000
00000000
00000000
NAME splashf 821

TIL 19w
00111001
00111111
00000111
00000011
00000000
00000000
00000000
00000000
NAME splashf 822

TIL 19x
11110000
10000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 823

TIL 19y
00000000
10000000
10000000
11000000
11000000
11100000
11100000
11110000
NAME splashf 824

TIL 19z
01111000
01111100
01111100
01111111
01111111
01111111
01111100
01111100
NAME splashf 825

TIL 1a0
00000000
00000000
00000000
11111000
11111000
11110000
00000000
00000000
NAME splashf 826

TIL 1a1
00000000
00000000
00000000
00000000
00000000
00000000
00000011
00001111
NAME splashf 827

TIL 1a2
00111000
00111000
00111000
00111000
01110000
01110000
11111000
11111100
NAME splashf 828

TIL 1a3
00000000
00000000
00000000
00000011
00000011
00000011
00000000
00000000
NAME splashf 829

TIL 1a4
00000011
00000111
00000111
11111111
11111111
11111111
00000111
00000111
NAME splashf 830

TIL 1a5
11000000
11000000
11000000
11000000
11000000
11000000
11000000
11000000
NAME splashf 831

TIL 1a6
01111000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 832

TIL 1a7
00000001
00000011
00000011
00000000
00001110
00000101
00000001
00110011
NAME splashf 833

TIL 1a8
00011111
11001100
11100000
00100000
01010000
10010000
00111000
00111000
NAME splashf 834

TIL 1a9
00111110
00001111
00000111
00000000
00000000
00000000
00000000
00000000
NAME splashf 835

TIL 1aa
00000010
00001111
00111111
00010000
01001011
01100100
01100110
11100111
NAME splashf 836

TIL 1ab
00000000
00000000
00000000
00000000
11000000
00000000
00000000
01100000
NAME splashf 837

TIL 1ac
00000000
00000001
00000011
00000111
00000111
00001111
00011111
00111111
NAME splashf 838

TIL 1ad
11111111
11111111
11110001
11110001
01110011
00111111
00011110
10001110
NAME splashf 839

TIL 1ae
11100000
11110000
11111000
11111100
11000000
00000000
00011100
00111100
NAME splashf 840

TIL 1af
00000000
00000000
00000000
00000000
00000000
00000000
00000000
01000000
NAME splashf 841

TIL 1ag
00000111
00000111
01101110
00011100
01111100
11111010
11100000
00000000
NAME splashf 842

TIL 1ah
00011000
10000000
11000000
01000000
00000000
00000000
00000000
00000000
NAME splashf 843

TIL 1ai
11100011
00001011
00001011
00001001
00000000
00000010
00000000
00000000
NAME splashf 844

TIL 1aj
00000000
10000000
11010000
11100000
11110000
01111000
00111000
00000000
NAME splashf 845

TIL 1ak
00000000
00000000
00000000
00000001
00000000
00000000
00000011
00000111
NAME splashf 846

TIL 1al
01111111
01111111
11110001
11110001
00111001
00011111
10001111
11000110
NAME splashf 847

TIL 1am
10001100
10000100
10000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 848

TIL 1an
01111110
01111110
00111100
00011000
00000000
00000000
00000000
00000000
NAME splashf 849

TIL 1ao
00100000
00100000
00000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 850

TIL 1ap
00000111
10000111
00000111
00000001
00000000
00000000
00000000
00000000
NAME splashf 851

TIL 1aq
11000110
11000100
11000000
00000000
00000000
00000000
00000000
00000000
NAME splashf 852

TIL 1ar
01110000
01110000
01111000
11111000
11111000
01110000
01110000
01110000
NAME Altar 1

TIL 1as
11110000
11110000
11111000
11111000
11111000
11111000
11111000
11111000
NAME Altar 2

TIL 1at
01111111
11111111
11111111
11111111
11111111
11111111
11111111
01111111
NAME Altar 3

TIL 1au
00000000
00000000
00000110
00000000
00001000
00000000
00000000
00100000
NAME Altar 4

TIL 1av
11111111
00011111
11000011
11111110
11111111
11111111
11111111
11111110
NAME Altar 5

TIL 1aw
11111111
11111111
11111111
11111111
10011111
11110000
11110000
11111111
NAME Altar 6

TIL 1ax
01111000
01111000
01111000
01111000
11111000
11111000
11111000
01111100
NAME Altar 7

TIL 1ay
00000011
00000011
00000001
00000001
00000001
00000001
00000011
00000011
NAME Altar 8

TIL 1az
11111000
11111000
11111000
11111100
11111100
11111000
11111000
11111000
NAME Altar 9

TIL 1b0
11100000
11100000
11100000
11100000
11100000
11100000
11110000
11100000
NAME Altar 10

TIL 1b1
11111111
11111111
11111111
11111111
01111111
11111111
01111111
01111111
NAME Altar 11

TIL 1b2
10000000
10000000
10000000
10000000
10000001
10000010
10000000
11000100
NAME Altar 12

TIL 1b3
00000001
01000001
00000011
00000011
00000111
00000111
00001111
00001111
NAME Altar 13

TIL 1b4
11111110
11111110
11111110
11111000
11111000
11111001
11110000
11000000
NAME Altar 14

TIL 1b5
01111111
01111111
11111001
11110001
11110011
11111001
11111111
11111111
NAME Altar 15

TIL 1b6
01111100
01111100
01111100
01111100
11111100
01111100
01111100
01111110
NAME Altar 16

TIL 1b7
11111100
11111100
11111100
11111100
11111000
11111000
11111000
11111000
NAME Altar 17

TIL 1b8
00001111
00000111
00001111
00001111
00001111
00001111
00001111
00001111
NAME Altar 18

TIL 1b9
11100000
11100000
11110000
11110000
11110000
11110000
11110000
11110000
NAME Altar 19

TIL 1ba
01111111
11111111
11111111
11111111
11111110
01111100
01111000
01110001
NAME Altar 20

TIL 1bb
11000100
10001000
00011000
00110000
01100000
01000000
10000000
10000000
NAME Altar 21

TIL 1bc
11111111
11111111
11111111
11111110
11111111
11111111
11111111
11111111
NAME Altar 22

TIL 1bd
11000000
11000000
11000000
00000000
10000000
11000000
10000001
10000011
NAME Altar 23

TIL 1be
11110011
00000011
00000001
00000011
00000011
00000011
10000011
10000111
NAME Altar 24

TIL 1bf
01111110
01111100
01111100
01111100
01111100
01111100
01111110
01111110
NAME Altar 25

TIL 1bg
11111000
11111000
11111100
11111100
11111100
11111100
11111110
11111110
NAME Altar 26

TIL 1bh
00001111
00001111
00000111
00000111
00001111
00001111
00001111
00001111
NAME Altar 27

TIL 1bi
01110001
01000100
00000000
00000000
00000000
00000000
00000000
00000000
NAME Altar 28

TIL 1bj
11111111
11111111
10111111
11111111
11111111
11111111
11111111
11111111
NAME Altar 29

TIL 1bk
10000111
10001111
11011111
11111111
11111111
11111111
11111111
11111111
NAME Altar 30

TIL 1bl
10000111
00110011
10110111
11111111
11111111
11111111
11111111
11111111
NAME Altar 31

TIL 1bm
01111110
01111111
01111110
01111100
01111110
01111110
00111100
00111110
NAME Altar 32

TIL 1bn
00000001
00000001
00000001
00000001
00000001
00000000
00000001
00000001
NAME Altar 33

TIL 1bo
11111110
11111110
11111110
11111110
11111110
11111100
11111110
11111110
NAME Altar 34

TIL 1bp
00001111
00001111
00000111
00000111
00001111
00001111
00000111
00000111
NAME Altar 35

TIL 1bq
00000000
00000000
00000000
00001000
00010000
01100000
01000000
00000000
NAME Altar 36

TIL 1br
00111111
00111101
00111011
00111001
11000011
11000011
11000111
11111111
NAME Altar 37

TIL 1bs
00111110
00111110
00111110
00111110
00111111
00111111
01111110
00111111
NAME Altar 38

TIL 1bt
00001111
00000111
00001111
00000011
00000111
00011111
00111111
01111111
NAME Altar 39

TIL 1bu
00111111
00111111
00111111
00111111
00111110
00111111
00111111
00111111
NAME Altar 40

TIL 1bv
11111110
11111110
11111111
11111110
11111111
11111110
11111111
11111111
NAME Altar 41

TIL 1bw
11111111
11111111
11111111
10111111
11000111
11111000
11111111
11111111
NAME Altar 42

TIL 1bx
11111111
11111111
11111111
11111111
00000111
00000011
00000001
11100000
NAME Altar 43

TIL 1by
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11001111
NAME Altar 44

TIL 1bz
00000001
00000000
00000000
00000000
00000000
00000000
00000000
00000001
NAME Altar 45

TIL 1c0
11111111
11111111
11101001
11000000
11000000
11000000
11001000
11001000
NAME Altar 46

TIL 1c1
11111000
11111110
11111111
11111111
11111111
11111111
11111111
11111111
NAME Altar 47

TIL 1c2
01101111
00011111
11100000
11110000
11111110
11111110
11111111
11111111
NAME Altar 48

TIL 1c3
11111111
11111111
11111111
01111111
00011111
00000111
00000000
00000000
NAME Altar 49

TIL 1c4
00111111
00111111
00111111
00111111
00011111
00111111
00111111
00011111
NAME Altar 50

TIL 1c5
00000000
00000000
00000000
10000000
00000000
00000000
00000000
10000000
NAME Altar 51

TIL 1c6
00001111
00001111
00011111
00111111
11011111
11111111
11111111
11111111
NAME Altar 52

TIL 1c7
10000000
10000001
00000011
10000111
10001111
10111111
00111111
00111111
NAME Altar 53

TIL 1c8
11111111
11111111
10111111
00011111
00001111
00000001
10000000
10000000
NAME Altar 54

TIL 1c9
11110000
11110000
11100000
11000000
10000000
00000000
00000000
00000000
NAME Altar 55

TIL 1ca
11000000
11100000
11110000
11110000
11111000
11111100
11111100
11111110
NAME Altar 56

TIL 1cb
00000000
00000000
00000000
00000001
00000001
10000011
00000011
00000011
NAME Altar 57

TIL 1cc
00000111
00000111
00001100
00011100
00011100
10111110
10111110
11111110
NAME Altar 58

TIL 1cd
11111110
11111110
11111110
11111110
11111100
11111100
11111100
11111100
NAME Altar 59

TIL 1ce
00000000
00000000
00000000
00000000
00000000
00000000
00011111
00010111
NAME Altar 60

TIL 1cf
00000000
00000000
00000000
00111010
01111111
01101011
11010011
11100001
NAME Altar 61

TIL 1cg
00000000
00000000
00000000
00001111
00111101
11110000
00100000
00100000
NAME Altar 62

TIL 1ch
00000000
00000000
00000000
00000111
11111111
11011100
11001000
10000000
NAME Altar 63

TIL 1ci
00000000
00000000
00000000
11000000
01111110
00110011
00100001
01100100
NAME Altar 64

TIL 1cj
00000000
00000000
00000000
00000000
00000000
00000000
11100000
10110000
NAME Altar 65

TIL 1ck
00000000
00000000
00000000
00000000
00000011
00000101
00001000
00111000
NAME Altar 66

TIL 1cl
00110001
01100001
01000011
10100011
00010101
10000011
10000110
01001110
NAME Altar 67

TIL 1cm
11100001
00000000
00110001
00011011
10011100
11010000
01000000
00000000
NAME Altar 68

TIL 1cn
00110000
00011111
00011101
11100000
10000000
00000000
00000000
00000000
NAME Altar 69

TIL 1co
10000100
10001011
01111111
00010000
00000000
00000000
00000000
00000000
NAME Altar 70

TIL 1cp
00001100
01111000
01011000
00001000
00000111
00000001
00000000
00000000
NAME Altar 71

TIL 1cq
01111110
00111111
00110000
00100000
11110000
11110001
00111001
00001111
NAME Altar 72

TIL 1cr
00000000
10000000
11000000
01100000
11111000
00000100
00000100
00000100
NAME Altar 73

TIL 1cs
00000000
00000000
00000000
00000000
00000000
00000111
00001110
00001100
NAME Altar 74

TIL 1ct
01101000
01001000
11000101
11000001
01000011
11101111
11000011
01000011
NAME Altar 75

TIL 1cu
00111100
01100000
11100000
11000000
00000000
00000000
00000000
00000000
NAME Altar 76

TIL 1cv
00000001
00000001
00000000
00000000
00000000
00000000
00000000
00000000
NAME Altar 77

TIL 1cw
00001110
11110001
11100101
11001000
01101000
00111000
00011000
00000101
NAME Altar 78

TIL 1cx
00000000
01000000
11000000
01100000
00111000
00011100
01001100
10001100
NAME Altar 79

TIL 1cy
00001100
00000101
00011000
00011000
00011000
00111100
01100101
00100001
NAME Altar 80

TIL 1cz
01100111
00111110
11110000
00100000
01110000
01100000
11100000
10000000
NAME Altar 81

TIL 1d0
00000000
00000001
00000001
00000001
00000001
00000001
00000001
00000001
NAME Altar 82

TIL 1d1
01000000
11000000
11100000
11100000
11100000
11100000
11100000
11100000
NAME Altar 83

TIL 1d2
00000000
00000000
00000000
00000000
00000000
00000000
00000111
00001111
NAME Altar 84

TIL 1d3
00000000
00000000
00000000
00000000
00000000
00000000
11110000
01111000
NAME Altar 85

TIL 1d4
00000001
00000011
00000111
00000111
00000111
00000111
00000111
00000011
NAME Altar 86

TIL 1d5
00000000
10000000
11000000
11000000
10000000
10000000
11000000
11000000
NAME Altar 87

TIL 1d6
00000111
00000011
00000000
00000000
00000001
00000000
00000000
00000000
NAME Altar 88

TIL 1d7
00001100
00011100
10111110
10000010
10000111
11010111
11100001
01100000
NAME Altar 89

TIL 1d8
00111000
01111101
01000000
11000001
01100001
01110011
11001110
10000010
NAME Altar 90

TIL 1d9
10000000
10000000
00000000
10000000
00000000
10000000
00000000
00000000
NAME Altar 91

TIL 1da
00011111
00011111
00111111
00110001
00110011
00111111
00011111
00000011
NAME Altar 92

TIL 1db
11111000
11111100
11111100
11001100
11001100
01111100
11111000
11100000
NAME Altar 93

TIL 1dc
11000000
11000000
11000000
11000000
10000000
10000000
10000000
11000000
NAME Altar 94

TIL 1dd
01000000
00100001
00111001
00110000
00110000
00100000
00110000
00011101
NAME Altar 95

TIL 1de
10000000
10000000
10000000
11000000
11000000
01000000
11000000
01000000
NAME Altar 96

TIL 1df
00000001
00000000
00000000
00000000
00000000
00000001
00000001
00000011
NAME Altar 97

TIL 1dg
10000010
11000111
01110101
01000001
11000001
11100001
10011011
10001101
NAME Altar 98

TIL 1dh
00000000
00000000
10000000
10000000
10000000
00000000
00000000
10000000
NAME Altar 99

TIL 1di
00011111
00011100
00011100
00011100
00001111
00001111
00001010
00000000
NAME Altar 100

TIL 1dj
11111111
11111100
01111100
11101111
11100111
00000010
01000110
01001111
NAME Altar 101

TIL 1dk
11111111
11111111
11111100
11101100
11001110
00001111
00000000
00000000
NAME Altar 102

TIL 1dl
11111111
01111111
00101111
00111011
01101001
11111000
00001000
00000000
NAME Altar 103

TIL 1dm
11111111
00111111
00101111
11111001
11110011
00111000
00111001
00111000
NAME Altar 104

TIL 1dn
11111000
10111000
00011000
00111000
11111000
10010000
01001000
00000000
NAME Altar 105

TIL 1do
00011000
00010000
00011100
00110111
00100001
01100000
00100000
00100000
NAME Altar 106

TIL 1dp
01000000
01100000
01000000
11000000
11000000
11100000
00110000
10110000
NAME Altar 107

TIL 1dq
00000000
00000001
00000000
00000001
00000111
00000010
00000110
00000010
NAME Altar 108

TIL 1dr
00010000
11000000
10100000
10010000
00101101
00010001
00011001
00010111
NAME Altar 109

TIL 1ds
11000000
00000000
00000000
00000000
00000001
00000011
00000011
00000111
NAME Altar 110

TIL 1dt
00011011
00011011
00011011
11111111
11111111
11111111
11111111
11111111
NAME Altar 111

TIL 1du
11001111
01001111
11101111
11111110
11000010
11100110
11111110
11111111
NAME Altar 112

TIL 1dv
00000000
00000000
00000010
00000011
00000001
00000001
00000000
10000000
NAME Altar 113

TIL 1dw
00111011
00111011
00111111
11100011
11100011
11100011
10110111
01111111
NAME Altar 114

TIL 1dx
01111000
01111000
01101000
11100000
11111100
11111111
11111111
11111111
NAME Altar 115

TIL 1dy
00011110
00001110
00011100
00011000
00011000
00111000
01111100
00100011
NAME Altar 116

TIL 1dz
00000000
11110000
01100000
01000000
01100000
01100000
11000000
10000000
NAME Altar 117

TIL 1e0
00000011
00000011
00000110
00000110
00000011
00000011
00000000
00000000
NAME Altar 118

TIL 1e1
00101110
01111110
00011110
00011110
00111110
00011110
00001110
00000000
NAME Altar 119

TIL 1e2
00000110
00000110
01000111
00000111
00100011
01000100
00000000
00000000
NAME Altar 120

TIL 1e3
01111100
00111100
11111111
11101111
11111111
01111111
01111111
00001111
NAME Altar 121

TIL 1e4
11111000
11000000
11000000
11101111
01001111
00100000
11111000
11111100
NAME Altar 122

TIL 1e5
00000000
00000011
00000011
11100011
11100011
01000011
00000001
00000000
NAME Altar 123

TIL 1e6
10000000
11000000
11000000
11000000
11100100
11011000
11000000
00000000
NAME Altar 124

TIL 1e7
00111111
00000001
00000001
00000001
00001001
01001000
00001111
00011111
NAME Altar 125

TIL 1e8
11111111
00111100
10111100
11111111
11111111
00111110
11111100
11111000
NAME Altar 126

TIL 1e9
11000000
11000000
11000000
11000001
11001000
00100000
00000000
00000000
NAME Altar 127

TIL 1ea
00000011
00111010
00111100
01111100
01111110
01111010
01110000
00000000
NAME Altar 128

TIL 1eb
11100000
01110000
00110000
00110000
00110000
00110000
00100000
00000000
NAME Altar 129

TIL 1ec
00001110
00001110
00001110
00001111
00001111
00001111
00000000
00000000
NAME Altar 130

TIL 1ed
00111100
00011100
00111100
11111100
11111000
11000000
00000000
00000000
NAME Altar 131

TIL 1ee
00010110
00010100
00010110
00010111
00001111
00000001
00000000
00000000
NAME Altar 132

TIL 1ef
00101000
00111000
00111000
11111000
11111000
11111000
00000000
00000000
NAME Altar 133

TIL 1eg
00000000
00000000
00000000
00001100
00010000
00010000
00010000
00010000
NAME Altar 134

TIL 1eh
00000000
00000000
00000000
00000000
00000000
00000010
11000100
10100100
NAME Altar 135

TIL 1ei
00000000
00000000
00000000
00000000
00001000
01000010
00100110
00110100
NAME Altar 136

TIL 1ej
00000000
00000000
00000000
00000000
00000000
10000000
00110000
00010000
NAME Altar 137

TIL 1ek
00000000
00000000
00000000
00000000
00000001
00001100
00000100
01000000
NAME Altar 138

TIL 1el
00000000
00000000
00000000
00000000
10000010
01100001
01100000
01000000
NAME Altar 139

TIL 1em
00000000
00000000
00000000
00000000
00000000
00010000
00000101
10000100
NAME Altar 140

TIL 1en
00000000
00000000
00000000
00000000
00000000
00100100
01000010
11000001
NAME Altar 141

TIL 1eo
00000000
00000000
00000000
00000000
00010000
00000000
00000101
00001000
NAME Altar 142

TIL 1ep
00000000
00000000
00000000
00001001
00010000
00000000
10000000
01111000
NAME Altar 143

TIL 1eq
00000000
00000000
00000000
00000000
10000000
00110111
00001110
10001000
NAME Altar 144

TIL 1er
00000000
00000000
00000000
00000000
00000000
11000000
10100000
01111100
NAME Altar 145

TIL 1es
00000000
00110000
00100100
01000011
01000011
00100110
00111000
00000000
NAME Altar 146

TIL 1et
01111101
11001000
10000110
10000011
10000011
10000110
01111100
00010000
NAME Altar 147

TIL 1eu
00110100
01000010
00000011
10000001
11000011
01100110
01110100
00000000
NAME Altar 148

TIL 1ev
00100100
00000100
11001110
00001110
10011100
11111100
00000110
00000011
NAME Altar 149

TIL 1ew
00000011
00010010
11000010
11000010
01110110
00110111
01000000
11000000
NAME Altar 150

TIL 1ex
00100001
00010010
00001100
00001100
00010100
00100110
11000011
00000000
NAME Altar 151

TIL 1ey
11100011
00011001
00010000
00110000
00100000
01110000
11001111
00000010
NAME Altar 152

TIL 1ez
00000000
00011000
11010000
01001000
00010111
11110011
10000000
00000000
NAME Altar 153

TIL 1f0
01001000
00101000
00010000
10001000
10001111
10001001
00110000
00000000
NAME Altar 154

TIL 1f1
01000000
01000010
00101100
01101100
11001111
10001000
10001000
01110000
NAME Altar 155

TIL 1f2
00101000
00101000
01001000
01000101
11000000
11000110
00111111
00011001
NAME Altar 156

TIL 1f3
00100001
00000001
01000001
11000011
01100111
01111110
11000000
00000000
NAME Altar 157

TIL 1f4
00001000
00001000
11111100
01000111
00000001
00000000
00000000
00000000
NAME Altar 158

TIL 1f5
00100110
00100010
10100010
11110100
00001000
00000000
00000000
00000000
NAME Altar 159

TIL 1f6
00000000
00000000
00000000
00000000
00000000
00000100
00011111
00111111
NAME Altar 160

TIL 1f7
00000000
00000000
00000000
00111110
01111111
01111111
11111011
11100011
NAME Altar 161

TIL 1f8
00000000
00000000
00000000
00011111
10111111
11110001
11110000
00100001
NAME Altar 162

TIL 1f9
00000000
00000000
00000000
00010111
11111111
11111100
11001100
11001000
NAME Altar 163

TIL 1fa
00000000
00000000
00000000
11001000
11111110
01111111
00100111
01100111
NAME Altar 164

TIL 1fb
00000000
00000000
00000000
00000000
00000011
00000111
00001100
00111100
NAME Altar 165

TIL 1fc
00110011
01110011
01110011
11111111
11011111
10000111
11000110
11111110
NAME Altar 166

TIL 1fd
11100011
00100011
01110011
00011111
11111100
11110000
01000000
00000000
NAME Altar 167

TIL 1fe
10111011
00111111
11111111
11110000
11100000
00000000
00000000
00000000
NAME Altar 168

TIL 1ff
11001110
11111111
01111111
00010000
00000000
00000000
00000000
00000000
NAME Altar 169

TIL 1fg
10101100
11111100
11011100
00001111
00000111
00000001
00000000
00000000
NAME Altar 170

TIL 1fh
01111110
01111111
01111111
11110000
11110000
11111001
00111111
00001111
NAME Altar 171

TIL 1fi
00000000
10000000
11000000
11100000
11111000
11111100
10001100
10001110
NAME Altar 172

TIL 1fj
00000000
00000000
00000000
00000000
00000000
00000111
00001110
00001110
NAME Altar 173

TIL 1fk
01111100
01101100
11100111
11100111
01100111
11111111
11101011
01100011
NAME Altar 174

TIL 1fl
01111100
11100000
11100000
11000000
00000000
00000000
00000000
00000000
NAME Altar 175

TIL 1fm
10001110
11111111
11111111
11101110
01111100
00111000
00011110
00000111
NAME Altar 176

TIL 1fn
00000000
11000000
11000000
11100000
01111000
01111100
11101100
10001100
NAME Altar 177

TIL 1fo
00001100
00001111
00011111
00011100
00111100
00111100
01111111
00110101
NAME Altar 178

TIL 1fp
01101111
11111110
11110000
01100000
01110000
01100000
11100000
11000000
NAME Altar 179

TIL 1fq
11000000
11000000
11100000
11100000
11100000
11100000
11100000
11100000
NAME Altar 180

TIL 1fr
10000000
10000000
11000000
11000000
10000000
10000000
11000000
11000000
NAME Altar 181

TIL 1fs
10011100
10011100
11111110
11000110
11000111
11011111
11110001
01100001
NAME Altar 182

TIL 1ft
00111111
01111111
01100111
11100001
01100011
01111111
11111110
11000110
NAME Altar 183

TIL 1fu
10000000
10000000
00000000
10000000
10000000
10000000
00000000
00000000
NAME Altar 184

TIL 1fv
00011111
00011111
00111111
00110011
00111011
00111111
00011111
00000011
NAME Altar 185

TIL 1fw
01100001
00111111
00111111
00111001
00110000
00110001
00111011
00011111
NAME Altar 186

TIL 1fx
10000000
10000000
10000000
11000000
11000000
11000000
11000000
11000000
NAME Altar 187

TIL 1fy
11000110
11111111
01111111
11110011
11100001
11100011
10111111
10011111
NAME Altar 188

TIL 1fz
00000000
00000000
10000000
10000000
10000000
10000000
00000000
10000000
NAME Altar 189

TIL 1g0
00011111
00011100
00011100
00011100
00011111
00001111
00001010
00001010
NAME Altar 190

TIL 1g1
11111111
11111111
11111100
11111111
11100111
01100010
01000111
01001111
NAME Altar 191

TIL 1g2
11111111
11111111
11111110
11111110
11001111
00001111
00001100
00000000
NAME Altar 192

TIL 1g3
11111111
11111111
00111111
00111011
01111001
11111000
00011000
00000000
NAME Altar 193

TIL 1g4
11111111
10111111
00111111
11111011
11111011
00111001
00111001
00111000
NAME Altar 194

TIL 1g5
11111000
10111000
00011000
10111000
11111000
11010000
01001000
01001000
NAME Altar 195

TIL 1g6
00011100
00011000
00011100
00111111
00110001
01100001
00110001
00111111
NAME Altar 196

TIL 1g7
11000000
11100000
11000000
11000000
11000000
11110000
11110000
10110000
NAME Altar 197

TIL 1g8
00000001
00000001
00000000
00000001
00000111
00000111
00000111
00000111
NAME Altar 198

TIL 1g9
10111010
11100000
10110000
11110001
11111111
00010111
00011111
00011111
NAME Altar 199

TIL 1ga
11000000
11000000
00000000
00000000
00000001
00000011
00000011
00000111
NAME Altar 200

TIL 1gb
11001111
11001111
11111111
11111111
11100110
11100110
11111110
11111111
NAME Altar 201

TIL 1gc
00000000
00000000
11000000
00000000
00000000
00000000
00000000
00000000
NAME Altar 202

TIL 1gd
00000000
00000000
00000011
00000011
00000011
00000001
10000001
10000000
NAME Altar 203

TIL 1ge
00111011
00111011
11111111
11110111
11100011
11100011
11111111
11111111
NAME Altar 204

TIL 1gf
01111000
01111000
11111000
11100000
11111100
11111111
11111111
11111111
NAME Altar 205

TIL 1gg
00011111
00001111
00011111
00011000
00011000
00111000
11111111
01111111
NAME Altar 206

TIL 1gh
01110000
11110000
11100000
11000000
11100000
11100000
11000000
10000000
NAME Altar 207

TIL 1gi
00000111
00000011
00000111
00000111
00000011
00000011
00000000
00000000
NAME Altar 208

TIL 1gj
11111111
11111110
00011111
00011110
11111110
00111110
00001110
00000000
NAME Altar 209

TIL 1gk
00000111
00000110
01011111
01110111
01111111
11111110
00000000
00000000
NAME Altar 210

TIL 1gl
01111100
01111100
11111111
11101111
11111111
01111111
01111111
00001111
NAME Altar 211

TIL 1gm
11111000
11000000
11000000
11101111
11101111
11110000
11111000
11111100
NAME Altar 212

TIL 1gn
00000000
00000011
00000111
11100011
11100011
01100011
00000011
00000000
NAME Altar 213

TIL 1go
10000000
11000000
11000000
11000000
11100111
11111100
11000000
00000000
NAME Altar 214

TIL 1gp
00111111
00000001
00000001
00001011
11101001
11001000
01011111
00011111
NAME Altar 215

TIL 1gq
11111111
10111100
10111100
11111111
11111111
11111110
11111110
11111000
NAME Altar 216

TIL 1gr
11000000
11000000
11110000
11001001
11111111
00111100
00000000
00000000
NAME Altar 217

TIL 1gs
00010011
00111111
01111110
11111111
11111111
01111010
01111000
00000000
NAME Altar 218

TIL 1gt
11100000
11110000
01110000
00110000
11110000
11110000
01100000
00000000
NAME Altar 219

TIL 1gu
00111100
00011100
00111100
11111100
11111100
11110000
00000000
00000000
NAME Altar 220

TIL 1gv
00010110
00011100
00011110
00010111
00011111
00001111
00000000
00000000
NAME Altar 221

TIL 1gw
00111100
00111100
00111000
11111000
11111000
11111000
00000000
00000000
NAME Altar 222

TIL 1gx
00000000
00000000
00000000
00001111
00011111
00011000
00111001
00011111
NAME Altar 223

TIL 1gy
00000000
00000000
00000000
00000000
10000000
10000010
11000110
11100100
NAME Altar 224

TIL 1gz
00000000
00000000
00000000
00000000
00001000
01111111
01100110
00110110
NAME Altar 225

TIL 1h0
00000000
00000000
00000000
00000000
10000000
11000000
00110000
00111100
NAME Altar 226

TIL 1h1
00000000
00000000
00000000
00000000
00000011
00101110
01111111
01100011
NAME Altar 227

TIL 1h2
00000000
00000000
00000000
00000000
10011110
11110001
01110001
11110001
NAME Altar 228

TIL 1h3
00000000
00000000
00000000
00000000
00000000
00000000
11000001
10100111
NAME Altar 229

TIL 1h4
00000000
00000000
00000000
00000000
00000000
00011000
01101101
11001111
NAME Altar 230

TIL 1h5
00000000
00000000
00000000
00000000
00000000
00111100
01100110
11000011
NAME Altar 231

TIL 1h6
00000000
00000000
00000000
00000000
00111000
01001001
01001111
01111100
NAME Altar 232

TIL 1h7
00000000
00000000
00000000
00001111
00011001
00010000
10010000
01111111
NAME Altar 233

TIL 1h8
00000000
00000000
00000000
00000000
10000000
11110111
11111111
10011100
NAME Altar 234

TIL 1h9
00000000
00000000
00000000
00000000
00000000
11000000
11100000
01111100
NAME Altar 235

TIL 1ha
00000000
00111100
01111110
01100111
01100111
01111110
00111100
00000000
NAME Altar 236

TIL 1hb
01111111
11111110
11000110
10000111
11000111
11111110
01111100
00010000
NAME Altar 237

TIL 1hc
01110110
11101110
11000111
11000111
11000111
11111110
01111100
00000000
NAME Altar 238

TIL 1hd
00111110
01111111
11001111
10001111
10111110
11111110
00000111
00000011
NAME Altar 239

TIL 1he
00111111
01110111
11100110
11101110
01111111
01110111
11100001
11000000
NAME Altar 240

TIL 1hf
11100011
00110011
00011110
00011110
00110110
11100111
11100011
00000000
NAME Altar 241

TIL 1hg
11111111
01111111
00111000
00110000
00111000
11111111
11101111
00000010
NAME Altar 242

TIL 1hh
10111100
10111000
11111100
11111111
11111111
11110011
10000000
00000000
NAME Altar 243

TIL 1hi
01001100
01111100
01111100
11111111
10011111
11111001
10110000
00000000
NAME Altar 244

TIL 1hj
11000011
01101110
01111100
11111111
11011111
10001100
11011000
01110000
NAME Altar 245

TIL 1hk
11111100
01111100
01101111
11000111
11100011
11111111
00111111
00011011
NAME Altar 246

TIL 1hl
01111111
01100011
11100011
11100011
01111111
11111110
11000000
00000000
NAME Altar 247

TIL 1hm
10011100
11111100
11111111
01100111
00000001
00000000
00000000
00000000
NAME Altar 248

TIL 1hn
01110110
01100110
11100110
11111100
00001000
00000000
00000000
00000000
NAME Altar 249

TIL 1ho
00000000
00000000
00000000
00111110
01111111
01111111
11111111
11111111
NAME Altar 250

TIL 1hp
00000000
00000000
00000000
00011111
10111111
11111111
11111111
11111111
NAME Altar 251

TIL 1hq
00000000
00000000
00000000
00010111
11111111
11111111
11111111
11111111
NAME Altar 252

TIL 1hr
00000000
00000000
00000000
11001000
11111110
11111111
11111111
11111111
NAME Altar 253

TIL 1hs
00000000
00000000
00000000
00000000
00000011
00000111
00001111
00111111
NAME Altar 254

TIL 1ht
00111111
01111111
01111111
11111111
11111111
11111111
11111110
11111110
NAME Altar 255

TIL 1hu
11111111
11111111
11111111
11111111
11111100
11110000
01000000
00000000
NAME Altar 256

TIL 1hv
11111111
11111111
11111111
11110000
11100000
00000000
00000000
00000000
NAME Altar 257

TIL 1hw
11111111
11111111
01111111
00010000
00000000
00000000
00000000
00000000
NAME Altar 258

TIL 1hx
11111111
11111111
11011111
00001111
00000111
00000001
00000000
00000000
NAME Altar 259

TIL 1hy
11111110
11111111
11111111
11111111
11111111
11111111
00111111
00001111
NAME Altar 260

TIL 1hz
00000000
10000000
11000000
11100000
11111000
11111100
11111100
11111110
NAME Altar 261

TIL 1i0
00000000
00000000
00000000
00000000
00000000
00000111
00001111
00001111
NAME Altar 262

TIL 1i1
01111111
01111111
11111111
11111111
01111111
11111111
11111111
11111111
NAME Altar 263

TIL 1i2
11111100
11100000
11100000
11000000
00000000
00000000
00000000
00000000
NAME Altar 264

TIL 1i3
11111110
11111111
11111111
11111111
01111111
00111111
00011111
00000111
NAME Altar 265

TIL 1i4
00000000
11000000
11000000
11100000
11111000
11111100
11111100
11111100
NAME Altar 266

TIL 1i5
00001111
00001111
00011111
00011111
00111111
00111111
01111111
00111111
NAME Altar 267

TIL 1i6
11111111
11111110
11110000
11100000
11110000
11100000
11100000
11000000
NAME Altar 268

TIL 1i7
00000000
00000000
00000000
00000000
00000000
00000000
11110000
11111000
NAME Altar 269

TIL 1i8
00000011
00000011
00000111
00000111
00000111
00000111
00000111
00000011
NAME Altar 270

TIL 1i9
11111100
11111100
11111110
11111110
11111111
11111111
11111111
01111111
NAME Altar 271

TIL 1ia
00111111
01111111
01111111
11111111
01111111
11111111
11111110
11111110
NAME Altar 272

TIL 1ib
11111000
11111100
11111100
11001100
11101100
11111100
11111000
11100000
NAME Altar 273

TIL 1ic
01111111
00111111
00111111
00111111
00111111
00111111
00111111
00011111
NAME Altar 274

TIL 1id
11111110
11111111
01111111
11111111
11111111
11111111
11111111
11111111
NAME Altar 275

TIL 1ie
00011111
00011111
00011100
00011100
00011111
00001111
00011011
00011010
NAME Altar 276

TIL 1if
11111111
11111111
11111110
11111111
11101111
11100010
01000111
01001111
NAME Altar 277

TIL 1ig
11111111
11111111
11111110
11111110
11011111
00011111
00001111
00000110
NAME Altar 278

TIL 1ih
11111111
11111111
00111111
00111111
11111001
11111000
01111000
01100000
NAME Altar 279

TIL 1ii
11111111
11111111
10111111
11111011
11111011
01111101
00111011
00111001
NAME Altar 280

TIL 1ij
11111000
10111000
00011000
10111000
11111000
11111000
01101000
01001000
NAME Altar 281

TIL 1ik
00011111
00011111
00011111
00111111
00111111
01111111
00111111
00111111
NAME Altar 282

TIL 1il
11000000
11100000
11000000
11000000
11000000
11110000
11110000
11110000
NAME Altar 283

TIL 1im
11000000
11000000
10000000
00000000
00000011
00000011
00000011
00000111
NAME Altar 284

TIL 1in
00011011
00011011
00011111
11111111
11111111
11111111
11111111
11111111
NAME Altar 285

TIL 1io
11001111
11001111
11111111
11111111
11100110
11111110
11111111
11111111
NAME Altar 286

TIL 1ip
00110010
00111011
11101111
11000000
00000000
00000000
00000000
00000001
NAME Altar 287

TIL 1iq
01001100
11101110
11111011
00000011
00000011
10000001
10000001
10000000
NAME Altar 288

TIL 1ir
00111011
00111111
11111111
11111111
11110111
11110111
11111111
11111111
NAME Altar 289

TIL 1is
01111100
01111100
11111100
11100000
11111100
11111111
11111111
11111111
NAME Altar 290

TIL 1it
00011111
00001111
00011111
00011111
00011111
00111111
11111111
01111111
NAME Altar 291

TIL 1iu
11110000
11110000
11100000
11000000
11100000
11100000
11000000
10000000
NAME Altar 292

TIL 1iv
00000111
00000011
00000111
00000111
00000011
00000011
00000001
00000000
NAME Altar 293

TIL 1iw
11111111
11111111
11111111
11111111
11111111
11111111
00111110
00000000
NAME Altar 294

TIL 1ix
00000111
00000111
11011111
11111111
11111111
11111111
10001110
00000000
NAME Altar 295

TIL 1iy
01111101
01111100
11111111
11101111
11111111
11111111
01111111
00001111
NAME Altar 296

TIL 1iz
11111100
11000000
11000000
11111111
11111111
11110000
11111100
11111100
NAME Altar 297

TIL 1j0
00000001
00001011
00011111
11111111
11111111
01100111
00000011
00000000
NAME Altar 298

TIL 1j1
11000000
11000000
11000000
11000100
11101111
11111111
11011000
00000000
NAME Altar 299

TIL 1j2
01111111
00000001
00000001
10101111
11111111
11111111
01111111
00011111
NAME Altar 300

TIL 1j3
11111111
10111111
10111111
11111111
11111111
11111111
11111110
11111100
NAME Altar 301

TIL 1j4
11000000
11000000
11111000
11111011
11111111
11111111
00111000
00000000
NAME Altar 302

TIL 1j5
01111111
01111111
01111111
11111111
11111111
11111111
01111011
00000000
NAME Altar 303

TIL 1j6
11100000
11110000
11110000
11110000
11110000
11110000
01100000
00000000
NAME Altar 304

TIL 1j7
00111100
00011100
00111100
11111100
11111100
11111000
00000000
00000000
NAME Altar 305

TIL 1j8
00011110
00011100
00011110
00011111
00011111
00001111
00000000
00000000
NAME Altar 306

TIL 1j9
00111100
00111100
00111100
11111100
11111000
11111000
00000000
00000000
NAME Altar 307

TIL 1ja
00000000
00000000
00000000
00001111
00011111
00011111
00111111
00011111
NAME Altar 308

TIL 1jb
00000000
00000000
00000000
00000000
10000011
10000011
11000111
11101111
NAME Altar 309

TIL 1jc
00000000
00000000
00000000
00000000
11001100
11111111
11111111
11111111
NAME Altar 310

TIL 1jd
00000000
00000000
00000000
00000000
10000000
11100000
11110000
11111100
NAME Altar 311

TIL 1je
00000000
00000000
00000000
00000001
00000011
00101111
01111111
01111111
NAME Altar 312

TIL 1jf
00000000
00000000
00000000
00000100
10011110
11111111
11111111
11111111
NAME Altar 313

TIL 1jg
00000000
00000000
00000000
00000000
00000000
10000000
11100101
11110111
NAME Altar 314

TIL 1jh
00000000
00000000
00000000
00000000
00000000
00111000
11111101
11111111
NAME Altar 315

TIL 1ji
00000000
00000000
00000000
00000000
00000000
00111100
01111110
11111111
NAME Altar 316

TIL 1jj
00000000
00000000
00000000
00000000
00111000
01111101
01111111
11111111
NAME Altar 317

TIL 1jk
00000000
00000000
00000000
00001111
00011111
00011111
10111111
11111111
NAME Altar 318

TIL 1jl
00000000
00000000
00000000
00000000
10000000
11110111
11111111
11111111
NAME Altar 319

TIL 1jm
00000000
00000000
00000000
00000000
00000000
11000000
11100000
11111100
NAME Altar 320

TIL 1jn
00000000
00111100
01111110
01111111
01111111
01111110
00111100
00000000
NAME Altar 321

TIL 1jo
01111111
11111111
11111111
11111111
11111111
11111110
01111100
00010000
NAME Altar 322

TIL 1jp
11111111
11111111
11111111
11111111
11111111
11111110
01111100
00000000
NAME Altar 323

TIL 1jq
11111111
11111111
11111111
11111111
11111111
11111111
00000111
00000011
NAME Altar 324

TIL 1jr
11111111
11111111
11111111
11111111
11111111
11110111
11100001
11000000
NAME Altar 325

TIL 1js
11111111
11111111
11111111
11111111
11110111
11100111
11100011
00000000
NAME Altar 326

TIL 1jt
11111111
11111111
11111111
11111111
11111111
11111111
11101111
00000010
NAME Altar 327

TIL 1ju
11111111
11111111
11111111
11111111
11111111
11110011
10000000
00000000
NAME Altar 328

TIL 1jv
11111111
11111111
11111111
11111111
11111111
11111001
10110000
00000000
NAME Altar 329

TIL 1jw
11111111
11111111
11111111
11111111
11111111
11111100
11111000
01110000
NAME Altar 330

TIL 1jx
11111111
11111111
11111111
11111111
11111111
11111111
00111111
00011011
NAME Altar 331

TIL 1jy
11111111
11111111
11111111
11111111
11111111
11111110
11000000
00000000
NAME Altar 332

TIL 1jz
11111111
11111111
11111111
01100111
00000001
00000000
00000000
00000000
NAME Altar 333

TIL 1k0
11111110
11111110
11111110
11111110
00001000
00000000
00000000
00000000
NAME Altar 334

TIL 1k1
11111111
11111111
11111111
11111111
11111110
11110000
01000000
00000000
NAME Altar 335

TIL 1k2
11111111
11111111
01111111
00110000
00000000
00000000
00000000
00000000
NAME Altar 336

TIL 1k3
11111111
11111111
11011111
00001111
00000111
00000101
00000000
00000000
NAME Altar 337

TIL 1k4
00000001
00000001
00000000
00000000
00000000
00000000
00000000
10000000
NAME Altar 338

TIL 1k5
00001111
00001111
00011111
00011111
00111111
00111111
01111111
01111111
NAME Altar 339

TIL 1k6
00011111
00011111
00111111
00111011
00111111
00111111
00011111
00000011
NAME Altar 340

TIL 1k7
11111000
11111100
11111100
11001100
11111100
11111100
11111000
11100000
NAME Altar 341

TIL 1k8
00011111
00011111
00011100
00011110
00011111
00011111
00011011
00011011
NAME Altar 342

TIL 1k9
11111111
11111111
11111111
11111111
11101111
11100110
01001111
01001111
NAME Altar 343

TIL 1ka
11111111
11111111
11111110
11111110
11011111
00011111
00011111
00011111
NAME Altar 344

TIL 1kb
11111111
11111111
01111111
00111111
11111011
11111000
11111000
11111000
NAME Altar 345

TIL 1kc
11111111
11111111
11111111
11111111
11111011
01111111
00111111
01111111
NAME Altar 346

TIL 1kd
11111000
11111000
00011000
10111000
11111000
11111000
01111000
01101000
NAME Altar 347

TIL 1ke
11000000
11100000
11000000
11000000
11100000
11110000
11110000
11110000
NAME Altar 348

TIL 1kf
11000000
11000000
11000000
00000001
00000011
00000011
00000111
00000111
NAME Altar 349

TIL 1kg
00011111
00011111
01111111
11111111
11111111
11111111
11111111
11111111
NAME Altar 350

TIL 1kh
11001111
11001111
11111111
11111111
11100111
11111111
11111111
11111111
NAME Altar 351

TIL 1ki
11111100
11111110
11111111
10000011
11010011
11010011
10010001
10000000
NAME Altar 352

TIL 1kj
00111111
00111111
11111111
11111111
11110111
11110111
11111111
11111111
NAME Altar 353

TIL 1kk
01111100
01111100
11111111
11100000
11111100
11111111
11111111
11111111
NAME Altar 354

TIL 1kl
00000000
00000000
00000000
01000000
00100100
00100100
11000000
10000000
NAME Altar 355

TIL 1km
00011111
00001111
00011111
00011111
00011111
00111111
11111111
11111111
NAME Altar 356

TIL 1kn
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00000000
NAME Altar 357

TIL 1ko
00000111
00001111
11011111
11111111
11111111
11111111
11111111
00000000
NAME Altar 358

TIL 1kp
11111111
01111100
11111111
11111111
11111111
11111111
11111111
00011111
NAME Altar 359

TIL 1kq
11111111
11000010
11001000
11111111
11111111
11111000
11111111
11111100
NAME Altar 360

TIL 1kr
00011011
01011111
01011111
11111111
11111111
01111111
11111111
00000000
NAME Altar 361

TIL 1ks
11000000
11000000
11000000
11000111
11111111
11111111
11111111
00000000
NAME Altar 362

TIL 1kt
01111111
00000001
00000011
10111111
11111111
11111111
11111111
00011111
NAME Altar 363

TIL 1ku
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111100
NAME Altar 364

TIL 1kv
11101000
11110000
11111001
11111111
11111111
11111111
11111111
00000000
NAME Altar 365

TIL 1kw
11100000
11110000
11110000
11110000
11110000
11110000
11100000
00000000
NAME Altar 366

TIL 1kx
00011110
00011110
00011111
00011111
00011111
00001111
00000000
00000000
NAME Altar 367

TIL 1ky
00111100
00111100
01111100
11111100
11111100
11111000
00000000
00000000
NAME Altar 368

TIL 1kz
00000000
00000000
00000000
00001111
00011111
00111111
00111111
00011111
NAME Altar 369

TIL 1l0
00000000
00000000
00000000
00000000
10000011
11000111
11000111
11111111
NAME Altar 370

TIL 1l1
00000000
00000000
00000000
00000000
11111110
11111111
11111111
11111111
NAME Altar 371

TIL 1l2
00000000
00000000
00000000
00000001
00000111
00111111
01111111
11111111
NAME Altar 372

TIL 1l3
00000000
00000000
00000000
00011100
10011111
11111111
11111111
11111111
NAME Altar 373

TIL 1l4
00000000
00000000
00000000
00000000
00000000
10000000
11100111
11111111
NAME Altar 374

TIL 1l5
00000000
00000000
00000000
00000000
00000000
01111000
11111111
11111111
NAME Altar 375

TIL 1l6
00000000
00000000
00000000
00000000
00011100
00111100
11111111
11111111
NAME Altar 376

TIL 1l7
00000000
00000000
00000000
00000000
01111000
01111101
01111111
11111111
NAME Altar 377

TIL 1l8
00000000
00000000
00000100
00001111
00111111
00111111
11111111
11111111
NAME Altar 378

TIL 1l9
00000000
00000000
00000000
00000000
11000000
11110111
11111111
11111111
NAME Altar 379

TIL 1la
11111111
11111111
11111111
11111111
11111111
11111111
11101111
00000110
NAME Altar 380

TIL 1lb
11111111
11111111
11111111
11111111
11111111
11111001
11110000
00000000
NAME Altar 381

TIL 1lc
11111110
11111110
11111110
11111110
00011000
00000000
00000000
00000000
NAME Altar 382

TIL 1ld
00000000
00000000
00000000
00111110
01111111
01111111
11111111
11110011
NAME Altar 383

TIL 1le
00000000
00000000
00000000
00011111
10111111
11111111
11110001
00111001
NAME Altar 384

TIL 1lf
00000000
00000000
00000000
00010111
11111111
11111110
11001100
11001110
NAME Altar 385

TIL 1lg
00000000
00000000
00000000
11001000
11111110
11111111
01110111
01111111
NAME Altar 386

TIL 1lh
00000000
00000000
00000000
00000000
00000011
00000111
00001111
00111100
NAME Altar 387

TIL 1li
00111011
01110011
01110111
11111111
11011111
11000111
11101110
11111110
NAME Altar 388

TIL 1lj
11100011
11110011
01111111
10111111
11111100
11110000
01000000
00000000
NAME Altar 389

TIL 1lk
10111111
00111111
11111111
11110000
11100000
00000000
00000000
00000000
NAME Altar 390

TIL 1ll
11001111
11111111
01111111
00010000
00000000
00000000
00000000
00000000
NAME Altar 391

TIL 1lm
11111110
11111100
11011100
00001111
00000111
00000001
00000000
00000000
NAME Altar 392

TIL 1ln
01111110
01111111
01111111
11111001
11111000
11111111
00111111
00001111
NAME Altar 393

TIL 1lo
00000000
10000000
11000000
11100000
11111000
11111100
10011100
10001110
NAME Altar 394

TIL 1lp
01111100
01111111
11101111
11100111
01111111
11111111
11111111
01100111
NAME Altar 395

TIL 1lq
11011110
11111111
11111111
11111111
01111100
00111100
00011111
00000111
NAME Altar 396

TIL 1lr
00000000
11000000
11000000
11100000
01111000
01111100
11111100
11001100
NAME Altar 397

TIL 1ls
00001111
00001111
00011111
00011100
00111100
00111100
01111111
00110111
NAME Altar 398

TIL 1lt
01111111
11111110
11110000
11100000
01110000
01100000
11100000
11000000
NAME Altar 399

TIL 1lu
10011100
11111100
11111110
11001110
11001111
11011111
11111011
01110001
NAME Altar 400

TIL 1lv
00111111
01111111
01110111
11100011
01110111
01111111
11111110
11000110
NAME Altar 401

TIL 1lw
11111000
11111100
11111100
11001100
11101100
01111100
11111000
11100000
NAME Altar 402

TIL 1lx
01110011
00111111
00111111
00111111
00111001
00111001
00111111
00011111
NAME Altar 403

TIL 1ly
11000110
11111111
01111111
11110011
11100011
11111111
11111111
10011111
NAME Altar 404

TIL 1lz
00011111
00011110
00011100
00011100
00011111
00001111
00011010
00001010
NAME Altar 405

TIL 1m0
11111111
11111111
11111110
11111110
11011111
00011111
00001110
00000010
NAME Altar 406

TIL 1m1
11111111
11111111
00111111
00111111
01111001
11111000
01111000
01100000
NAME Altar 407

TIL 1m2
11111111
11111111
00111111
11111011
11111011
00111001
00111011
00111001
NAME Altar 408

TIL 1m3
11111000
10111000
00011000
10111000
11111000
11110000
01001000
01001000
NAME Altar 409

TIL 1m4
00011111
00011000
00011111
00111111
00111011
01110001
00110001
00111111
NAME Altar 410

TIL 1m5
11111111
11111001
11110000
11111011
11111111
00111111
00111111
00111111
NAME Altar 411

TIL 1m6
00110000
00110001
11101111
11000000
00000000
00000000
00000000
00000000
NAME Altar 412

TIL 1m7
00000100
11001100
11111011
00000011
00000011
00000001
10000001
10000000
NAME Altar 413

TIL 1m8
00111011
00111011
11111111
11110111
11110111
11100111
11111111
11111111
NAME Altar 414

TIL 1m9
01111100
01111100
11111000
11100000
11111100
11111111
11111111
11111111
NAME Altar 415

TIL 1ma
00011111
00001111
00011111
00011100
00011100
00111100
11111111
01111111
NAME Altar 416

TIL 1mb
11111111
11111111
01011111
00011110
11111110
10111111
00011110
00000000
NAME Altar 417

TIL 1mc
00000111
00000110
01011111
11110111
01111111
11111110
00000100
00000000
NAME Altar 418

TIL 1md
11111100
11000000
11000000
11111111
11111111
11110000
11111000
11111100
NAME Altar 419

TIL 1me
00000001
00000011
00000111
11100111
11100011
01100011
00000011
00000000
NAME Altar 420

TIL 1mf
11000000
11000000
11000000
11000000
11100111
11111100
11001000
00000000
NAME Altar 421

TIL 1mg
00111111
00000001
00000001
00001011
11111111
11101101
01111111
00011111
NAME Altar 422

TIL 1mh
11111111
10111100
10111100
11111111
11111111
11111111
11111110
11111100
NAME Altar 423

TIL 1mi
11000000
11000000
11111000
11101001
11111111
01111100
00100000
00000000
NAME Altar 424

TIL 1mj
00111011
00111111
01111110
11111111
11111111
01111111
01111000
00000000
NAME Altar 425

TIL 1mk
00111100
00111100
00111100
11111000
11111000
11111000
00000000
00000000
NAME Altar 426

TIL 1ml
00000000
00000000
00000000
00001111
00011111
00011001
00111001
00011111
NAME Altar 427

TIL 1mm
00000000
00000000
00000000
00000000
10000010
10000011
11000110
11101110
NAME Altar 428

TIL 1mn
00000000
00000000
00000000
00000000
11001100
11111111
01110111
00111110
NAME Altar 429

TIL 1mo
00000000
00000000
00000000
00000000
10000000
11000000
11110000
00111100
NAME Altar 430

TIL 1mp
00000000
00000000
00000000
00000000
00000011
00101111
01111111
01100011
NAME Altar 431

TIL 1mq
00000000
00000000
00000000
00000100
10011110
11111111
01110011
11110011
NAME Altar 432

TIL 1mr
00000000
00000000
00000000
00000000
00000000
00000000
11100101
11110111
NAME Altar 433

TIL 1ms
00000000
00000000
00000000
00000000
00000000
00011000
11111101
11101111
NAME Altar 434

TIL 1mt
00000000
00000000
00000000
00000000
00000000
00111100
01111110
11100111
NAME Altar 435

TIL 1mu
00000000
00000000
00000000
00000000
00111000
01101001
01101111
11111111
NAME Altar 436

TIL 1mv
00000000
00000000
00000000
00001111
00011111
00011001
10011001
11111111
NAME Altar 437

TIL 1mw
00000000
00000000
00000000
00000000
10000000
11110111
11111111
11011110
NAME Altar 438

TIL 1mx
01111111
11111110
11101111
11000111
11001111
11111110
01111100
00010000
NAME Altar 439

TIL 1my
01110110
11111110
11100111
11000111
11101111
11111110
01111100
00000000
NAME Altar 440

TIL 1mz
01111110
11111111
11101111
11011111
11111110
11111110
00000111
00000011
NAME Altar 441

TIL 1n0
00111111
11110111
11100111
11111111
11111111
01110111
11100001
11000000
NAME Altar 442

TIL 1n1
11100011
11110111
00111111
00111110
11110111
11100111
11100011
00000000
NAME Altar 443

TIL 1n2
11111111
11111111
01111101
01111000
01111001
11111111
11101111
00000010
NAME Altar 444

TIL 1n3
10111110
11111100
11111100
11111111
11111111
11110011
10000000
00000000
NAME Altar 445

TIL 1n4
11101110
01111100
11111100
11111111
11011111
11111001
10110000
00000000
NAME Altar 446

TIL 1n5
11100111
11111111
01111110
11111111
11111111
11001100
11111000
01110000
NAME Altar 447

TIL 1n6
11111100
11111100
11111111
11100111
11100111
11111111
00111111
00011011
NAME Altar 448

TIL 1n7
01111111
01110011
11100011
11110111
11111111
11111110
11000000
00000000
NAME Altar 449

TIL 1n8
01111110
01100110
11111110
11111100
00001000
00000000
00000000
00000000
NAME Altar 450

TIL 1n9
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
WAL true

TIL 1na
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL 1nb
11111111
11111111
11111111
11111111
11111111
01111111
01100110
01000010

SPR A
00011000
00011000
00011000
00111100
01111110
10111101
00100100
00100100
POS 0 1,14

SPR a
00000000
00000000
01010001
01110001
01110010
01111100
00111100
00100100
DLG SPR_0
POS 0 14,14

SPR b
00000000
00010000
00010000
00111000
00010000
00010000
00000000
00000000
>
00000000
00000000
00010000
01111100
00010000
00000000
00000000
00000000

ITM 0
00000000
00000000
00000000
00111100
01100100
00100100
00011000
00000000
NAME tea
DLG ITM_0

ITM 1
00000000
00001000
00000100
00001000
00011100
00011100
00011100
00011100
>
00000000
00001000
00010000
00001000
00011100
00011100
00011100
00011100

ITM 2
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

ITM 3
00010000
01010100
00111000
11111110
00111000
01010100
00010000
00010000
>
00010000
00010000
00111000
11111110
00111000
00010000
00010000
00010000

DLG SPR_0
"""
Hola! I am your {wvy}Alebrijes{wvy}, your spirit animal.

I am here to guide you to your Altar. You need to pick items to place on your Altar to finish the tradition. Good Luck!
"""

DLG ITM_0
You found a nice warm cup of tea

VAR a
42


</script>

<style>
html {
	margin:0px;
	padding:0px;
}

body {
	margin:0px;
	padding:0px;
	overflow:hidden;
	background:#ffffff;
}

#game {
	background:black;
	width:100vw;
	max-width:100vh;
	margin:auto;
	display:block;
}
</style>

<!-- SCRIPTS -->
<script>
function startExportedGame() {
	attachCanvas( document.getElementById("game") );
	load_game( document.getElementById("exportedGameData").text.slice(1) );
}
</script>

<script>
//hex-to-rgb method borrowed from stack overflow
function hexToRgb(hex) {
	// Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
	var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
	hex = hex.replace(shorthandRegex, function(m, r, g, b) {
		return r + r + g + g + b + b;
	});

	var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
	return result ? {
		r: parseInt(result[1], 16),
		g: parseInt(result[2], 16),
		b: parseInt(result[3], 16)
	} : null;
}
function componentToHex(c) {
    var hex = c.toString(16);
    return hex.length == 1 ? "0" + hex : hex;
}
function rgbToHex(r, g, b) {
    return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
}

function hslToHex(h,s,l) {
    var rgbArr = hslToRgb(h,s,l);
    return rgbToHex( Math.floor(rgbArr[0]), Math.floor(rgbArr[1]), Math.floor(rgbArr[2]) );
}

function hexToHsl(hex) {
    var rgb = hexToRgb(hex);
    return rgbToHsl(rgb.r, rgb.g, rgb.b);
}

// really just a vector distance
function colorDistance(a1,b1,c1,a2,b2,c2) {
    return Math.sqrt( Math.pow(a1 - a2, 2) + Math.pow(b1 - b2, 2) + Math.pow(c1 - c2, 2) );
}

function hexColorDistance(hex1,hex2) {
    var color1 = hexToRgb(hex1);
    var color2 = hexToRgb(hex2);
    return rgbColorDistance(color1.r, color1.g, color1.b, color2.r, color2.g, color2.b);
}


// source : http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
/* accepts parameters
 * h  Object = {h:x, s:y, v:z}
 * OR 
 * h, s, v
*/
function HSVtoRGB(h, s, v) {
    var r, g, b, i, f, p, q, t;
    if (arguments.length === 1) {
        s = h.s, v = h.v, h = h.h;
    }
    i = Math.floor(h * 6);
    f = h * 6 - i;
    p = v * (1 - s);
    q = v * (1 - f * s);
    t = v * (1 - (1 - f) * s);
    switch (i % 6) {
        case 0: r = v, g = t, b = p; break;
        case 1: r = q, g = v, b = p; break;
        case 2: r = p, g = v, b = t; break;
        case 3: r = p, g = q, b = v; break;
        case 4: r = t, g = p, b = v; break;
        case 5: r = v, g = p, b = q; break;
    }
    return {
        r: Math.round(r * 255),
        g: Math.round(g * 255),
        b: Math.round(b * 255)
    };
}

/* accepts parameters
 * r  Object = {r:x, g:y, b:z}
 * OR 
 * r, g, b
*/
function RGBtoHSV(r, g, b) {
    if (arguments.length === 1) {
        g = r.g, b = r.b, r = r.r;
    }
    var max = Math.max(r, g, b), min = Math.min(r, g, b),
        d = max - min,
        h,
        s = (max === 0 ? 0 : d / max),
        v = max / 255;

    switch (max) {
        case min: h = 0; break;
        case r: h = (g - b) + d * (g < b ? 6: 0); h /= 6 * d; break;
        case g: h = (b - r) + d * 2; h /= 6 * d; break;
        case b: h = (r - g) + d * 4; h /= 6 * d; break;
    }

    return {
        h: h,
        s: s,
        v: v
    };
}

// source : https://gist.github.com/mjackson/5311256
/**
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes h, s, and l are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 255].
 *
 * @param   Number  h       The hue
 * @param   Number  s       The saturation
 * @param   Number  l       The lightness
 * @return  Array           The RGB representation
 */
function hslToRgb(h, s, l) {
  var r, g, b;

  if (s == 0) {
    r = g = b = l; // achromatic
  } else {
    function hue2rgb(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    }

    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;

    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }

  return [ r * 255, g * 255, b * 255 ];
}

/**
 * From: http://stackoverflow.com/questions/2353211/hsl-to-rgb-color-conversion
 *
 * Converts an RGB color value to HSL. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes r, g, and b are contained in the set [0, 255] and
 * returns h, s, and l in the set [0, 1].
 *
 * @param   {number}  r       The red color value
 * @param   {number}  g       The green color value
 * @param   {number}  b       The blue color value
 * @return  {Array}           The HSL representation
 */
function rgbToHsl(r, g, b){
    r /= 255, g /= 255, b /= 255;
    var max = Math.max(r, g, b), min = Math.min(r, g, b);
    var h, s, l = (max + min) / 2;

    if(max == min){
        h = s = 0; // achromatic
    }else{
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch(max){
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }

    return [h, s, l];
}
</script>

<script>
var TransitionManager = function() {
	var transitionStart = null;
	var transitionEnd = null;
	var effectImage = null;

	var isTransitioning = false;
	var transitionTime = 0; // milliseconds
	var frameRate = 8; // cap the FPS
	var prevStep = -1; // used to avoid running post-process effect constantly

	this.BeginTransition = function(startRoom,startX,startY,endRoom,endX,endY,effectName) {
		// console.log("--- START ROOM TRANSITION ---");

		curEffect = effectName;

		var tmpRoom = player().room;
		var tmpX = player().x;
		var tmpY = player().y;

		if (transitionEffects[curEffect].showPlayerStart) {
			player().room = startRoom;
			player().x = startX;
			player().y = startY;
		}
		else {
			player().room = "_transition_none"; // kind of hacky!!
		}

		drawRoom(room[startRoom]);
		var startPalette = getPal( room[startRoom].pal );
		var startImage = new PostProcessImage( ctx.getImageData(0,0,canvas.width,canvas.height) ); // TODO : don't use global ctx?
		transitionStart = new TransitionInfo(startImage, startPalette, startX, startY);

		if (transitionEffects[curEffect].showPlayerEnd) {
			player().room = endRoom;
			player().x = endX;
			player().y = endY;
		}
		else {
			player().room = "_transition_none";
		}

		drawRoom(room[endRoom]);
		var endPalette = getPal( room[endRoom].pal );
		var endImage = new PostProcessImage( ctx.getImageData(0,0,canvas.width,canvas.height) );
		transitionEnd = new TransitionInfo(endImage, endPalette, endX, endY);

		effectImage = new PostProcessImage( ctx.createImageData(canvas.width,canvas.height) );

		isTransitioning = true;
		transitionTime = 0;
		prevStep = -1;

		player().room = tmpRoom;
		player().x = tmpX;
		player().y = tmpY;
	}

	this.UpdateTransition = function(dt) {
		if (!isTransitioning) {
			return;
		}

		transitionTime += dt;

		var transitionDelta = transitionTime / transitionEffects[curEffect].duration;
		var maxStep = Math.floor(frameRate * (transitionEffects[curEffect].duration / 1000));
		var step = Math.floor(transitionDelta * maxStep);

		if (step != prevStep) {
			// console.log("step! " + step + " " + transitionDelta);
			for (var y = 0; y < effectImage.Height; y++) {
				for (var x = 0; x < effectImage.Width; x++) {
					var color = transitionEffects[curEffect].pixelEffectFunc(transitionStart,transitionEnd,x,y,(step / maxStep));
					effectImage.SetPixel(x,y,color);
				}
			}
		}
		prevStep = step;

		ctx.putImageData(effectImage.GetData(), 0, 0);

		if (transitionTime >= transitionEffects[curEffect].duration) {
			isTransitioning = false;
			transitionTime = 0;
			transitionStart = null;
			transitionEnd = null;
			effectImage = null;
			prevStep = -1;
		}
	}

	this.IsTransitionActive = function() {
		return isTransitioning;
	}

	var transitionEffects = {};
	var curEffect = "none";
	this.RegisterTransitionEffect = function(name, effect) {
		transitionEffects[name] = effect;
	}

	this.RegisterTransitionEffect("none", {
		showPlayerStart : false,
		showPlayerEnd : false,
		pixelEffectFunc : function() {},
	});

	this.RegisterTransitionEffect("fade_w", { // TODO : have it linger on full white briefly?
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 750,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var pixelColorA = delta < 0.5 ? start.Image.GetPixel(pixelX,pixelY) : {r:255,g:255,b:255,a:255};
			var pixelColorB = delta < 0.5 ? {r:255,g:255,b:255,a:255} : end.Image.GetPixel(pixelX,pixelY);

			delta = delta < 0.5 ? (delta / 0.5) : ((delta - 0.5) / 0.5); // hacky

			return PostProcessUtilities.LerpColor(pixelColorA, pixelColorB, delta);
		}
	});

	this.RegisterTransitionEffect("fade_b", {
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 750,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var pixelColorA = delta < 0.5 ? start.Image.GetPixel(pixelX,pixelY) : {r:0,g:0,b:0,a:255};
			var pixelColorB = delta < 0.5 ? {r:0,g:0,b:0,a:255} : end.Image.GetPixel(pixelX,pixelY);

			delta = delta < 0.5 ? (delta / 0.5) : ((delta - 0.5) / 0.5); // hacky

			return PostProcessUtilities.LerpColor(pixelColorA, pixelColorB, delta);
		}
	});

	this.RegisterTransitionEffect("wave", {
		showPlayerStart : true,
		showPlayerEnd : true,
		duration : 1500,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var waveDelta = delta < 0.5 ? delta / 0.5 : 1 - ((delta - 0.5) / 0.5);

			var offset = (pixelY + (waveDelta * waveDelta * 0.2 * start.Image.Height));
			var freq = 4;
			var size = 2 + (14 * waveDelta);
			pixelX += Math.floor(Math.sin(offset / freq) * size);

			if (pixelX < 0) {
				pixelX += start.Image.Width;
			}
			else if (pixelX >= start.Image.Width) {
				pixelX -= start.Image.Width;
			}

			var curImage = delta < 0.5 ? start.Image : end.Image;
			return curImage.GetPixel(pixelX,pixelY);
		}
	});

	this.RegisterTransitionEffect("tunnel", {
		showPlayerStart : true,
		showPlayerEnd : true,
		duration : 1500,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			if (delta <= 0.4) {
				var tunnelDelta = 1 - (delta / 0.4);

				var xDist = start.PlayerCenter.x - pixelX;
				var yDist = start.PlayerCenter.y - pixelY;
				var dist = Math.sqrt((xDist * xDist) + (yDist * yDist));

				if (dist > start.Image.Width * tunnelDelta) {
					return {r:0,g:0,b:0,a:255};
				}
				else {
					return start.Image.GetPixel(pixelX,pixelY);
				}
			}
			else if (delta <= 0.6)
			{
				return {r:0,g:0,b:0,a:255};
			}
			else {
				var tunnelDelta = (delta - 0.6) / 0.4;

				var xDist = end.PlayerCenter.x - pixelX;
				var yDist = end.PlayerCenter.y - pixelY;
				var dist = Math.sqrt((xDist * xDist) + (yDist * yDist));

				if (dist > end.Image.Width * tunnelDelta) {
					return {r:0,g:0,b:0,a:255};
				}
				else {
					return end.Image.GetPixel(pixelX,pixelY);
				}
			}
		}
	});

	this.RegisterTransitionEffect("slide_u", {
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 1000,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var pixelOffset = -1 * Math.floor(start.Image.Height * delta);
			var slidePixelY = pixelY + pixelOffset;

			var colorDelta = clampLerp(delta, 0.4);

			if (slidePixelY >= 0) {
				var colorA = start.Image.GetPixel(pixelX,slidePixelY);
				var colorB = PostProcessUtilities.GetCorrespondingColorFromPal(colorA,start.Palette,end.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
			else {
				slidePixelY += start.Image.Height;
				var colorB = end.Image.GetPixel(pixelX,slidePixelY);
				var colorA = PostProcessUtilities.GetCorrespondingColorFromPal(colorB,end.Palette,start.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
		}
	});

	this.RegisterTransitionEffect("slide_d", {
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 1000,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var pixelOffset = Math.floor(start.Image.Height * delta);
			var slidePixelY = pixelY + pixelOffset;

			var colorDelta = clampLerp(delta, 0.4);

			if (slidePixelY < start.Image.Height) {
				var colorA = start.Image.GetPixel(pixelX,slidePixelY);
				var colorB = PostProcessUtilities.GetCorrespondingColorFromPal(colorA,start.Palette,end.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
			else {
				slidePixelY -= start.Image.Height;
				var colorB = end.Image.GetPixel(pixelX,slidePixelY);
				var colorA = PostProcessUtilities.GetCorrespondingColorFromPal(colorB,end.Palette,start.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
		}
	});

	this.RegisterTransitionEffect("slide_l", {
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 1000,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var pixelOffset = -1 * Math.floor(start.Image.Width * delta);
			var slidePixelX = pixelX + pixelOffset;

			var colorDelta = clampLerp(delta, 0.4);

			if (slidePixelX >= 0) {
				var colorA = start.Image.GetPixel(slidePixelX,pixelY);
				var colorB = PostProcessUtilities.GetCorrespondingColorFromPal(colorA,start.Palette,end.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
			else {
				slidePixelX += start.Image.Width;
				var colorB = end.Image.GetPixel(slidePixelX,pixelY);
				var colorA = PostProcessUtilities.GetCorrespondingColorFromPal(colorB,end.Palette,start.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
		}
	});

	this.RegisterTransitionEffect("slide_r", {
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 1000,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var pixelOffset = Math.floor(start.Image.Width * delta);
			var slidePixelX = pixelX + pixelOffset;

			var colorDelta = clampLerp(delta, 0.4);

			if (slidePixelX < start.Image.Width) {
				var colorA = start.Image.GetPixel(slidePixelX,pixelY);
				var colorB = PostProcessUtilities.GetCorrespondingColorFromPal(colorA,start.Palette,end.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
			else {
				slidePixelX -= start.Image.Width;
				var colorB = end.Image.GetPixel(slidePixelX,pixelY);
				var colorA = PostProcessUtilities.GetCorrespondingColorFromPal(colorB,end.Palette,start.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
		}
	});

	function clampLerp(deltaIn, clampDuration) {
		var clampOffset = (1.0 - clampDuration) / 2;
		var deltaOut = Math.min(clampDuration, Math.max(0.0, deltaIn - clampOffset)) / clampDuration;
		return deltaOut;
	}

	// TODO : WIP
	// this.RegisterTransitionEffect("fuzz", {
	// 	showPlayerStart : true,
	// 	showPlayerEnd : true,
	// 	duration : 1500,
	// 	pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
	// 		var curImage = delta <= 0.5 ? start : end;
	// 		var sampleSize = delta <= 0.5 ? (2 + Math.floor(14 * (delta/0.5))) : (16 - Math.floor(14 * ((delta-0.5)/0.5)));

	// 		var palIndex = 0;

	// 		var sampleX = Math.floor(pixelX / sampleSize) * sampleSize;
	// 		var sampleY = Math.floor(pixelY / sampleSize) * sampleSize;

	// 		var frameState = transitionEffects["fuzz"].frameState;

	// 		if (frameState.time != delta) {
	// 			frameState.time = delta;
	// 			frameState.preCalcSampleValues = {};
	// 		}

	// 		if (frameState.preCalcSampleValues[[sampleX,sampleY]]) {
	// 			palIndex = frameState.preCalcSampleValues[[sampleX,sampleY]];
	// 		}
	// 		else {
	// 			var paletteCount = {};
	// 			var foregroundValue = 1.0;
	// 			var backgroundValue = 0.4;
	// 			for (var y = sampleY; y < sampleY + sampleSize; y++) {
	// 				for (var x = sampleX; x < sampleX + sampleSize; x++) {
	// 					var color = curImage.Image.GetPixel(x,y)
	// 					var palIndex = PostProcessUtilities.GetColorPalIndex(color,curImage.Palette);
	// 					if (palIndex != -1) {
	// 						if (paletteCount[palIndex]) {
	// 							paletteCount[palIndex] += (palIndex != 0) ? foregroundValue : backgroundValue;
	// 						}
	// 						else {
	// 							paletteCount[palIndex] = (palIndex != 0) ? foregroundValue : backgroundValue;
	// 						}
	// 					}
	// 				}
	// 			}

	// 			var maxCount = 0;
	// 			for (var i in paletteCount) {
	// 				if (paletteCount[i] > maxCount) {
	// 					palIndex = i;
	// 					maxCount = paletteCount[i];
	// 				}
	// 			}

	// 			frameState.preCalcSampleValues[[sampleX,sampleY]] = palIndex;
	// 		}

	// 		return PostProcessUtilities.GetPalColor(curImage.Palette,palIndex);
	// 	},
	// 	frameState : { // ok this is hacky but it's for performance ok
	// 		time : -1,
	// 		preCalcSampleValues : {}
	// 	}
	// });
}; // TransitionManager()


// TODO : extract the scale variable so it can be changed?
var PostProcessUtilities = {
	SamplePixelColor : function(image,x,y) {
		var pixelIndex = (y * scale * image.width * 4) + (x * scale * 4);
		var r = image.data[pixelIndex + 0];
		var g = image.data[pixelIndex + 1];
		var b = image.data[pixelIndex + 2];
		var a = image.data[pixelIndex + 3];
		return { r:r, g:g, b:b, a:a };
	},
	SetPixelColor : function(image,x,y,colorRgba) {
		for (var yDelta = 0; yDelta <= scale; yDelta++) {
			for (var xDelta = 0; xDelta <= scale; xDelta++) {
				var pixelIndex = (((y * scale) + yDelta) * image.width * 4) + (((x * scale) + xDelta) * 4);
				image.data[pixelIndex + 0] = colorRgba.r;
				image.data[pixelIndex + 1] = colorRgba.g;
				image.data[pixelIndex + 2] = colorRgba.b;
				image.data[pixelIndex + 3] = colorRgba.a;
			}
		}
	},
	LerpColor : function(colorA,colorB,t) {
		// TODO: move to color_util.js?
		return {
			r : colorA.r + ((colorB.r - colorA.r) * t),
			g : colorA.g + ((colorB.g - colorA.g) * t),
			b : colorA.b + ((colorB.b - colorA.b) * t),
			a : colorA.a + ((colorB.a - colorA.a) * t),
		};
	},
	GetColorPalIndex : function(colorIn,curPal) {
		var colorIndex = -1;

		for (var i = 0; i < curPal.length; i++) {
			if (colorIn.r == curPal[i][0] && colorIn.g == curPal[i][1] && colorIn.b == curPal[i][2]) {
				colorIndex = i;
			}
		}

		return colorIndex;
	},
	GetPalColor : function(palette,index) {
		return { r: palette[index][0], g: palette[index][1], b: palette[index][2], a: 255 }
	},
	GetCorrespondingColorFromPal : function(colorIn,curPal,otherPal) { // this is kind of hacky!
		var colorIndex = PostProcessUtilities.GetColorPalIndex(colorIn,curPal);

		if (colorIndex >= 0 && colorIndex <= otherPal.length) {
			return PostProcessUtilities.GetPalColor(otherPal,colorIndex);
		}
		else {
			return colorIn;
		}
	},
};

var PostProcessImage = function(imageData) {
	this.Width = imageData.width / scale;
	this.Height = imageData.height / scale;

	this.GetPixel = function(x,y) {
		return PostProcessUtilities.SamplePixelColor(imageData,x,y);
	};

	this.SetPixel = function(x,y,colorRgba) {
		PostProcessUtilities.SetPixelColor(imageData,x,y,colorRgba);
	};

	this.GetData = function() {
		return imageData;
	};
};

var TransitionInfo = function(image, palette, playerX, playerY) {
	this.Image = image;
	this.Palette = palette;
	this.PlayerTilePos = { x: playerX, y: playerY };
	this.PlayerCenter = { x: Math.floor((playerX * tilesize) + (tilesize / 2)), y: Math.floor((playerY * tilesize) + (tilesize / 2)) };
};
</script>

<script>
/*
TODO:
- can I simplify this more now that I've removed the external resources stuff?
*/

function FontManager(packagedFontNames) {

var self = this;

var fontExtension = ".bitsyfont";
this.GetExtension = function() {
	return fontExtension;
}

// place to store font data
var fontResources = {};

// load fonts from the editor
if (packagedFontNames != undefined && packagedFontNames != null && packagedFontNames.length > 0
		&& Resources != undefined && Resources != null) {

	for (var i = 0; i < packagedFontNames.length; i++) {
		var filename = packagedFontNames[i];
		fontResources[filename] = Resources[filename];
	}
}

// manually add resource
this.AddResource = function(filename, fontdata) {
	fontResources[filename] = fontdata;
}

this.ContainsResource = function(filename) {
	return fontResources[filename] != null;
}

function GetData(fontName) {
	return fontResources[fontName + fontExtension];
}
this.GetData = GetData;

function Create(fontData) {
	return new Font(fontData);
}
this.Create = Create;

this.Get = function(fontName) {
	var fontData = self.GetData(fontName);
	return self.Create(fontData);
}

function Font(fontData) {
	var name = "unknown";
	var width = 6; // default size so if you have NO font or an invalid font it displays boxes
	var height = 8;
	var chardata = {};
	var invalidCharData = {};

	this.getName = function() {
		return name;
	}

	this.getData = function() {
		return chardata;
	}

	this.getWidth = function() {
		return width;
	}

	this.getHeight = function() {
		return height;
	}

	this.hasChar = function(char) {
		var codepoint = char.charCodeAt(0);
		return chardata[codepoint] != null;
	}

	this.getChar = function(char) {

		var codepoint = char.charCodeAt(0);

		if (chardata[codepoint] != null) {
			return chardata[codepoint];
		}
		else {
			return invalidCharData;
		}
	}

	this.allCharCodes = function() {
		var codeList = [];
		for (var code in chardata) {
			codeList.push(code);
		}
		return codeList;
	}

	function parseFont(fontData) {
		if (fontData == null)
			return;

		var lines = fontData.split("\n");

		var isReadingChar = false;
		var isReadingCharProperties = false;
		var curCharLineCount = 0;
		var curCharCode = 0;

		for (var i = 0; i < lines.length; i++) {
			var line = lines[i];

			if (line[0] === "#") {
				continue; // skip comment lines
			}

			if (!isReadingChar) {
				// READING NON CHARACTER DATA LINE
				var args = line.split(" ");
				if (args[0] == "FONT") {
					name = args[1];
				}
				else if (args[0] == "SIZE") {
					width = parseInt(args[1]);
					height = parseInt(args[2]);
				}
				else if (args[0] == "CHAR") {
					isReadingChar = true;
					isReadingCharProperties = true;

					curCharLineCount = 0;
					curCharCode = parseInt(args[1]);
					chardata[curCharCode] = { 
						width: width,
						height: height,
						offset: {
							x: 0,
							y: 0
						},
						spacing: width,
						data: []
					};
				}
			}
			else {
				// CHAR PROPERTIES
				if (isReadingCharProperties) {
					var args = line.split(" ");
					if (args[0].indexOf("CHAR_") == 0) { // Sub-properties start with "CHAR_"
						if (args[0] == "CHAR_SIZE") {
							// Custom character size - overrides the default character size for the font
							chardata[curCharCode].width = parseInt(args[1]);
							chardata[curCharCode].height = parseInt(args[2]);
							chardata[curCharCode].spacing = parseInt(args[1]); // HACK : assumes CHAR_SIZE is always declared first
						}
						else if (args[0] == "CHAR_OFFSET") {
							// Character offset - shift the origin of the character on the X or Y axis
							chardata[curCharCode].offset.x = parseInt(args[1]);
							chardata[curCharCode].offset.y = parseInt(args[2]);
						}
						else if (args[0] == "CHAR_SPACING") {
							// Character spacing:
							// specify total horizontal space taken up by the character
							// lets chars take up more or less space on a line than its bitmap does
							chardata[curCharCode].spacing = parseInt(args[1]);
						}
					}
					else {
						isReadingCharProperties = false;
					}
				}

				// CHAR DATA
				if (!isReadingCharProperties) {
					// READING CHARACTER DATA LINE
					for (var j = 0; j < chardata[curCharCode].width; j++)
					{
						chardata[curCharCode].data.push( parseInt(line[j]) );
					}

					curCharLineCount++;
					if (curCharLineCount >= height) {
						isReadingChar = false;
					}
				}
			}
		}

		// init invalid character box
		invalidCharData = { 
			width: width,
			height: height,
			offset: {
				x: 0,
				y: 0
			},
			spacing: width, // TODO : name?
			data: []
		};
		for (var y = 0; y < height; y++) {
			for (var x = 0; x < width; x++) {
				if (x < width-1 && y < height-1) {
					invalidCharData.data.push(1);
				}
				else {
					invalidCharData.data.push(0);
				}
			}
		}
	}

	parseFont(fontData);
}

} // FontManager
</script>

<script>
function Script() {

this.CreateInterpreter = function() {
	return new Interpreter();
};

this.CreateUtils = function() {
	return new Utils();
};

var Interpreter = function() {
	var env = new Environment();
	var parser = new Parser( env );

	this.SetDialogBuffer = function(buffer) { env.SetDialogBuffer( buffer ); };

	// TODO -- maybe this should return a string instead othe actual script??
	this.Compile = function(scriptName, scriptStr) {
		// console.log("COMPILE");
		var script = parser.Parse( scriptStr );
		env.SetScript( scriptName, script );
	}
	this.Run = function(scriptName, exitHandler) { // Runs pre-compiled script
		// console.log("RUN");
		// console.log(env.GetScript( scriptName ));
		env.GetScript( scriptName )
			.Eval( env, function(result) { OnScriptReturn(result, exitHandler); } );

		// console.log("SERIALIZE!!!!");
		// console.log( env.GetScript( scriptName ).Serialize() );
	}
	this.Interpret = function(scriptStr, exitHandler) { // Compiles and runs code immediately
		// console.log("INTERPRET");
		var script = parser.Parse( scriptStr );
		script.Eval( env, function(result) { OnScriptReturn(result, exitHandler); } );
	}
	this.HasScript = function(name) { return env.HasScript(name); };

	this.ResetEnvironment = function() {
		env = new Environment();
		parser = new Parser( env );
	}

	this.Parse = function(scriptStr) { // parses a script but doesn't save it
		return parser.Parse( scriptStr );
	}
	this.Eval = function(scriptTree, exitHandler) { // runs a script stored externally
		scriptTree.Eval( env, function(result) { OnScriptReturn(result, exitHandler); } );
	}

	function OnScriptReturn(result, exitHandler) {
		if (isReturnObject(result)) {
			result = result.result; // pull out the contained result
		}

		// console.log("RESULT " + result);

		if (exitHandler != null) {
			exitHandler(result);
		}
	}

	this.CreateExpression = function(expStr) {
		return parser.CreateExpression( expStr );
	}

	this.SetVariable = function(name,value,useHandler) {
		env.SetVariable(name,value,useHandler);
	}

	this.DeleteVariable = function(name,useHandler) {
		env.DeleteVariable(name,useHandler);
	}
	this.HasVariable = function(name) {
		return env.HasVariable(name);
	}

	this.SetOnVariableChangeHandler = function(onVariableChange) {
		env.SetOnVariableChangeHandler(onVariableChange);
	}
	this.GetVariableNames = function() {
		return env.GetVariableNames();
	}
	this.GetVariable = function(name) {
		return env.GetVariable(name);
	}

	this.DebugVisualizeScriptTree = function(scriptName) {
		var printVisitor = {
			Visit : function(node,depth) {
				console.log("-".repeat(depth) + "- " + node.ToString());
			},
		};

		env.GetScript( scriptName ).VisitAll( printVisitor );
	}
}


var Utils = function() {
	// for editor ui
	this.CreateDialogBlock = function(children,doIndentFirstLine) {
		if(doIndentFirstLine === undefined) doIndentFirstLine = true;
		var block = new BlockNode( BlockMode.Dialog, doIndentFirstLine );
		for(var i = 0; i < children.length; i++) {
			block.AddChild( children[i] );
		}
		return block;
	}

	this.ChangeSequenceType = function(oldSequence,type) {
		if(type === "sequence") {
			return new SequenceNode( oldSequence.options );
		}
		else if(type === "cycle") {
			return new CycleNode( oldSequence.options );
		}
		else if(type === "shuffle") {
			return new ShuffleNode( oldSequence.options );
		}
		return oldSequence;
	}

	this.CreateSequenceBlock = function() {
		var option1 = new BlockNode( BlockMode.Dialog, false /*doIndentFirstLine*/ );
		var option2 = new BlockNode( BlockMode.Dialog, false /*doIndentFirstLine*/ );
		var sequence = new SequenceNode( [ option1, option2 ] );
		var block = new BlockNode( BlockMode.Code );
		block.AddChild( sequence );
		return block;
	}

	this.CreateIfBlock = function() {
		var leftNode = new BlockNode( BlockMode.Code );
		leftNode.AddChild( new FuncNode("item", [new LiteralNode("0")] ) );
		var rightNode = new LiteralNode( 1 );
		var condition1 = new ExpNode("==", leftNode, rightNode );

		var condition2 = new ElseNode();

		var result1 = new BlockNode( BlockMode.Dialog );
		var result2 = new BlockNode( BlockMode.Dialog );

		var ifNode = new IfNode( [ condition1, condition2 ], [ result1, result2 ] );
		var block = new BlockNode( BlockMode.Code );
		block.AddChild( ifNode );
		return block;
	}

	this.ReadDialogScript = function(lines, i) {
		var scriptStr = "";
		if (lines[i] === Sym.DialogOpen) {
			scriptStr += lines[i] + "\n";
			i++;
			while(lines[i] != Sym.DialogClose) {
				scriptStr += lines[i] + "\n";
				i++;
			}
			scriptStr += lines[i];
			i++;
		}
		else {
			scriptStr += lines[i];
		}
		return { script:scriptStr, index:i };
	}

	// TODO this.ReadCodeScript (reads through code open and close symbols), and this.ReadScript

	this.EnsureDialogBlockFormat = function(dialogStr) {
		// TODO -- what if it's already enclosed in dialog symbols??
		if(dialogStr.indexOf('\n') > -1) {
			dialogStr = Sym.DialogOpen + "\n" + dialogStr + "\n" + Sym.DialogClose;
		}
		return dialogStr;
	}

	this.RemoveDialogBlockFormat = function(source) {
		var sourceLines = source.split("\n");
		var dialogStr = "";
		if(sourceLines[0] === Sym.DialogOpen) {
			// multi line
			var i = 1;
			while (i < sourceLines.length && sourceLines[i] != Sym.DialogClose) {
				dialogStr += sourceLines[i] + (sourceLines[i+1] != Sym.DialogClose ? '\n' : '');
				i++;
			}
		}
		else {
			// single line
			dialogStr = source;
		}
		return dialogStr;
	}
}


/* BUILT-IN FUNCTIONS */ // TODO: better way to encapsulate these?
function deprecatedFunc(environment,parameters,onReturn) {
	console.log("BITSY SCRIPT WARNING: Tried to use deprecated function");
	onReturn(null);
}

// TODO : vNext
// function returnFunc(environment,parameters,onReturn) {
// 	var ret = { isReturn: true, result: null };
// 	if (parameters.length > 0 && parameters[0] != undefined && parameters[0] != null) {
// 		ret.result = parameters[0];
// 	}
// 	onReturn(ret);
// }

// TODO : vNext
// // TODO : this is kind of hacky
// // - needs to work with names too
// function changeAvatarFunc(environment,parameters,onReturn) {
// 	if( parameters[0] != undefined && parameters[0] != null ) {
// 		sprite["A"].drw = "SPR_" + parameters[0];
// 	}
// 	onReturn(null);
// }

function printFunc(environment,parameters,onReturn) {
	// console.log("PRINT FUNC");
	// console.log(parameters);
	if( parameters[0] != undefined && parameters[0] != null ) {
		// console.log(parameters[0]);
		// console.log(parameters[0].toString());
		// var textStr = parameters[0].toString();
		var textStr = "" + parameters[0];
		// console.log(textStr);
		var onFinishHandler = function() {
			// console.log("FINISHED PRINTING ---- SCRIPT");
			onReturn(null);
		}; // called when dialog is finished printing
		environment.GetDialogBuffer().AddText( textStr, onFinishHandler );
	}
	else {
		onReturn(null);
	}
}

function linebreakFunc(environment,parameters,onReturn) {
	// console.log("LINEBREAK FUNC");
	environment.GetDialogBuffer().AddLinebreak();
	onReturn(null);
}

function printDrawingFunc(environment,parameters,onReturn) {
	var drawingId = parameters[0];
	environment.GetDialogBuffer().AddDrawing( drawingId, function() {
		onReturn(null);
	});
}

function printSpriteFunc(environment,parameters,onReturn) {
	var spriteId = parameters[0];
	if(names.sprite.has(spriteId)) spriteId = names.sprite.get(spriteId); // id is actually a name
	var drawingId = sprite[spriteId].drw;
	printDrawingFunc(environment, [drawingId], onReturn);
}

function printTileFunc(environment,parameters,onReturn) {
	var tileId = parameters[0];
	if(names.tile.has(tileId)) tileId = names.tile.get(tileId); // id is actually a name
	var drawingId = tile[tileId].drw;
	printDrawingFunc(environment, [drawingId], onReturn);
}

function printItemFunc(environment,parameters,onReturn) {
	var itemId = parameters[0];
	if(names.item.has(itemId)) itemId = names.item.get(itemId); // id is actually a name
	var drawingId = item[itemId].drw;
	printDrawingFunc(environment, [drawingId], onReturn);
}

function printFontFunc(environment, parameters, onReturn) {
	var allCharacters = "";
	var font = fontManager.Get( fontName );
	var codeList = font.allCharCodes();
	for (var i = 0; i < codeList.length; i++) {
		allCharacters += String.fromCharCode(codeList[i]) + " ";
	}
	printFunc(environment, [allCharacters], onReturn);
}

function itemFunc(environment,parameters,onReturn) {
	var itemId = parameters[0];
	if(names.item.has(itemId)) itemId = names.item.get(itemId); // id is actually a name
	var itemCount = player().inventory[itemId] ? player().inventory[itemId] : 0; // TODO : ultimately the environment should include a reference to the game state
	// console.log("ITEM FUNC " + itemId + " " + itemCount);
	onReturn(itemCount);
}

function addOrRemoveTextEffect(environment,name) {
	if( environment.GetDialogBuffer().HasTextEffect(name) )
		environment.GetDialogBuffer().RemoveTextEffect(name);
	else
		environment.GetDialogBuffer().AddTextEffect(name);
}

function rainbowFunc(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"rbw");
	onReturn(null);
}

// TODO : should the colors use a parameter instead of special names?
function color1Func(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"clr1");
	onReturn(null);
}

function color2Func(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"clr2");
	onReturn(null);
}

function color3Func(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"clr3");
	onReturn(null);
}

function wavyFunc(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"wvy");
	onReturn(null);
}

function shakyFunc(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"shk");
	onReturn(null);
}

/* BUILT-IN OPERATORS */
function setExp(environment,left,right,onReturn) {
	// console.log("SET " + left.name);

	if(left.type != "variable") {
		// not a variable! return null and hope for the best D:
		onReturn( null );
		return;
	}

	right.Eval(environment,function(rVal) {
		environment.SetVariable( left.name, rVal );
		// console.log("VAL " + environment.GetVariable( left.name ) );
		left.Eval(environment,function(lVal) {
			onReturn( lVal );
		});
	});
}
function equalExp(environment,left,right,onReturn) {
	// console.log("EVAL EQUAL");
	// console.log(left);
	// console.log(right);
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal === rVal );
		});
	});
}
function greaterExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal > rVal );
		});
	});
}
function lessExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal < rVal );
		});
	});
}
function greaterEqExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal >= rVal );
		});
	});
}
function lessEqExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal <= rVal );
		});
	});
}
function multExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal * rVal );
		});
	});
}
function divExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal / rVal );
		});
	});
}
function addExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal + rVal );
		});
	});
}
function subExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal - rVal );
		});
	});
}

/* ENVIRONMENT */
var Environment = function() {
	var dialogBuffer = null;
	this.SetDialogBuffer = function(buffer) { dialogBuffer = buffer; };
	this.GetDialogBuffer = function() { return dialogBuffer; };

	var functionMap = new Map();
	functionMap.set("print", printFunc);
	functionMap.set("say", printFunc);
	functionMap.set("br", linebreakFunc);
	functionMap.set("item", itemFunc);
	functionMap.set("rbw", rainbowFunc);
	functionMap.set("clr1", color1Func);
	functionMap.set("clr2", color2Func);
	functionMap.set("clr3", color3Func);
	functionMap.set("wvy", wavyFunc);
	functionMap.set("shk", shakyFunc);
	functionMap.set("printSprite", printSpriteFunc);
	functionMap.set("printTile", printTileFunc);
	functionMap.set("printItem", printItemFunc);
	functionMap.set("debugOnlyPrintFont", printFontFunc); // DEBUG ONLY

	// TODO : vNext
	// functionMap.set("changeAvatar", changeAvatarFunc);
	// functionMap.set("return", returnFunc);

	this.HasFunction = function(name) { return functionMap.has(name); };
	this.EvalFunction = function(name,parameters,onReturn) {
		// console.log(functionMap);
		// console.log(name);
		functionMap.get( name )( this, parameters, onReturn );
	}

	var variableMap = new Map();

	this.HasVariable = function(name) { return variableMap.has(name); };
	this.GetVariable = function(name) { return variableMap.get(name); };
	this.SetVariable = function(name,value,useHandler) {
		// console.log("SET VARIABLE " + name + " = " + value);
		if(useHandler === undefined) useHandler = true;
		variableMap.set(name, value);
		if(onVariableChangeHandler != null && useHandler)
			onVariableChangeHandler(name);
	};
	this.DeleteVariable = function(name,useHandler) {
		if(useHandler === undefined) useHandler = true;
		if(variableMap.has(name)) {
			variableMap.delete(name);
			if(onVariableChangeHandler != null && useHandler)
				onVariableChangeHandler(name);
		}
	};

	var operatorMap = new Map();
	operatorMap.set("=", setExp);
	operatorMap.set("==", equalExp);
	operatorMap.set(">", greaterExp);
	operatorMap.set("<", lessExp);
	operatorMap.set(">=", greaterEqExp);
	operatorMap.set("<=", lessEqExp);
	operatorMap.set("*", multExp);
	operatorMap.set("/", divExp);
	operatorMap.set("+", addExp);
	operatorMap.set("-", subExp);

	this.HasOperator = function(sym) { return operatorMap.get(sym); };
	this.EvalOperator = function(sym,left,right,onReturn) {
		operatorMap.get( sym )( this, left, right, onReturn );
	}

	var scriptMap = new Map();
	this.HasScript = function(name) { return scriptMap.has(name); };
	this.GetScript = function(name) { return scriptMap.get(name); };
	this.SetScript = function(name,script) { scriptMap.set(name, script); };

	var onVariableChangeHandler = null;
	this.SetOnVariableChangeHandler = function(onVariableChange) {
		onVariableChangeHandler = onVariableChange;
	}
	this.GetVariableNames = function() {
		return Array.from( variableMap.keys() );
	}
}

function leadingWhitespace(depth) {
	var str = "";
	for(var i = 0; i < depth; i++) {
		str += "  "; // two spaces per indent
	}
	// console.log("WHITESPACE " + depth + " ::" + str + "::");
	return str;
}

/* NODES */
var TreeRelationship = function() {
	this.parent = null;
	this.children = [];
	this.AddChild = function(node) {
		this.children.push( node );
		node.parent = this;
	};

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit( this, depth );
		for( var i = 0; i < this.children.length; i++ ) {
			this.children[i].VisitAll( visitor, depth + 1 );
		}
	};
}

function isReturnObject(val) {
	return typeof val === "object" && val != null
				&& val.isReturn != undefined && val.isReturn != null
				&& val.isReturn;
}

var BlockMode = {
	Code : "code",
	Dialog : "dialog"
};

var BlockNode = function(mode, doIndentFirstLine) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "block";
	this.mode = mode;

	this.Eval = function(environment,onReturn) {
		// console.log("EVAL BLOCK " + this.children.length);

		if( this.onEnter != null ) {
			this.onEnter();
		}

		var lastVal = null;
		var i = 0;

		function evalChildren(children,done) {
			if (i < children.length) {
				// console.log(">> CHILD " + i);
				children[i].Eval( environment, function(val) {
					// console.log("<< CHILD " + i);

					if (isReturnObject(val)) { // early return
						lastVal = val;
						done();
					}
					else {
						lastVal = val;
						i++;
						evalChildren(children,done);
					}
				} );
			}
			else {
				done();
			}
		};

		var self = this;
		evalChildren( this.children, function() {
			if( self.onExit != null ) {
				self.onExit();
			}
			onReturn(lastVal);
		} );
	}

	if(doIndentFirstLine === undefined) doIndentFirstLine = true; // This is just for serialization

	this.Serialize = function(depth) {
		if(depth === undefined) depth = 0;

		// console.log("SERIALIZE BLOCK!!!");
		// console.log(depth);
		// console.log(doIndentFirstLine);

		var str = "";
		var lastNode = null;
		if (this.mode === BlockMode.Code) str += "{"; // todo: increase scope of Sym?
		for (var i = 0; i < this.children.length; i++) {

			var curNode = this.children[i];

			if(curNode.type === "block" && lastNode && lastNode.type === "block" && !isBlockWithNoNewline(curNode) && !isBlockWithNoNewline(lastNode))
				str += "\n";

			var shouldIndentFirstLine = (i == 0 && doIndentFirstLine);
			var shouldIndentAfterLinebreak = (lastNode && lastNode.type === "function" && lastNode.name === "br");
			if(this.mode === BlockMode.Dialog && (shouldIndentFirstLine || shouldIndentAfterLinebreak))
				str += leadingWhitespace(depth);
			str += curNode.Serialize(depth);
			lastNode = curNode;
		}
		if (this.mode === BlockMode.Code) str += "}";
		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.mode;
	};
}

function isBlockWithNoNewline(node) {
	return isTextEffectBlock(node) || isMultilineListBlock(node);
}

function isTextEffectBlock(node) {
	if(node.type === "block") {
		if(node.children.length > 0 && node.children[0].type === "function") {
			var func = node.children[0];
			if(func.name === "clr1" || func.name === "clr2" || func.name === "clr3" || func.name === "wvy" || func.name === "shk" || func.name === "rbw") {
				return true;
			}
		}
	}
	return false;
}

function isMultilineListBlock(node) {
	if(node.type === "block") {
		if(node.children.length > 0) {
			var child = node.children[0];
			if(child.type === "sequence" || child.type === "cycle" || child.type === "shuffle" || child.type === "if") {
				return true;
			}
		}
	}
	return false;
}

var FuncNode = function(name,arguments) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "function";
	this.name = name;
	this.arguments = arguments;

	this.Eval = function(environment,onReturn) {

		if( this.onEnter != null ) this.onEnter();

		// console.log("FUNC");
		// console.log(this.arguments);
		var argumentValues = [];
		var i = 0;
		function evalArgs(arguments,done) {
			if(i < arguments.length) {
				// Evaluate each argument
				arguments[i].Eval( environment, function(val) {
					argumentValues.push( val );
					i++;
					evalArgs(arguments,done);
				} );
			}
			else {
				done();
			}
		};
		var self = this; // hack to deal with scope
		evalArgs( this.arguments, function() {
			// Then evaluate the function
			// console.log("ARGS");
			// console.log(argumentValues);

			if( self.onExit != null ) self.onExit();

			environment.EvalFunction( self.name, argumentValues, onReturn );
		} );
	}

	this.Serialize = function(depth) {
		var isDialogBlock = this.parent.mode && this.parent.mode === BlockMode.Dialog;
		if(isDialogBlock && this.name === "print") {
			// TODO this could cause problems with "real" print functions
			return this.arguments[0].value; // first argument should be the text of the {print} func
		}
		else if(isDialogBlock && this.name === "br") {
			return "\n";
		}
		else {
			var str = "";
			str += this.name;
			for(var i = 0; i < this.arguments.length; i++) {
				str += " ";
				str += this.arguments[i].Serialize(depth);
			}
			return str;
		}
	}

	this.ToString = function() {
		return this.type + " " + this.name;
	};
}

var LiteralNode = function(value) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "literal";
	this.value = value;

	this.Eval = function(environment,onReturn) {
		onReturn(this.value);
	}

	this.Serialize = function(depth) {
		var str = "";

		if(this.value === null)
			return str;

		if(typeof this.value === "string") str += '"';
		str += this.value;
		if(typeof this.value === "string") str += '"';

		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.value;
	};
}

var VarNode = function(name) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "variable";
	this.name = name;

	this.Eval = function(environment,onReturn) {
		// console.log("EVAL " + this.name + " " + environment.HasVariable(this.name) + " " + environment.GetVariable(this.name));
		if( environment.HasVariable(this.name) )
			onReturn( environment.GetVariable( this.name ) );
		else
			onReturn(null); // not a valid variable -- return null and hope that's ok
	} // TODO: might want to store nodes in the variableMap instead of values???

	this.Serialize = function(depth) {
		var str = "" + this.name;
		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.name;
	};
}

var ExpNode = function(operator, left, right) {
	Object.assign( this, new TreeRelationship() );
	this.type = "operator";
	this.operator = operator;
	this.left = left;
	this.right = right;

	this.Eval = function(environment,onReturn) {
		// console.log("EVAL " + this.operator);
		var self = this; // hack to deal with scope
		environment.EvalOperator( this.operator, this.left, this.right, 
			function(val){
				// console.log("EVAL EXP " + self.operator + " " + val);
				onReturn(val);
			} );
		// NOTE : sadly this pushes a lot of complexity down onto the actual operator methods
	}

	this.Serialize = function(depth) {
		var isNegativeNumber = this.operator === "-" && this.left.type === "literal" && this.left.value === null;

		if(!isNegativeNumber) {
			var str = "";
			str += this.left.Serialize(depth);
			str += " " + this.operator + " ";
			str += this.right.Serialize(depth);
			return str;
		}
		else {
			return this.operator + this.right.Serialize(depth); // hacky but seems to work
		}
	}

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit( this, depth );
		if(this.left != null)
			this.left.VisitAll( visitor, depth + 1 );
		if(this.right != null)
			this.right.VisitAll( visitor, depth + 1 );
	};

	this.ToString = function() {
		return this.type + " " + this.operator;
	};
}

var SequenceBase = function() {
	this.Serialize = function(depth) {
		var str = "";
		str += this.type + "\n";
		for (var i = 0; i < this.options.length; i++) {
			// console.log("SERIALIZE SEQUENCE ");
			// console.log(depth);
			str += leadingWhitespace(depth + 1) + Sym.List + " " + this.options[i].Serialize(depth + 2) + "\n";
		}
		str += leadingWhitespace(depth);
		return str;
	}

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit( this, depth );
		for( var i = 0; i < this.options.length; i++ ) {
			this.options[i].VisitAll( visitor, depth + 1 );
		}
	};

	this.ToString = function() {
		return this.type;
	};
}

var SequenceNode = function(options) {
	Object.assign( this, new TreeRelationship() );
	Object.assign( this, new SequenceBase() );
	this.type = "sequence";
	this.options = options;

	var index = 0;
	this.Eval = function(environment,onReturn) {
		// console.log("SEQUENCE " + index);
		this.options[index].Eval( environment, onReturn );

		var next = index + 1;
		if(next < this.options.length)
			index = next;
	}
}

var CycleNode = function(options) {
	Object.assign( this, new TreeRelationship() );
	Object.assign( this, new SequenceBase() );
	this.type = "cycle";
	this.options = options;

	var index = 0;
	this.Eval = function(environment,onReturn) {
		// console.log("CYCLE " + index);
		this.options[index].Eval( environment, onReturn );

		var next = index + 1;
		if(next < this.options.length)
			index = next;
		else
			index = 0;
	}
}

var ShuffleNode = function(options) {
	Object.assign( this, new TreeRelationship() );
	Object.assign( this, new SequenceBase() );
	this.type = "shuffle";
	this.options = options;

	var optionsShuffled = [];
	function shuffle(options) {
		optionsShuffled = [];
		var optionsUnshuffled = options.slice();
		while(optionsUnshuffled.length > 0) {
			var i = Math.floor( Math.random() * optionsUnshuffled.length );
			optionsShuffled.push( optionsUnshuffled.splice(i,1)[0] );
		}
	}
	shuffle(this.options);

	var index = 0;
	this.Eval = function(environment,onReturn) {
		// OLD RANDOM VERSION
		// var index = Math.floor(Math.random() * this.options.length);
		// this.options[index].Eval( environment, onReturn );

		optionsShuffled[index].Eval( environment, onReturn );
		
		index++;
		if (index >= this.options.length) {
			shuffle(this.options);
			index = 0;
		}
	}
}

var IfNode = function(conditions, results, isSingleLine) {
	Object.assign( this, new TreeRelationship() );
	this.type = "if";
	this.conditions = conditions;
	this.results = results;

	this.Eval = function(environment,onReturn) {
		// console.log("EVAL IF");
		var i = 0;
		var self = this;
		function TestCondition() {
			// console.log("EVAL " + i);
			self.conditions[i].Eval(environment, function(val) {
				// console.log(val);
				if(val == true) {
					self.results[i].Eval(environment, onReturn);
				}
				else if(i+1 < self.conditions.length) {
					i++;
					TestCondition(); // test next condition
				}
				else {
					onReturn(null); // out of conditions and none were true
				}
			});
		};
		TestCondition();
	}

	if(isSingleLine === undefined) isSingleLine = false; // This is just for serialization

	this.Serialize = function(depth) {
		var str = "";
		if(isSingleLine) {
			str += this.conditions[0].Serialize() + " ? " + this.results[0].Serialize();
			if(this.conditions.length > 1 && this.conditions[1].type === "else")
				str += " : " + this.results[1].Serialize();
		}
		else {
			str += "\n";
			for (var i = 0; i < this.conditions.length; i++) {
				str += leadingWhitespace(depth + 1) + Sym.List + " " + this.conditions[i].Serialize(depth) + " ?\n";
				str += this.results[i].Serialize(depth + 2) + "\n";
			}
			str += leadingWhitespace(depth);
		}
		return str;
	}

	this.IsSingleLine = function() {
		return isSingleLine;
	}

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit( this, depth );
		for( var i = 0; i < this.conditions.length; i++ ) {
			this.conditions[i].VisitAll( visitor, depth + 1 );
		}
		for( var i = 0; i < this.results.length; i++ ) {
			this.results[i].VisitAll( visitor, depth + 1 );
		}
	};

	this.ToString = function() {
		return this.type + " " + this.mode;
	};
}

var ElseNode = function() {
	Object.assign( this, new TreeRelationship() );
	this.type = "else";

	this.Eval = function(environment,onReturn) {
		onReturn(true);
	}

	this.Serialize = function() {
		return "else";
	}

	this.ToString = function() {
		return this.type + " " + this.mode;
	};
}

var Sym = {
	// DialogOpen : "/\"",
	// DialogClose : "\"/",
	DialogOpen : '"""',
	DialogClose : '"""',
	CodeOpen : "{",
	CodeClose : "}",
	Linebreak : "\n", // just call it "break" ?
	Separator : ":",
	List : "-",
	String : '"'
};

var Parser = function(env) {
	var environment = env;

	this.Parse = function(scriptStr) {
		// console.log("NEW PARSE!!!!!!");

		// TODO : make this work for single-line, no dialog block scripts

		var state = new ParserState( new BlockNode(BlockMode.Dialog), scriptStr );

		if( state.MatchAhead(Sym.DialogOpen) ) {
			// multi-line dialog block
			var dialogStr = state.ConsumeBlock( Sym.DialogOpen, Sym.DialogClose );
			state = new ParserState( new BlockNode(BlockMode.Dialog), dialogStr );
			state = ParseDialog( state );
		}
		// else if( state.MatchAhead(Sym.CodeOpen) ) { // NOTE: This causes problems when you lead with a code block
		// 	// code-block: should this ever happen?
		// 	state = ParseCodeBlock( state );
		// }
		else {
			// single-line dialog block
			state = ParseDialog( state );
		}

		// console.log( state.rootNode );
		return state.rootNode;
	};

	var ParserState = function( rootNode, str ) {
		this.rootNode = rootNode;
		this.curNode = this.rootNode;

		var sourceStr = str;
		var i = 0;
		this.Index = function() { return i; };
		this.Count = function() { return sourceStr.length; };
		this.Done = function() { return i >= sourceStr.length; };
		this.Char = function() { return sourceStr[i]; };
		this.Step = function(n) { if(n===undefined) n=1; i += n; };
		this.MatchAhead = function(str) {
			// console.log(str);
			str = "" + str; // hack to turn single chars into strings
			// console.log(str);
			// console.log(str.length);
			for(var j = 0; j < str.length; j++) {
				if( i + j >= sourceStr.length )
					return false;
				else if( str[j] != sourceStr[i+j] )
					return false;
			}
			return true;
		}
		this.Peak = function(end) {
			var str = "";
			var j = i;
			// console.log(j);
			while(j < sourceStr.length && end.indexOf( sourceStr[j] ) == -1 ) {
				str += sourceStr[j];
				j++;
			}
			// console.log("PEAK ::" + str + "::");
			return str;
		}
		this.ConsumeBlock = function( open, close ) {
			var startIndex = i;

			var matchCount = 0;
			if( this.MatchAhead( open ) ) {
				matchCount++;
				this.Step( open.length );
			}

			while( matchCount > 0 && !this.Done() ) {
				if( this.MatchAhead( close ) ) {
					matchCount--;
					this.Step( close.length );
				}
				else if( this.MatchAhead( open ) ) {
					matchCount++;
					this.Step( open.length );
				}
				else {
					this.Step();
				}
			}

			// console.log("!!! " + startIndex + " " + i);

			return sourceStr.slice( startIndex + open.length, i - close.length );
		}
		this.Print = function() { console.log(sourceStr); };
		this.Source = function() { return sourceStr; };
	};

	function ParseDialog(state) {
		// console.log("PARSE DIALOG");
		state.Print();

		// for linebreak logic: add linebreaks after lines with dialog or empty lines (if it's not the very first line)
		var hasBlock = false;
		var hasDialog = false;
		var isFirstLine = true;

		// console.log("---- PARSE DIALOG ----");

		var text = "";
		var addTextNode = function() {
			// console.log("TEXT " + text.length);
			if (text.length > 0) {
				// console.log("TEXT " + text);
				// console.log("text!!");
				// console.log([text]);

				state.curNode.AddChild( new FuncNode( "print", [new LiteralNode(text)] ) );
				text = "";

				hasDialog = true;
			}
		}

		while ( !state.Done() ) {

			if( state.MatchAhead(Sym.CodeOpen) ) {
				addTextNode();
				state = ParseCodeBlock( state );

				// console.log("CODE");

				var len = state.curNode.children.length;
				if(len > 0 && state.curNode.children[len-1].type === "block") {
					var block = state.curNode.children[len-1];
					if(isMultilineListBlock(block))
						hasDialog = true; // hack to get correct newline behavior for multiline blocks
				}

				hasBlock = true;
			}
			// NOTE: nested dialog blocks disabled for now
			// else if( state.MatchAhead(Sym.DialogOpen) ) {
			// 	addTextNode();
			// 	state = ParseDialogBlock( state ); // These can be nested (should they though???)

			// 	hasBlock = true;
			// }
			else {
				if ( state.MatchAhead(Sym.Linebreak) ) {
					addTextNode();

					/*
					NOTES:
					linebreaks SHOULD happen on
					- lines with text (including the first or last line)
					- empty lines (that are NOT the first or last line)
					linebreaks should NOT happen on
					- lines with only CODE blocks
					- empty FIRST or LAST lines

					also, apparently:
					- NEVER line break on the last line
					*/
					var isLastLine = (state.Index() + 1) == state.Count();
					// console.log("block " + hasBlock);
					// console.log("dialog " + hasDialog);
					var isEmptyLine = !hasBlock && !hasDialog;
					// console.log("empty " + isEmptyLine);
					var isValidEmptyLine = isEmptyLine && !(isFirstLine || isLastLine);
					// console.log("valid empty " + isValidEmptyLine);
					var shouldAddLinebreak = (hasDialog || isValidEmptyLine) && !isLastLine; // last clause is a hack (but it works - why?)
					// console.log("LINEBREAK? " + shouldAddLinebreak);
					if( shouldAddLinebreak ) {
						// console.log("NEWLINE");
						// console.log("empty? " + isEmptyLine);
						// console.log("dialog? " + hasDialog);
						state.curNode.AddChild( new FuncNode( "br", [] ) ); // use function or character?
					}

					// linebreak logic
					isFirstLine = false;
					hasBlock = false;
					hasDialog = false;

					text = "";
				}
				else {
					text += state.Char();
				}
				state.Step();
			}

		}
		addTextNode();

		// console.log("---- PARSE DIALOG ----");

		// console.log(state);
		return state;
	}

	function ParseDialogBlock(state) {
		var dialogStr = state.ConsumeBlock( Sym.DialogOpen, Sym.DialogClose );

		var dialogState = new ParserState( new BlockNode(BlockMode.Dialog), dialogStr );
		dialogState = ParseDialog( dialogState );

		state.curNode.AddChild( dialogState.rootNode );

		return state;
	}

	function ParseIf(state) {
		var conditionStrings = [];
		var resultStrings = [];
		var curIndex = -1;
		var isNewline = true;
		var isConditionDone = false;
		var codeBlockCount = 0;

		while( !state.Done() ) {
			if(state.Char() === Sym.CodeOpen)
				codeBlockCount++;
			else if(state.Char() === Sym.CodeClose)
				codeBlockCount--;

			var isWhitespace = (state.Char() === " " || state.Char() === "\t");
			var isSkippableWhitespace = isNewline && isWhitespace;
			var isNewListItem = isNewline && (codeBlockCount <= 0) && (state.Char() === Sym.List);

			if(isNewListItem) {
				curIndex++;
				isConditionDone = false;
				conditionStrings[curIndex] = "";
				resultStrings[curIndex] = "";
			}
			else if(curIndex > -1) {
				if(!isConditionDone) {
					if(state.Char() === "?" || state.Char() === "\n") { // TODO: use Sym
						// end of condition
						isConditionDone = true;
					}
					else {
						// read in condition
						conditionStrings[curIndex] += state.Char();
					}
				}
				else {
					// read in result
					if(!isSkippableWhitespace)
						resultStrings[curIndex] += state.Char();
				}
			}

			isNewline = (state.Char() === Sym.Linebreak) || isSkippableWhitespace || isNewListItem;

			state.Step();
		}

		// console.log("PARSE IF:");
		// console.log(conditionStrings);
		// console.log(resultStrings);

		var conditions = [];
		for(var i = 0; i < conditionStrings.length; i++) {
			var str = conditionStrings[i].trim();
			if(str === "else") {
				conditions.push( new ElseNode() );
			}
			else {
				var exp = CreateExpression( str );
				conditions.push( exp );
			}
		}

		var results = [];
		for(var i = 0; i < resultStrings.length; i++) {
			var str = resultStrings[i];
			var dialogBlockState = new ParserState( new BlockNode(BlockMode.Dialog), str );
			dialogBlockState = ParseDialog( dialogBlockState );
			var dialogBlock = dialogBlockState.rootNode;
			results.push( dialogBlock );
		}

		state.curNode.AddChild( new IfNode( conditions, results ) );

		return state;
	}

	function IsSequence(str) {
		// console.log("IsSequence? " + str);
		return str === "sequence" || str === "cycle" || str === "shuffle";
	}

	// TODO: don't forget about eating whitespace
	function ParseSequence(state, sequenceType) {
		// console.log("SEQUENCE " + sequenceType);
		state.Print();

		var isNewline = false;
		var itemStrings = [];
		var curItemIndex = -1; // -1 indicates not reading an item yet
		var codeBlockCount = 0;

		while( !state.Done() ) {
			if(state.Char() === Sym.CodeOpen)
				codeBlockCount++;
			else if(state.Char() === Sym.CodeClose)
				codeBlockCount--;

			var isWhitespace = (state.Char() === " " || state.Char() === "\t");
			var isSkippableWhitespace = isNewline && isWhitespace;
			var isNewListItem = isNewline && (codeBlockCount <= 0) && (state.Char() === Sym.List);

			if(isNewListItem) {
				// console.log("found next list item");
				curItemIndex++;
				itemStrings[curItemIndex] = "";
			}
			else if(curItemIndex > -1) {
				if(!isSkippableWhitespace)
					itemStrings[curItemIndex] += state.Char();
			}

			isNewline = (state.Char() === Sym.Linebreak) || isSkippableWhitespace || isNewListItem;

			// console.log(state.Char());
			state.Step();
		}
		// console.log(itemStrings);
		// console.log("SEQUENCE DONE");

		var options = [];
		for(var i = 0; i < itemStrings.length; i++) {
			var str = itemStrings[i];
			var dialogBlockState = new ParserState( new BlockNode( BlockMode.Dialog, false /* doIndentFirstLine */ ), str );
			dialogBlockState = ParseDialog( dialogBlockState );
			var dialogBlock = dialogBlockState.rootNode;
			options.push( dialogBlock );
		}

		// console.log(options);

		if(sequenceType === "sequence")
			state.curNode.AddChild( new SequenceNode( options ) );
		else if(sequenceType === "cycle")
			state.curNode.AddChild( new CycleNode( options ) );
		else if(sequenceType === "shuffle")
			state.curNode.AddChild( new ShuffleNode( options ) );

		return state;
	}

	function ParseFunction(state, funcName) {
		console.log("~~~ PARSE FUNCTION " + funcName);

		var args = [];

		var curSymbol = "";
		function OnSymbolEnd() {
			curSymbol = curSymbol.trim();
			// console.log("PARAMTER " + curSymbol);
			args.push( StringToValue(curSymbol) );
			// console.log(args);
			curSymbol = "";
		}

		while( !( state.Char() === "\n" || state.Done() ) ) {
			if( state.MatchAhead(Sym.CodeOpen) ) {
				var codeBlockState = new ParserState( new BlockNode(BlockMode.Code), state.ConsumeBlock( Sym.CodeOpen, Sym.CodeClose ) );
				codeBlockState = ParseCode( codeBlockState );
				var codeBlock = codeBlockState.rootNode;
				args.push( codeBlock );
				curSymbol = "";
			}
			else if( state.MatchAhead(Sym.String) ) {
				/* STRING LITERAL */
				var str = state.ConsumeBlock(Sym.String, Sym.String);
				// console.log("STRING " + str);
				args.push( new LiteralNode(str) );
				curSymbol = "";
			}
			else if(state.Char() === " " && curSymbol.length > 0) {
				OnSymbolEnd();
			}
			else {
				curSymbol += state.Char();
			}
			state.Step();
		}

		if(curSymbol.length > 0) {
			OnSymbolEnd();
		}

		state.curNode.AddChild( new FuncNode( funcName, args ) );

		return state;
	}

	function IsValidVariableName(str) {
		var reg = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
		var isValid = reg.test(str);
		// console.log("VALID variable??? " + isValid);
		return isValid;
	}

	function StringToValue(valStr) {
		if(valStr[0] === Sym.CodeOpen) {
			// CODE BLOCK!!!
			var codeStr = (new ParserState( null, valStr )).ConsumeBlock(Sym.CodeOpen, Sym.CodeClose); //hacky
			var codeBlockState = new ParserState( new BlockNode( BlockMode.Code ), codeStr );
			codeBlockState = ParseCode( codeBlockState );
			return codeBlockState.rootNode;
		}
		else if(valStr[0] === Sym.String) {
			// STRING!!
			// console.log("STRING");
			var str = "";
			var i = 1;
			while (i < valStr.length && valStr[i] != Sym.String) {
				str += valStr[i];
				i++;
			}
			// console.log(str);
			return new LiteralNode( str );
		}
		else if(valStr === "true") {
			// BOOL
			return new LiteralNode( true );
		}
		else if(valStr === "false") {
			// BOOL
			return new LiteralNode( false );
		}
		else if( !isNaN(parseFloat(valStr)) ) {
			// NUMBER!!
			// console.log("NUMBER!!! " + valStr);
			return new LiteralNode( parseFloat(valStr) );
		}
		else if(IsValidVariableName(valStr)) {
			// VARIABLE!!
			// console.log("VARIABLE");
			return new VarNode(valStr); // TODO : check for valid potential variables
		}
		else {
			// uh oh
			return new LiteralNode(null);
		}
	}

	var setSymbol = "=";
	var ifSymbol = "?";
	var elseSymbol = ":";
	var operatorSymbols = ["==", ">=", "<=", ">", "<", "-", "+", "/", "*"]; // operators need to be in reverse order of precedence
	function CreateExpression(expStr) {
		console.log("CREATE EXPRESSION --- " + expStr);

		expStr = expStr.trim();

		function IsInsideString(index) {
			var inString = false;
			for(var i = 0; i < expStr.length; i++) {
				if(expStr[i] === Sym.String)
					inString = !inString;

				if(index === i)
					return inString;
			}
			return false;
		}

		function IsInsideCode(index) {
			var count = 0;
			for(var i = 0; i < expStr.length; i++) {
				if(expStr[i] === Sym.CodeOpen)
					count++;
				else if(expStr[i] === Sym.CodeClose)
					count--;

				if(index === i)
					return count > 0;
			}
			return false;
		}

		var operator = null;

		// set is special because other operator can look like it, and it has to go first in the order of operations
		var setIndex = expStr.indexOf(setSymbol);
		if( setIndex > -1 && !IsInsideString(setIndex) && !IsInsideCode(setIndex) ) { // it might be a set operator
			if( expStr[setIndex+1] != "=" && expStr[setIndex-1] != ">" && expStr[setIndex-1] != "<" ) {
				// ok it actually IS a set operator and not ==, >=, or <=
				operator = setSymbol;
				var variableName = expStr.substring(0,setIndex).trim(); // TODO : valid variable name testing
				var left = IsValidVariableName(variableName) ? new VarNode( variableName ) : new LiteralNode(null);
				var right = CreateExpression( expStr.substring(setIndex+setSymbol.length) );
				var exp = new ExpNode( operator, left, right );
				return exp;
			}
		}

		// special if "expression" for single-line if statements
		var ifIndex = expStr.indexOf(ifSymbol);
		if( ifIndex > -1 && !IsInsideString(ifIndex) && !IsInsideCode(ifIndex) ) {
			operator = ifSymbol;
			var conditionStr = expStr.substring(0,ifIndex).trim();
			var conditions = [ CreateExpression(conditionStr) ];

			var resultStr = expStr.substring(ifIndex+ifSymbol.length);
			var results = [];
			function AddResult(str) {
				var dialogBlockState = new ParserState( new BlockNode(BlockMode.Dialog), str );
				dialogBlockState = ParseDialog( dialogBlockState );
				var dialogBlock = dialogBlockState.rootNode;
				results.push( dialogBlock );
			}

			var elseIndex = resultStr.indexOf(elseSymbol); // does this need to test for strings?
			if(elseIndex > -1) {
				conditions.push( new ElseNode() );

				var elseStr = resultStr.substring(elseIndex+elseSymbol.length);
				var resultStr = resultStr.substring(0,elseIndex);

				AddResult( resultStr.trim() );
				AddResult( elseStr.trim() );
			}
			else {
				AddResult( resultStr.trim() );
			}

			return new IfNode( conditions, results, true /*isSingleLine*/ );
		}

		for( var i = 0; (operator == null) && (i < operatorSymbols.length); i++ ) {
			var opSym = operatorSymbols[i];
			var opIndex = expStr.indexOf( opSym );
			if( opIndex > -1 && !IsInsideString(opIndex) && !IsInsideCode(opIndex) ) {
				operator = opSym;
				var left = CreateExpression( expStr.substring(0,opIndex) );
				var right = CreateExpression( expStr.substring(opIndex+opSym.length) );
				var exp = new ExpNode( operator, left, right );
				return exp;
			}
		}

		if( operator == null ) {
			return StringToValue(expStr);
		}
	}
	this.CreateExpression = CreateExpression;

	function IsWhitespace(str) {
		return ( str === " " || str === "\t" || str === "\n" );
	}

	function IsExpression(str) {
		var tempState = new ParserState(null, str); // hacky
		var nonWhitespaceCount = 0;

		while (!tempState.Done()) {
			if( IsWhitespace(tempState.Char()) ) {
				tempState.Step(); // consume whitespace
			}
			else if( tempState.MatchAhead(Sym.CodeOpen) ) {
				tempState.ConsumeBlock( Sym.CodeOpen, Sym.CodeClose );
			}
			else {
				nonWhitespaceCount++;
				tempState.Step();
			}
		}

		var isExpression = nonWhitespaceCount > 0;
		return isExpression;
	}

	function ParseExpression(state) {
		var line = state.Source(); // state.Peak( [Sym.Linebreak] ); // TODO : remove the linebreak thing
		// console.log("EXPRESSION " + line);
		var exp = CreateExpression( line );
		// console.log(exp);
		state.curNode.AddChild( exp );
		state.Step( line.length );
		return state;
	}

	function ParseCode(state) {
		console.log("PARSE CODE --- " + state.Source());

		// skip leading whitespace
		while (IsWhitespace(state.Char())) {
			state.Step();
		}

		if( state.Char() === Sym.List && (state.Peak([]).indexOf("?") > -1) ) { // TODO : symbols? matchahead?
			// console.log("PEAK IF " + state.Peak( ["?"] ));
			state = ParseIf( state );
		}
		else if( environment.HasFunction( state.Peak( [" "] ) ) ) { // TODO --- what about newlines???
			var funcName = state.Peak( [" "] );
			state.Step( funcName.length );
			state = ParseFunction( state, funcName );
		}
		else if( IsSequence( state.Peak( [" ", Sym.Linebreak] ) ) ) {
			var sequenceType = state.Peak( [" ", Sym.Linebreak] );
			state.Step( sequenceType.length );
			state = ParseSequence( state, sequenceType );
		}
		else if (IsExpression(state.Source())) {
			state = ParseExpression(state);
		}
		else {
			// multi-line code block
			while (!state.Done()) {
				if( state.MatchAhead(Sym.CodeOpen) ) {
					state = ParseCodeBlock( state );
				}
				else {
					state.Step();
				}
			}
		}

		// just go to the end now
		while (!state.Done()) {
			state.Step();
		}

		return state;
	}

	function ParseCodeBlock(state) {
		var codeStr = state.ConsumeBlock( Sym.CodeOpen, Sym.CodeClose );

		// console.log("PARSE CODE");
		// console.log(codeStr);

		var codeState = new ParserState( new BlockNode(BlockMode.Code), codeStr );
		codeState = ParseCode( codeState );
		
		state.curNode.AddChild( codeState.rootNode );

		return state;
	}

}

} // Script()
</script>

<script>
function Dialog() {

this.CreateRenderer = function() {
	return new DialogRenderer();
};

this.CreateBuffer = function() {
	return new DialogBuffer();
};

var DialogRenderer = function() {

	// TODO : refactor this eventually? remove everything from struct.. avoid the defaults?
	var textboxInfo = {
		img : null,
		width : 104,
		height : 8+4+2+5, //8 for text, 4 for top-bottom padding, 2 for line padding, 5 for arrow
		top : 12,
		left : 12,
		bottom : 12, //for drawing it from the bottom
		font_scale : 0.5, // we draw font at half-size compared to everything else
		padding_vert : 2,
		padding_horz : 4,
		arrow_height : 5,
	};

	var font = null;
	this.SetFont = function(f) {
		font = f;
		textboxInfo.height = (textboxInfo.padding_vert * 3) + (relativeFontHeight() * 2) + textboxInfo.arrow_height;
		textboxInfo.img = context.createImageData(textboxInfo.width*scale, textboxInfo.height*scale);
	}

	function textScale() {
		return scale * textboxInfo.font_scale;
	}

	function relativeFontWidth() {
		return Math.ceil( font.getWidth() * textboxInfo.font_scale );
	}

	function relativeFontHeight() {
		return Math.ceil( font.getHeight() * textboxInfo.font_scale );
	}

	var context = null;
	this.AttachContext = function(c) {
		context = c;
	};

	this.ClearTextbox = function() {
		if(context == null) return;

		//create new image none exists
		if(textboxInfo.img == null)
			textboxInfo.img = context.createImageData(textboxInfo.width*scale, textboxInfo.height*scale);

		// fill text box with black
		for (var i=0;i<textboxInfo.img.data.length;i+=4)
		{
			textboxInfo.img.data[i+0]=0;
			textboxInfo.img.data[i+1]=0;
			textboxInfo.img.data[i+2]=0;
			textboxInfo.img.data[i+3]=255;
		}
	};

	var isCentered = false;
	this.SetCentered = function(centered) {
		isCentered = centered;
	};

	this.DrawTextbox = function() {
		if(context == null) return;
		if (isCentered) {
			context.putImageData(textboxInfo.img, textboxInfo.left*scale, ((height/2)-(textboxInfo.height/2))*scale);
		}
		else if (player().y < mapsize/2) {
			//bottom
			context.putImageData(textboxInfo.img, textboxInfo.left*scale, (height-textboxInfo.bottom-textboxInfo.height)*scale);
		}
		else {
			//top
			context.putImageData(textboxInfo.img, textboxInfo.left*scale, textboxInfo.top*scale);
		}
	};

	var arrowdata = [
		1,1,1,1,1,
		0,1,1,1,0,
		0,0,1,0,0
	];
	this.DrawNextArrow = function() {
		// console.log("draw arrow!");
		var top = (textboxInfo.height-5) * scale;
		var left = (textboxInfo.width-(5+4)) * scale;
		if (textDirection === TextDirection.RightToLeft) { // RTL hack
			left = 4 * scale;
		}

		for (var y = 0; y < 3; y++) {
			for (var x = 0; x < 5; x++) {
				var i = (y * 5) + x;
				if (arrowdata[i] == 1) {
					//scaling nonsense
					for (var sy = 0; sy < scale; sy++) {
						for (var sx = 0; sx < scale; sx++) {
							var pxl = 4 * ( ((top+(y*scale)+sy) * (textboxInfo.width*scale)) + (left+(x*scale)+sx) );
							textboxInfo.img.data[pxl+0] = 255;
							textboxInfo.img.data[pxl+1] = 255;
							textboxInfo.img.data[pxl+2] = 255;
							textboxInfo.img.data[pxl+3] = 255;
						}
					}
				}
			}
		}
	};

	var text_scale = 2; //using a different scaling factor for text feels like cheating... but it looks better
	this.DrawChar = function(char, row, col, leftPos) {
		char.offset = {
			x: char.base_offset.x,
			y: char.base_offset.y
		}; // compute render offset *every* frame

		char.SetPosition(row,col);
		char.ApplyEffects(effectTime);

		var charData = char.bitmap;

		var top = (4 * scale) + (row * 2 * scale) + (row * font.getHeight() * text_scale) + Math.floor( char.offset.y );
		var left = (4 * scale) + (leftPos * text_scale) + Math.floor( char.offset.x );

		var debug_r = Math.random() * 255;

		for (var y = 0; y < char.height; y++) {
			for (var x = 0; x < char.width; x++) {

				var i = (y * char.width) + x;
				if ( charData[i] == 1 ) {

					//scaling nonsense
					for (var sy = 0; sy < text_scale; sy++) {
						for (var sx = 0; sx < text_scale; sx++) {
							var pxl = 4 * ( ((top+(y*text_scale)+sy) * (textboxInfo.width*scale)) + (left+(x*text_scale)+sx) );
							textboxInfo.img.data[pxl+0] = char.color.r;
							textboxInfo.img.data[pxl+1] = char.color.g;
							textboxInfo.img.data[pxl+2] = char.color.b;
							textboxInfo.img.data[pxl+3] = char.color.a;
						}
					}
				}
				// else {
				// 	// DEBUG

				// 	//scaling nonsense
				// 	for (var sy = 0; sy < text_scale; sy++) {
				// 		for (var sx = 0; sx < text_scale; sx++) {
				// 			var pxl = 4 * ( ((top+(y*text_scale)+sy) * (textboxInfo.width*scale)) + (left+(x*text_scale)+sx) );
				// 			textboxInfo.img.data[pxl+0] = debug_r;
				// 			textboxInfo.img.data[pxl+1] = 0;
				// 			textboxInfo.img.data[pxl+2] = 0;
				// 			textboxInfo.img.data[pxl+3] = 255;
				// 		}
				// 	}
				// }

			}
		}
		
		// call printHandler for character
		char.OnPrint();
	};

	var effectTime = 0; // TODO this variable should live somewhere better
	this.Draw = function(buffer,dt) {
		effectTime += dt;

		this.ClearTextbox();

		buffer.ForEachActiveChar( this.DrawChar );

		if( buffer.CanContinue() )
			this.DrawNextArrow();

		this.DrawTextbox();

		if( buffer.DidPageFinishThisFrame() && onPageFinish != null )
			onPageFinish();
	};

	/* this is a hook for GIF rendering */
	var onPageFinish = null;
	this.SetPageFinishHandler = function(handler) {
		onPageFinish = handler;
	};

	this.Reset = function() {
		effectTime = 0;
		// TODO - anything else?
	}

	// this.CharsPerRow = function() {
	// 	return textboxInfo.charsPerRow;
	// }
}


var DialogBuffer = function() {
	var buffer = [[[]]]; // holds dialog in an array buffer
	var pageIndex = 0;
	var rowIndex = 0;
	var charIndex = 0;
	var nextCharTimer = 0;
	var nextCharMaxTime = 50; // in milliseconds
	var isDialogReadyToContinue = false;
	var activeTextEffects = [];
	var font = null;
	var arabicHandler = new ArabicHandler();
	var onDialogEndCallbacks = [];

	this.SetFont = function(f) {
		font = f;
	}

	this.CurPage = function() { return buffer[ pageIndex ]; };
	this.CurRow = function() { return this.CurPage()[ rowIndex ]; };
	this.CurChar = function() { return this.CurRow()[ charIndex ]; };
	this.CurPageCount = function() { return buffer.length; };
	this.CurRowCount = function() { return this.CurPage().length; };
	this.CurCharCount = function() { return this.CurRow().length; };

	this.ForEachActiveChar = function(handler) { // Iterates over visible characters on the active page
		var rowCount = rowIndex + 1;
		for (var i = 0; i < rowCount; i++) {
			var row = this.CurPage()[i];
			var charCount = (i == rowIndex) ? charIndex+1 : row.length;
			// console.log(charCount);

			var leftPos = 0;
			if (textDirection === TextDirection.RightToLeft) {
				leftPos = 24 * 8; // hack -- I think this is correct?
			}

			for(var j = 0; j < charCount; j++) {
				var char = row[j];
				if(char) {
					if (textDirection === TextDirection.RightToLeft) {
						leftPos -= char.spacing;
					}
					// console.log(j + " " + leftPos);

					// handler( char, i /*rowIndex*/, j /*colIndex*/ );
					handler(char, i /*rowIndex*/, j /*colIndex*/, leftPos)

					if (textDirection === TextDirection.LeftToRight) {
						leftPos += char.spacing;
					}
				}
			}
		}
	}

	this.Reset = function() {
		buffer = [[[]]];
		pageIndex = 0;
		rowIndex = 0;
		charIndex = 0;
		isDialogReadyToContinue = false;

		activeTextEffects = [];

		onDialogEndCallbacks = [];

		isActive = false;
	};

	this.DoNextChar = function() {
		// console.log("DO NEXT CHAR");

		nextCharTimer = 0; //reset timer

		//time to update characters
		if (charIndex + 1 < this.CurCharCount()) {
			//add char to current row
			charIndex++;
		}
		else if (rowIndex + 1 < this.CurRowCount()) {
			//start next row
			rowIndex++;
			charIndex = 0;
		}
		else {
			//the page is full!
			isDialogReadyToContinue = true;
			didPageFinishThisFrame = true;

			// console.log("WAITING FOR INPUT");
		}

		// console.log(this.CurChar());
		if(this.CurChar() != null)
			this.CurChar().OnPrint(); // make sure we hit the callback before we run out of text
	};

	this.Update = function(dt) {
		didPageFinishThisFrame = false;
		didFlipPageThisFrame = false;
		// this.Draw(dt); // TODO move into a renderer object
		if (isDialogReadyToContinue) {
			return; //waiting for dialog to be advanced by player
		}

		nextCharTimer += dt; //tick timer

		if (nextCharTimer > nextCharMaxTime) {
			this.DoNextChar();
		}
	};

	this.Skip = function() {
		console.log("SKIPPP");
		didPageFinishThisFrame = false;
		didFlipPageThisFrame = false;
		// add new characters until you get to the end of the current line of dialog
		while (rowIndex < this.CurRowCount()) {
			this.DoNextChar();

			if(isDialogReadyToContinue) {
				//make sure to push the rowIndex past the end to break out of the loop
				rowIndex++;
				charIndex = 0;
			}
		}
		rowIndex = this.CurRowCount()-1;
		charIndex = this.CurCharCount()-1;
	};

	this.FlipPage = function() {
		didFlipPageThisFrame = true;
		isDialogReadyToContinue = false;
		pageIndex++;
		rowIndex = 0;
		charIndex = 0;
	}

	this.EndDialog = function() {
		isActive = false; // no more text to show... this should be a sign to stop rendering dialog

		for (var i = 0; i < onDialogEndCallbacks.length; i++) {
			onDialogEndCallbacks[i]();
		}
	}

	this.Continue = function() {
		console.log("CONTINUE");
		if (pageIndex + 1 < this.CurPageCount()) {
			//start next page
			this.FlipPage();
			return true; /* hasMoreDialog */
		}
		else {
			//end dialog mode
			this.EndDialog();
			return false; /* hasMoreDialog */
		}
	};

	var isActive = false;
	this.IsActive = function() { return isActive; };

	this.OnDialogEnd = function(callback) {
		if (!isActive) {
			callback();
		}
		else {
			onDialogEndCallbacks.push(callback);
		}
	}

	this.CanContinue = function() { return isDialogReadyToContinue; };

	function DialogChar(effectList) {
		this.effectList = effectList.slice(); // clone effect list (since it can change between chars)

		this.color = { r:255, g:255, b:255, a:255 };
		this.offset = { x:0, y:0 }; // in pixels (screen pixels?)

		this.col = 0;
		this.row = 0;

		this.SetPosition = function(row,col) {
			// console.log("SET POS");
			// console.log(this);
			this.row = row;
			this.col = col;
		}

		this.ApplyEffects = function(time) {
			// console.log("APPLY EFFECTS! " + time);
			for(var i = 0; i < this.effectList.length; i++) {
				var effectName = this.effectList[i];
				// console.log("FX " + effectName);
				TextEffects[ effectName ].DoEffect( this, time );
			}
		}

		var printHandler = null; // optional function to be called once on printing character
		this.SetPrintHandler = function(handler) {
			printHandler = handler;
		}
		this.OnPrint = function() {
			if (printHandler != null) {
				console.log("PRINT HANDLER ---- DIALOG BUFFER");
				printHandler();
				printHandler = null; // only call handler once (hacky)
			}
		}

		this.bitmap = [];
		this.width = 0;
		this.height = 0;
		this.base_offset = { // hacky name
 			x: 0,
			y: 0
		};
		this.spacing = 0;
	}

	function DialogFontChar(font, char, effectList) {
		Object.assign(this, new DialogChar(effectList));

		var charData = font.getChar(char);
		this.bitmap = charData.data;
		this.width = charData.width;
		this.height = charData.height;
		this.base_offset.x = charData.offset.x;
		this.base_offset.y = charData.offset.y;
		this.spacing = charData.spacing;
	}

	function DialogDrawingChar(drawingId, effectList) {
		Object.assign(this, new DialogChar(effectList));

		var imageData = renderer.GetImageSource(drawingId)[0];
		var imageDataFlat = [];
		for (var i = 0; i < imageData.length; i++) {
			// console.log(imageData[i]);
			imageDataFlat = imageDataFlat.concat(imageData[i]);
		}

		this.bitmap = imageDataFlat;
		this.width = 8;
		this.height = 8;
		this.spacing = 8;
	}

	function AddWordToCharArray(charArray,word,effectList) {
		for(var i = 0; i < word.length; i++) {
			charArray.push( new DialogFontChar( font, word[i], effectList ) );
		}
		return charArray;
	}

	function GetCharArrayWidth(charArray) {
		var width = 0;
		for(var i = 0; i < charArray.length; i++) {
			width += charArray[i].spacing;
		}
		return width;
	}

	function GetStringWidth(str) {
		var width = 0;
		for (var i = 0; i < str.length; i++) {
			var charData = font.getChar(str[i]);
			width += charData.spacing;
		}
		return width;
	}

	var pixelsPerRow = 192; // hard-coded fun times!!!

	this.AddDrawing = function(drawingId, onFinishHandler) {
		// console.log("DRAWING ID " + drawingId);

		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		var drawingChar = new DialogDrawingChar(drawingId, activeTextEffects)
		drawingChar.SetPrintHandler( onFinishHandler );

		var rowLength = GetCharArrayWidth(curRowArr);

		// TODO : clean up copy-pasted code here :/
		if (rowLength + drawingChar.spacing  <= pixelsPerRow || rowLength <= 0)
		{
			//stay on same row
			curRowArr.push( drawingChar );
		}
		else if (curRowIndex == 0)
		{
			//start next row
			buffer[ curPageIndex ][ curRowIndex ] = curRowArr;
			buffer[ curPageIndex ].push( [] );
			curRowIndex++;
			curRowArr = buffer[ curPageIndex ][ curRowIndex ];
			curRowArr.push( drawingChar );
		}
		else {
			//start next page
			buffer[ curPageIndex ][ curRowIndex ] = curRowArr;
			buffer.push( [] );
			curPageIndex++;
			buffer[ curPageIndex ].push( [] );
			curRowIndex = 0;
			curRowArr = buffer[ curPageIndex ][ curRowIndex ];
			curRowArr.push( drawingChar );
		}

		isActive = true; // this feels like a bad way to do this???
	}

	// TODO : convert this into something that takes DialogChar arrays
	this.AddText = function(textStr,onFinishHandler) {
		// console.log("ADD TEXT " + textStr);

		//process dialog so it's easier to display
		var words = textStr.split(" ");

		// var curPageIndex = this.CurPageCount() - 1;
		// var curRowIndex = this.CurRowCount() - 1;
		// var curRowArr = this.CurRow();

		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		for (var i = 0; i < words.length; i++) {
			var word = words[i];
			if (arabicHandler.ContainsArabicCharacters(word)) {
				word = arabicHandler.ShapeArabicCharacters(word);
			}

			var wordWithPrecedingSpace = ((i == 0) ? "" : " ") + word;
			var wordLength = GetStringWidth( wordWithPrecedingSpace );

			var rowLength = GetCharArrayWidth(curRowArr);

			if (rowLength + wordLength <= pixelsPerRow || rowLength <= 0) {
				//stay on same row
				curRowArr = AddWordToCharArray( curRowArr, wordWithPrecedingSpace, activeTextEffects );
			}
			else if (curRowIndex == 0) {
				//start next row
				buffer[ curPageIndex ][ curRowIndex ] = curRowArr;
				buffer[ curPageIndex ].push( [] );
				curRowIndex++;
				curRowArr = buffer[ curPageIndex ][ curRowIndex ];
				curRowArr = AddWordToCharArray( curRowArr, word, activeTextEffects );
			}
			else {
				//start next page
				buffer[ curPageIndex ][ curRowIndex ] = curRowArr;
				buffer.push( [] );
				curPageIndex++;
				buffer[ curPageIndex ].push( [] );
				curRowIndex = 0;
				curRowArr = buffer[ curPageIndex ][ curRowIndex ];
				curRowArr = AddWordToCharArray( curRowArr, word, activeTextEffects );
			}
		}

		//destroy any empty stuff
		var lastPage = buffer[ buffer.length-1 ];
		var lastRow = lastPage[ lastPage.length-1 ];
		if( lastRow.length == 0 )
			lastPage.splice( lastPage.length-1, 1 );
		if( lastPage.length == 0 )
			buffer.splice( buffer.length-1, 1 );

		//finish up 
		lastPage = buffer[ buffer.length-1 ];
		lastRow = lastPage[ lastPage.length-1 ];
		if( lastRow.length > 0 ) {
			var lastChar = lastRow[ lastRow.length-1 ];
			lastChar.SetPrintHandler( onFinishHandler );
		}

		console.log(buffer);

		isActive = true;
	};

	this.AddLinebreak = function() {
		var lastPage = buffer[ buffer.length-1 ];
		if( lastPage.length <= 1 ) {
			console.log("LINEBREAK - NEW ROW ");
			// add new row
			lastPage.push( [] );
		}
		else {
			// add new page
			buffer.push( [[]] );
		}
		console.log(buffer);

		isActive = true;
	}

	/* new text effects */
	this.HasTextEffect = function(name) {
		return activeTextEffects.indexOf( name ) > -1;
	}
	this.AddTextEffect = function(name) {
		activeTextEffects.push( name );
	}
	this.RemoveTextEffect = function(name) {
		activeTextEffects.splice( activeTextEffects.indexOf( name ), 1 );
	}

	/* this is a hook for GIF rendering */
	var didPageFinishThisFrame = false;
	this.DidPageFinishThisFrame = function(){ return didPageFinishThisFrame; };

	var didFlipPageThisFrame = false;
	this.DidFlipPageThisFrame = function(){ return didFlipPageThisFrame; };

	// this.SetCharsPerRow = function(num){ charsPerRow = num; }; // hacky
};

/* ARABIC */
var ArabicHandler = function() {

	var arabicCharStart = 0x0621;
	var arabicCharEnd = 0x064E;

	var CharacterForm = {
		Isolated : 0,
		Final : 1,
		Initial : 2,
		Middle : 3
	};

	// map glyphs to their character forms
	var glyphForms = {
		/*		 Isolated, Final, Initial, Middle Forms	*/
		0x0621: [0xFE80,0xFE80,0xFE80,0xFE80], /*  HAMZA  */ 
		0x0622: [0xFE81,0xFE82,0xFE81,0xFE82], /*  ALEF WITH MADDA ABOVE  */ 
		0x0623: [0xFE83,0xFE84,0xFE83,0xFE84], /*  ALEF WITH HAMZA ABOVE  */ 
		0x0624: [0xFE85,0xFE86,0xFE85,0xFE86], /*  WAW WITH HAMZA ABOVE  */ 
		0x0625: [0xFE87,0xFE88,0xFE87,0xFE88], /*  ALEF WITH HAMZA BELOW  */ 
		0x0626: [0xFE89,0xFE8A,0xFE8B,0xFE8C], /*  YEH WITH HAMZA ABOVE  */ 
		0x0627: [0xFE8D,0xFE8E,0xFE8D,0xFE8E], /*  ALEF  */ 
		0x0628: [0xFE8F,0xFE90,0xFE91,0xFE92], /*  BEH  */ 
		0x0629: [0xFE93,0xFE94,0xFE93,0xFE94], /*  TEH MARBUTA  */ 
		0x062A: [0xFE95,0xFE96,0xFE97,0xFE98], /*  TEH  */ 
		0x062B: [0xFE99,0xFE9A,0xFE9B,0xFE9C], /*  THEH  */ 
		0x062C: [0xFE9D,0xFE9E,0xFE9F,0xFEA0], /*  JEEM  */ 
		0x062D: [0xFEA1,0xFEA2,0xFEA3,0xFEA4], /*  HAH  */ 
		0x062E: [0xFEA5,0xFEA6,0xFEA7,0xFEA8], /*  KHAH  */ 
		0x062F: [0xFEA9,0xFEAA,0xFEA9,0xFEAA], /*  DAL  */ 
		0x0630: [0xFEAB,0xFEAC,0xFEAB,0xFEAC], /*  THAL */ 
		0x0631: [0xFEAD,0xFEAE,0xFEAD,0xFEAE], /*  RAA  */ 
		0x0632: [0xFEAF,0xFEB0,0xFEAF,0xFEB0], /*  ZAIN  */ 
		0x0633: [0xFEB1,0xFEB2,0xFEB3,0xFEB4], /*  SEEN  */ 
		0x0634: [0xFEB5,0xFEB6,0xFEB7,0xFEB8], /*  SHEEN  */ 
		0x0635: [0xFEB9,0xFEBA,0xFEBB,0xFEBC], /*  SAD  */ 
		0x0636: [0xFEBD,0xFEBE,0xFEBF,0xFEC0], /*  DAD  */ 
		0x0637: [0xFEC1,0xFEC2,0xFEC3,0xFEC4], /*  TAH  */ 
		0x0638: [0xFEC5,0xFEC6,0xFEC7,0xFEC8], /*  ZAH  */ 
		0x0639: [0xFEC9,0xFECA,0xFECB,0xFECC], /*  AIN  */ 
		0x063A: [0xFECD,0xFECE,0xFECF,0xFED0], /*  GHAIN  */ 
		0x063B: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063C: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063D: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063E: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063F: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x0640: [0x0640,0x0640,0x0640,0x0640], /*  TATWEEL  */ 
		0x0641: [0xFED1,0xFED2,0xFED3,0xFED4], /*  FAA  */ 
		0x0642: [0xFED5,0xFED6,0xFED7,0xFED8], /*  QAF  */ 
		0x0643: [0xFED9,0xFEDA,0xFEDB,0xFEDC], /*  KAF  */ 
		0x0644: [0xFEDD,0xFEDE,0xFEDF,0xFEE0], /*  LAM  */ 
		0x0645: [0xFEE1,0xFEE2,0xFEE3,0xFEE4], /*  MEEM  */ 
		0x0646: [0xFEE5,0xFEE6,0xFEE7,0xFEE8], /*  NOON  */ 
		0x0647: [0xFEE9,0xFEEA,0xFEEB,0xFEEC], /*  HEH  */ 
		0x0648: [0xFEED,0xFEEE,0xFEED,0xFEEE], /*  WAW  */ 
		0x0649: [0xFEEF,0xFEF0,0xFBE8,0xFBE9], /*  ALEF MAKSURA  */ 
		0x064A: [0xFEF1,0xFEF2,0xFEF3,0xFEF4], /*  YEH  */ 
		0x064B: [0xFEF5,0xFEF6,0xFEF5,0xFEF6], /*  LAM ALEF MADD*/
		0x064C: [0xFEF7,0xFEF8,0xFEF7,0xFEF8], /*  LAM ALEF HAMZA ABOVE*/
		0x064D: [0xFEF9,0xFEFa,0xFEF9,0xFEFa], /*  LAM ALEF HAMZA BELOW*/
		0x064E: [0xFEFb,0xFEFc,0xFEFb,0xFEFc], /*  LAM ALEF */
	};

	var disconnectedCharacters = [0x0621,0x0622,0x0623,0x0624,0x0625,0x0627,0x062f,0x0630,0x0631,0x0632,0x0648,0x0649,0x064b,0x064c,0x064d,0x064e];

	function IsArabicCharacter(char) {
		var code = char.charCodeAt(0);
		return (code >= arabicCharStart && code <= arabicCharEnd);
	}

	function ContainsArabicCharacters(word) {
		for (var i = 0; i < word.length; i++) {
			if (IsArabicCharacter(word[i])) {
				return true;
			}
		}
		return false;
	}

	function IsDisconnectedCharacter(char) {
		var code = char.charCodeAt(0);
		return disconnectedCharacters.indexOf(code) != -1;
	}

	function ShapeArabicCharacters(word) {
		var shapedWord = "";

		for (var i = 0; i < word.length; i++) {
			if (!IsArabicCharacter(word[i])) {
				shapedWord += word[i];
				continue;
			}

			var connectedToPreviousChar = i-1 >= 0 && IsArabicCharacter(word[i-1]) && !IsDisconnectedCharacter(word[i-1]);

			var connectedToNextChar = i+1 < word.length && IsArabicCharacter(word[i+1]) && !IsDisconnectedCharacter(word[i]);

			var form;
			if (!connectedToPreviousChar && !connectedToNextChar) {
				form = CharacterForm.Isolated;
			}
			else if (connectedToPreviousChar && !connectedToNextChar) {
				form = CharacterForm.Final;
			}
			else if (!connectedToPreviousChar && connectedToNextChar) {
				form = CharacterForm.Initial;
			}
			else if (connectedToPreviousChar && connectedToNextChar) {
				form = CharacterForm.Middle;
			}

			var code = word[i].charCodeAt(0);

			// handle lam alef special case
			if (code == 0x0644 && connectedToNextChar) {
				var nextCode = word[i+1].charCodeAt(0);
				var specialCode = null;
				if (nextCode == 0x0622) {
					// alef madd
					specialCode = glyphForms[0x064b][form];
				}
				else if (nextCode == 0x0623) {
					// hamza above
					specialCode = glyphForms[0x064c][form];
				}
				else if (nextCode == 0x0625) {
					// hamza below
					specialCode = glyphForms[0x064d][form];
				}
				else if (nextCode == 0x0627) {
					// alef
					specialCode = glyphForms[0x064e][form];
				}

				if (specialCode != null) {
					shapedWord += String.fromCharCode(specialCode);
					i++; // skip a step
					continue;
				}
			}

			// hacky?
			if (form === CharacterForm.Isolated) {
				shapedWord += word[i];
				continue;
			}

			var shapedCode = glyphForms[code][form];
			shapedWord += String.fromCharCode(shapedCode);
		}

		return shapedWord;
	}

	this.ContainsArabicCharacters = ContainsArabicCharacters;
	this.ShapeArabicCharacters = ShapeArabicCharacters;
}

/* NEW TEXT EFFECTS */
var TextEffects = new Map();

var RainbowEffect = function() { // TODO - should it be an object or just a method?
	this.DoEffect = function(char,time) {
		// console.log("RAINBOW!!!");
		// console.log(char);
		// console.log(char.color);
		// console.log(char.col);

		var h = Math.abs( Math.sin( (time / 600) - (char.col / 8) ) );
		var rgb = hslToRgb( h, 1, 0.5 );
		char.color.r = rgb[0];
		char.color.g = rgb[1];
		char.color.b = rgb[2];
		char.color.a = 255;
	}
};
TextEffects["rbw"] = new RainbowEffect();

var ColorEffect = function(index) {
	this.DoEffect = function(char) {
		var pal = getPal( curPal() );
		var color = pal[ parseInt( index ) ];
		// console.log(color);
		char.color.r = color[0];
		char.color.g = color[1];
		char.color.b = color[2];
		char.color.a = 255;
	}
};
TextEffects["clr1"] = new ColorEffect(0);
TextEffects["clr2"] = new ColorEffect(1); // TODO : should I use parameters instead of special names?
TextEffects["clr3"] = new ColorEffect(2);

var WavyEffect = function() {
	this.DoEffect = function(char,time) {
		char.offset.y += Math.sin( (time / 250) - (char.col / 2) ) * 4;
	}
};
TextEffects["wvy"] = new WavyEffect();

var ShakyEffect = function() {
	function disturb(func,time,offset,mult1,mult2) {
		return func( (time * mult1) - (offset * mult2) );
	}

	this.DoEffect = function(char,time) {
		char.offset.y += 3
						* disturb(Math.sin,time,char.col,0.1,0.5)
						* disturb(Math.cos,time,char.col,0.3,0.2)
						* disturb(Math.sin,time,char.row,2.0,1.0);
		char.offset.x += 3
						* disturb(Math.cos,time,char.row,0.1,1.0)
						* disturb(Math.sin,time,char.col,3.0,0.7)
						* disturb(Math.cos,time,char.col,0.2,0.3);
	}
};
TextEffects["shk"] = new ShakyEffect();

} // Dialog()
</script>

<script>
/*
TODO
- reset renderer function
- react to changes in: drawings, palettes
- possible future plan: limit size of cache (remove old images)
- change image store path from (pal > col > draw) to (draw > pal > col)
- get rid of old getSpriteImage (etc) methods
- get editor working again [in progress]
- move debug timer class into core (seems useful)
*/

function Renderer(tilesize, scale) {

console.log("!!!!! NEW RENDERER");

var imageStore = { // TODO : rename to imageCache
	source: {},
	render: {}
};

var palettes = null; // TODO : need null checks?
var context = null;

function setPalettes(paletteObj) {
	palettes = paletteObj;

	// TODO : should this really clear out the render cache?
	imageStore.render = {};
}

function getPaletteColor(paletteId, colorIndex) {
	if (palettes[paletteId] === undefined) {
		paletteId = "default";
	}

	var palette = palettes[paletteId];

	if (colorIndex > palette.colors.length) { // do I need this failure case? (seems un-reliable)
		colorIndex = 0;
	}

	var color = palette.colors[colorIndex];

	return {
		r : color[0],
		g : color[1],
		b : color[2]
	};
}

var debugRenderCount = 0;

// TODO : change image store path from (pal > col > draw) to (draw > pal > col)
function renderImage(drawing, paletteId) {
	// debugRenderCount++;
	// console.log("RENDER COUNT " + debugRenderCount);

	var col = drawing.col;
	var colStr = "" + col;
	var pal = paletteId;
	var drwId = drawing.drw;
	var imgSrc = imageStore.source[ drawing.drw ];

	// initialize render cache entry
	if (imageStore.render[drwId] === undefined || imageStore.render[drwId] === null) {
		imageStore.render[drwId] = {};
	}

	if (imageStore.render[drwId][pal] === undefined || imageStore.render[drwId][pal] === null) {
		imageStore.render[drwId][pal] = {};
	}

	// create array of ImageData frames
	imageStore.render[drwId][pal][colStr] = [];

	for (var i = 0; i < imgSrc.length; i++) {
		var frameSrc = imgSrc[i];
		var frameData = imageDataFromImageSource( frameSrc, pal, col );
		imageStore.render[drwId][pal][colStr].push(frameData);
	}
}

function imageDataFromImageSource(imageSource, pal, col) {
	//console.log(imageSource);

	var img = context.createImageData(tilesize*scale,tilesize*scale);

	var backgroundColor = getPaletteColor(pal,0);
	var foregroundColor = getPaletteColor(pal,col);

	for (var y = 0; y < tilesize; y++) {
		for (var x = 0; x < tilesize; x++) {
			var px = imageSource[y][x];
			for (var sy = 0; sy < scale; sy++) {
				for (var sx = 0; sx < scale; sx++) {
					var pxl = (((y * scale) + sy) * tilesize * scale * 4) + (((x*scale) + sx) * 4);
					if ( px === 1 ) {
						img.data[pxl + 0] = foregroundColor.r;
						img.data[pxl + 1] = foregroundColor.g;
						img.data[pxl + 2] = foregroundColor.b;
						img.data[pxl + 3] = 255;
					}
					else { //ch === 0
						img.data[pxl + 0] = backgroundColor.r;
						img.data[pxl + 1] = backgroundColor.g;
						img.data[pxl + 2] = backgroundColor.b;
						img.data[pxl + 3] = 255;
					}
				}
			}
		}
	}

	// convert to canvas: chrome has poor performance when working directly with image data
	var imageCanvas = document.createElement("canvas");
	imageCanvas.width = img.width;
	imageCanvas.height = img.height;
	var imageContext = imageCanvas.getContext("2d");
	imageContext.putImageData(img,0,0);

	return imageCanvas;
}

// TODO : move into core
function undefinedOrNull(x) {
	return x === undefined || x === null;
}

function isImageRendered(drawing, paletteId) {
	var col = drawing.col;
	var colStr = "" + col;
	var pal = paletteId;
	var drwId = drawing.drw;

	if (undefinedOrNull(imageStore.render[drwId]) ||
		undefinedOrNull(imageStore.render[drwId][pal]) ||
		undefinedOrNull(imageStore.render[drwId][pal][colStr])) {
			return false;
	}
	else {
		return true;
	}
}

function getImageSet(drawing, paletteId) {
	return imageStore.render[drawing.drw][paletteId][drawing.col];
}

function getImageFrame(drawing, paletteId, frameOverride) {
	var frameIndex = 0;
	if (drawing.animation.isAnimated) {
		if (frameOverride != undefined && frameOverride != null) {
			frameIndex = frameOverride;
		}
		else {
			frameIndex = drawing.animation.frameIndex;
		}
	}

	return getImageSet(drawing, paletteId)[frameIndex];
}

function getOrRenderImage(drawing, paletteId, frameOverride) {
	if (!isImageRendered(drawing, paletteId)) {
		renderImage(drawing, paletteId);
	}

	return getImageFrame(drawing, paletteId, frameOverride);
}

/* PUBLIC INTERFACE */
this.GetImage = getOrRenderImage;

this.SetPalettes = setPalettes;

this.SetImageSource = function(drawingId, imageSourceData) {
	imageStore.source[drawingId] = imageSourceData;
	imageStore.render[drawingId] = {}; // reset render cache for this image
}

this.GetImageSource = function(drawingId) {
	return imageStore.source[drawingId];
}

this.GetFrameCount = function(drawingId) {
	return imageStore.source[drawingId].length;
}

this.AttachContext = function(ctx) {
	context = ctx;
}

} // Renderer()
</script>

<script>
var xhr; // TODO : remove
var canvas;
var context; // TODO : remove if safe?
var ctx;

var title = "";
var room = {};
var tile = {};
var sprite = {};
var item = {};
var dialog = {};
var palette = { //start off with a default palette
		"default" : {
			name : "default",
			colors : [[0,0,0],[255,255,255],[255,255,255]]
		}
	};
var ending = {};
var variable = {}; // these are starting variable values -- they don't update (or I don't think they will)
var playerId = "A";

var defaultFontName = "ascii_small";
var fontName = defaultFontName;
var TextDirection = {
	LeftToRight : "LTR",
	RightToLeft : "RTL"
};
var textDirection = TextDirection.LeftToRight;

var names = {
	room : new Map(),
	tile : new Map(), // Note: Not currently enabled in the UI
	sprite : new Map(),
	item : new Map(),
	/*dialog : new Map()*/ // TODO
	/*ending : new Map()*/ // TODO
};
function updateNamesFromCurData() {
	names.room = new Map();
	for(id in room) {
		if(room[id].name != undefined && room[id].name != null) {
			names.room.set( room[id].name, id );
		}
	}
	names.tile = new Map();
	for(id in tile) {
		if(tile[id].name != undefined && tile[id].name != null) {
			names.tile.set( tile[id].name, id );
		}
	}
	names.sprite = new Map();
	for(id in sprite) {
		if(sprite[id].name != undefined && sprite[id].name != null) {
			names.sprite.set( sprite[id].name, id );
		}
	}
	names.item = new Map();
	for(id in item) {
		if(item[id].name != undefined && item[id].name != null) {
			names.item.set( item[id].name, id );
		}
	}
}

var spriteStartLocations = {};

/* VERSION */
var version = {
	major: 6, // major changes
	minor: 3 // smaller changes
};
function getEngineVersion() {
	return version.major + "." + version.minor;
}

/* FLAGS */
var flags;
function resetFlags() {
	flags = {
		ROOM_FORMAT : 0 // 0 = non-comma separated, 1 = comma separated
	};
}
resetFlags(); //init flags on load script

// SUPER hacky location... :/
var editorDevFlags = {
	// NONE right now!
};

function clearGameData() {
	title = "";
	room = {};
	tile = {};
	sprite = {};
	item = {};
	dialog = {};
	palette = { //start off with a default palette
		"default" : {
			name : "default",
			colors : [[0,0,0],[255,255,255],[255,255,255]]
		}
	};
	ending = {};
	isEnding = false; //todo - correct place for this?
	variable = {};

	// TODO RENDERER : clear data?

	spriteStartLocations = {};

	names = {
		room : new Map(),
		tile : new Map(),
		sprite : new Map(),
		item : new Map()
	};

	fontName = defaultFontName; // TODO : reset font manager too?
	textDirection = TextDirection.LeftToRight;
}

var width = 128;
var height = 128;
var scale = 4; //this is stupid but necessary
var tilesize = 8;
var mapsize = 16;

var curRoom = "0";

var key = {
	left : 37,
	right : 39,
	up : 38,
	down : 40,
	space : 32,
	enter : 13,
	w : 87,
	a : 65,
	s : 83,
	d : 68,
	r : 82,
	shift : 16,
	ctrl : 17,
	alt : 18,
	cmd : 224
};

var prevTime = 0;
var deltaTime = 0;

//methods used to trigger gif recording
var didPlayerMoveThisFrame = false;
var onPlayerMoved = null;
// var didDialogUpdateThisFrame = false;
var onDialogUpdate = null;

//inventory update UI handles
var onInventoryChanged = null;
var onVariableChanged = null;
var onGameReset = null;

var isPlayerEmbeddedInEditor = false;

var renderer = new Renderer(tilesize, scale);

function getGameNameFromURL() {
	var game = window.location.hash.substring(1);
	// console.log("game name --- " + game);
	return game;
}

function attachCanvas(c) {
	canvas = c;
	canvas.width = width * scale;
	canvas.height = width * scale;
	ctx = canvas.getContext("2d");
	dialogRenderer.AttachContext(ctx);
	renderer.AttachContext(ctx);
}

var curGameData = null;
function load_game(game_data, startWithTitle) {
	curGameData = game_data; //remember the current game (used to reset the game)

	dialogBuffer.Reset();
	scriptInterpreter.ResetEnvironment(); // ensures variables are reset -- is this the best way?

	parseWorld(game_data);

	if (!isPlayerEmbeddedInEditor) {
		// hack to ensure default font is available
		fontManager.AddResource(defaultFontName + fontManager.GetExtension(), document.getElementById(defaultFontName).text.slice(1));
	}

	var font = fontManager.Get( fontName );
	dialogBuffer.SetFont(font);
	dialogRenderer.SetFont(font);

	setInitialVariables();

	// setInterval(updateLoadingScreen, 300); // hack test

	onready(startWithTitle);
}

function reset_cur_game() {
	if (curGameData == null) {
		return; //can't reset if we don't have the game data
	}

	stopGame();
	clearGameData();
	load_game(curGameData);

	if (isPlayerEmbeddedInEditor && onGameReset != null) {
		onGameReset();
	}
}

var update_interval = null;
function onready(startWithTitle) {
	if(startWithTitle === undefined || startWithTitle === null) startWithTitle = true;

	clearInterval(loading_interval);

	input = new InputManager();

	document.addEventListener('keydown', input.onkeydown);
	document.addEventListener('keyup', input.onkeyup);

	if (isPlayerEmbeddedInEditor) {
		canvas.addEventListener('touchstart', input.ontouchstart);
		canvas.addEventListener('touchmove', input.ontouchmove);
		canvas.addEventListener('touchend', input.ontouchend);
	}
	else {
		document.addEventListener('touchstart', input.ontouchstart);
		document.addEventListener('touchmove', input.ontouchmove);
		document.addEventListener('touchend', input.ontouchend);
	}

	window.onblur = input.onblur;

	update_interval = setInterval(update,16);

	if(startWithTitle) { // used by editor 
		startNarrating(title);
	}
}

function setInitialVariables() {
	for(id in variable) {
		var value = variable[id]; // default to string
		if(value === "true") {
			value = true;
		}
		else if(value === "false") {
			value = false;
		}
		else if(!isNaN(parseFloat(value))) {
			value = parseFloat(value);
		}
		scriptInterpreter.SetVariable(id,value);
	}
	scriptInterpreter.SetOnVariableChangeHandler( onVariableChanged );
}

// TODO: this is likely broken
function breadthFirstSearch(map, from, to) {
	from.trail = [];
	var visited = [];
	var queue = [from];
	visited.push( posToString(from) );

	//console.log( "~ bfs ~");
	//console.log( posToString(from) + " to " + posToString(to) );

	while ( queue.length > 0 ) {

		//grab pos from queue and mark as visited
		var curPos = queue.shift();

		//console.log( posToString(curPos) );
		//console.log( ".. " + pathToString(curPos.trail) );
		//console.log( visited );

		if (curPos.x == to.x && curPos.y == to.y) {
			//found a path!
			var path = curPos.trail.splice(0);
			path.push( curPos );
			return path;
		}

		//look at neighbors
		neighbors(curPos).forEach( function(n) {
			var inBounds = (n.x >= 0 && n.x < 16 && n.y >= 0 && n.y < 16);
			if (inBounds) {
				var noCollision = map[n.y][n.x] <= 0;
				var notVisited = visited.indexOf( posToString(n) ) == -1;
				if (noCollision && notVisited) {
					n.trail = curPos.trail.slice();
					n.trail.push(curPos);
					queue.push( n );
					visited.push( posToString(n) );
				}
			}
		});

	}

	return []; // no path found
}

function posToString(pos) {
	return pos.x + "," + pos.y;
}

function pathToString(path) {
	var s = "";
	for (i in path) {
		s += posToString(path[i]) + " ";
	}
	return s;
}

function neighbors(pos) {
	var neighborList = [];
	neighborList.push( {x:pos.x+1, y:pos.y+0} );
	neighborList.push( {x:pos.x-1, y:pos.y+0} );
	neighborList.push( {x:pos.x+0, y:pos.y+1} );
	neighborList.push( {x:pos.x+0, y:pos.y-1} );
	return neighborList;
}

function collisionMap(roomId) {
	var map = [
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
	];

	for (r in room[roomId].tilemap) {
		var row = room[roomId].tilemap[r];
		for (var c = 0; c < row.length; c++) {
			if (room[roomId].walls.indexOf( row[x] ) != -1) {
				map[r][c] = 1;
			}
		}
	}

	for (id in sprite) {
		var spr = sprite[id];
		if (spr.room === roomId) {
			map[spr.y][spr.x] = 2;
		}
	}

	return map;
}

function getOffset(evt) {
	var offset = { x:0, y:0 };

	var el = evt.target;
	var rect = el.getBoundingClientRect();

	offset.x += rect.left + el.scrollLeft;
	offset.y += rect.top + el.scrollTop;

	offset.x = evt.clientX - offset.x;
	offset.y = evt.clientY - offset.y;

	return offset;
}

function stopGame() {
	console.log("stop GAME!");

	document.removeEventListener('keydown', input.onkeydown);
	document.removeEventListener('keyup', input.onkeyup);

	if (isPlayerEmbeddedInEditor) {
		canvas.removeEventListener('touchstart', input.ontouchstart);
		canvas.removeEventListener('touchmove', input.ontouchmove);
		canvas.removeEventListener('touchend', input.ontouchend);
	}
	else {
		document.removeEventListener('touchstart', input.ontouchstart);
		document.removeEventListener('touchmove', input.ontouchmove);
		document.removeEventListener('touchend', input.ontouchend);
	}

	window.onblur = null;

	clearInterval(update_interval);
}

/* loading animation */
var loading_anim_data = [
	[
		0,1,1,1,1,1,1,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,0,0,1,0,0,
		0,0,1,0,0,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,1,1,1,1,1,1,0,
		0,0,1,0,0,1,0,0,
		0,0,1,1,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,0,0,1,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,1,1,1,1,1,1,0,
		0,0,1,0,0,1,0,0,
		0,0,1,0,0,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,1,1,1,1,1,1,0,
		0,0,1,0,0,1,0,0,
		0,0,1,0,0,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,0,0,0,0,0,0,0,
		1,0,0,0,0,0,0,1,
		1,1,1,0,0,1,1,1,
		1,1,1,1,1,0,0,1,
		1,1,1,1,1,0,0,1,
		1,1,1,0,0,1,1,1,
		1,0,0,0,0,0,0,1,
		0,0,0,0,0,0,0,0,
	]
];
var loading_anim_frame = 0;
var loading_anim_speed = 500;
var loading_interval = null;

function loadingAnimation() {
	//create image
	var loadingAnimImg = ctx.createImageData(8*scale, 8*scale);
	//draw image
	for (var y = 0; y < 8; y++) {
		for (var x = 0; x < 8; x++) {
			var i = (y * 8) + x;
			if (loading_anim_data[loading_anim_frame][i] == 1) {
				//scaling nonsense
				for (var sy = 0; sy < scale; sy++) {
					for (var sx = 0; sx < scale; sx++) {
						var pxl = 4 * ( (((y*scale)+sy) * (8*scale)) + ((x*scale)+sx) );
						loadingAnimImg.data[pxl+0] = 255;
						loadingAnimImg.data[pxl+1] = 255;
						loadingAnimImg.data[pxl+2] = 255;
						loadingAnimImg.data[pxl+3] = 255;
					}
				}
			}
		}
	}
	//put image on canvas
	ctx.putImageData(loadingAnimImg,scale*(width/2 - 4),scale*(height/2 - 4));
	//update frame
	loading_anim_frame++;
	if (loading_anim_frame >= 5) loading_anim_frame = 0;
}

function updateLoadingScreen() {
	// TODO : in progress
	ctx.fillStyle = "rgb(0,0,0)";
	ctx.fillRect(0,0,canvas.width,canvas.height);

	loadingAnimation();
	drawSprite( getSpriteImage(sprite["a"],"0",0), 8, 8, ctx );
}

function update() {
	var curTime = Date.now();
	deltaTime = curTime - prevTime;

	if (curRoom == null) {
		// in the special case where there is no valid room, end the game
		startNarrating( "", true /*isEnding*/ );
	}

	if (!transition.IsTransitionActive()) {
		updateInput();
	}

	if (transition.IsTransitionActive()) {
		// transition animation takes over everything!
		transition.UpdateTransition(deltaTime);
	}
	else {
		if (!isNarrating && !isEnding) {
			updateAnimation();
			drawRoom( room[curRoom] ); // draw world if game has begun
		}
		else {
			//make sure to still clear screen
			ctx.fillStyle = "rgb(" + getPal(curPal())[0][0] + "," + getPal(curPal())[0][1] + "," + getPal(curPal())[0][2] + ")";
			ctx.fillRect(0,0,canvas.width,canvas.height);
		}

		// if (isDialogMode) { // dialog mode
		if(dialogBuffer.IsActive()) {
			dialogRenderer.Draw( dialogBuffer, deltaTime );
			dialogBuffer.Update( deltaTime );
		}
		else if (!isEnding) {
			moveSprites(); // TODO : I probably need to remove this..
		}

		// keep moving avatar if player holds down button
		if( !dialogBuffer.IsActive() && !isEnding )
		{
			if( curPlayerDirection != Direction.None ) {
				playerHoldToMoveTimer -= deltaTime;

				if( playerHoldToMoveTimer <= 0 )
				{
					movePlayer( curPlayerDirection );
					playerHoldToMoveTimer = 150;
				}
			}
		}
	}

	prevTime = curTime;

	//for gif recording
	if (didPlayerMoveThisFrame && onPlayerMoved != null) {
		onPlayerMoved();
	}
	didPlayerMoveThisFrame = false;

	/* hacky replacement */
	if (onDialogUpdate != null) {
		dialogRenderer.SetPageFinishHandler( onDialogUpdate );
	}

	input.resetKeyPressed();
	input.resetTapReleased();
}

function updateInput() {
	if( dialogBuffer.IsActive() ) {
		if (input.anyKeyPressed() || input.isTapReleased()) {
			/* CONTINUE DIALOG */
			if (dialogBuffer.CanContinue()) {
				var hasMoreDialog = dialogBuffer.Continue();
				if(!hasMoreDialog) {
					// ignore currently held keys UNTIL they are released (stops player from insta-moving)
					input.ignoreHeldKeys();
				}
			}
			else {
				dialogBuffer.Skip();
			}
		}
	}
	else if ( isEnding ) {
		if (input.anyKeyPressed() || input.isTapReleased()) {
			/* RESTART GAME */
			reset_cur_game();
		}
	}
	else {
		/* WALK */
		var prevPlayerDirection = curPlayerDirection;

		if ( input.isKeyDown( key.left ) || input.isKeyDown( key.a ) || input.swipeLeft() ) {
			curPlayerDirection = Direction.Left;
		}
		else if ( input.isKeyDown( key.right ) || input.isKeyDown( key.d ) || input.swipeRight() ) {
			curPlayerDirection = Direction.Right;
		}
		else if ( input.isKeyDown( key.up ) || input.isKeyDown( key.w ) || input.swipeUp() ) {
			curPlayerDirection = Direction.Up;
		}
		else if ( input.isKeyDown( key.down ) || input.isKeyDown( key.s ) || input.swipeDown() ) {
			curPlayerDirection = Direction.Down;
		}
		else {
			curPlayerDirection = Direction.None;
		}

		if (curPlayerDirection != Direction.None && curPlayerDirection != prevPlayerDirection) {
			movePlayer( curPlayerDirection );
			playerHoldToMoveTimer = 500;
		}
	}
}

var animationCounter = 0;
var animationTime = 400;
function updateAnimation() {
	animationCounter += deltaTime;

	if ( animationCounter >= animationTime ) {

		// animate sprites
		for (id in sprite) {
			var spr = sprite[id];
			if (spr.animation.isAnimated) {
				spr.animation.frameIndex = ( spr.animation.frameIndex + 1 ) % spr.animation.frameCount;
			}
		}

		// animate tiles
		for (id in tile) {
			var til = tile[id];
			if (til.animation.isAnimated) {
				til.animation.frameIndex = ( til.animation.frameIndex + 1 ) % til.animation.frameCount;
			}
		}

		// animate items
		for (id in item) {
			var itm = item[id];
			if (itm.animation.isAnimated) {
				itm.animation.frameIndex = ( itm.animation.frameIndex + 1 ) % itm.animation.frameCount;
			}
		}

		// reset counter
		animationCounter = 0;

	}
}

function resetAllAnimations() {
	for (id in sprite) {
		var spr = sprite[id];
		if (spr.animation.isAnimated) {
			spr.animation.frameIndex = 0;
		}
	}

	for (id in tile) {
		var til = tile[id];
		if (til.animation.isAnimated) {
			til.animation.frameIndex = 0;
		}
	}

	for (id in item) {
		var itm = item[id];
		if (itm.animation.isAnimated) {
			itm.animation.frameIndex = 0;
		}
	}
}

var moveCounter = 0;
var moveTime = 200;
function moveSprites() {
	moveCounter += deltaTime;

	if (moveCounter >= moveTime) {

		for (id in sprite) {
			var spr = sprite[id];
			if (spr.walkingPath.length > 0) {
				//move sprite
				var nextPos = spr.walkingPath.shift();
				spr.x = nextPos.x;
				spr.y = nextPos.y;


				var end = getEnding( spr.room, spr.x, spr.y );
				var ext = getExit( spr.room, spr.x, spr.y );
				var itmIndex = getItemIndex( spr.room, spr.x, spr.y );
				if (end) { //if the sprite hits an ending
					if (id === playerId) { // only the player can end the game
						startNarrating( ending[end.id], true /*isEnding*/ );
					}
				}
				else if (ext) { //if the sprite hits an exit
					//move it to another scene
					spr.room = ext.dest.room;
					spr.x = ext.dest.x;
					spr.y = ext.dest.y;
					if (id === playerId) {
						//if the player changes scenes, change the visible scene
						curRoom = ext.dest.room;
					}
				}
				else if(itmIndex > -1) {
					var itm = room[ spr.room ].items[ itmIndex ];
					room[ spr.room ].items.splice( itmIndex, 1 );
					if( spr.inventory[ itm.id ] ) {
						spr.inventory[ itm.id ] += 1;
					}
					else {
						spr.inventory[ itm.id ] = 1;
					}

					if (onInventoryChanged != null) {
						onInventoryChanged( itm.id );
					}

					if (id === playerId) {
						startItemDialog( itm.id  /*itemId*/ );
					}

					// stop moving : is this a good idea?
					spr.walkingPath = [];
				}

				if (id === playerId) didPlayerMoveThisFrame = true;
			}
		}

		moveCounter = 0;
	}

}

function getSpriteAt(x,y) {
	for (id in sprite) {
		var spr = sprite[id];
		if (spr.room === curRoom) {
			if (spr.x == x && spr.y == y) {
				return id;
			}
		}
	}
	return null;
}

var Direction = {
	None : -1,
	Up : 0,
	Down : 1,
	Left : 2,
	Right : 3
};

var curPlayerDirection = Direction.None;
var playerHoldToMoveTimer = 0;

var InputManager = function() {
	var self = this;

	var pressed;
	var ignored;
	var newKeyPress;
	var touchState;

	function resetAll() {
		pressed = {};
		ignored = {};
		newKeyPress = false;

		touchState = {
			isDown : false,
			startX : 0,
			startY : 0,
			curX : 0,
			curY : 0,
			swipeDistance : 30,
			swipeDirection : Direction.None,
			tapReleased : false
		};
	}
	resetAll();

	function stopWindowScrolling(e) {
		if(e.keyCode == key.left || e.keyCode == key.right || e.keyCode == key.up || e.keyCode == key.down || !isPlayerEmbeddedInEditor)
			e.preventDefault();
	}

	function tryRestartGame(e) {
		/* RESTART GAME */
		if ( e.keyCode === key.r && ( e.getModifierState("Control") || e.getModifierState("Meta") ) ) {
			if ( confirm("Restart the game?") ) {
				reset_cur_game();
			}
		}
	}

	function eventIsModifier(event) {
		return (event.keyCode == key.shift || event.keyCode == key.ctrl || event.keyCode == key.alt || event.keyCode == key.cmd);
	}

	function isModifierKeyDown() {
		return ( self.isKeyDown(key.shift) || self.isKeyDown(key.ctrl) || self.isKeyDown(key.alt) || self.isKeyDown(key.cmd) );
	}

	this.ignoreHeldKeys = function() {
		for (var key in pressed) {
			if (pressed[key]) { // only ignore keys that are actually held
				ignored[key] = true;
				// console.log("IGNORE -- " + key);
			}
		}
	}

	this.onkeydown = function(event) {
		// console.log("KEYDOWN -- " + event.keyCode);

		stopWindowScrolling(event);

		tryRestartGame(event);

		// Special keys being held down can interfere with keyup events and lock movement
		// so just don't collect input when they're held
		{
			if (isModifierKeyDown()) {
				return;
			}

			if (eventIsModifier(event)) {
				resetAll();
			}
		}

		if (ignored[event.keyCode]) {
			return;
		}

		if (!self.isKeyDown(event.keyCode)) {
			newKeyPress = true;
		}

		pressed[event.keyCode] = true;
		ignored[event.keyCode] = false;
	}

	this.onkeyup = function(event) {
		// console.log("KEYUP -- " + event.keyCode);
		pressed[event.keyCode] = false;
		ignored[event.keyCode] = false;
	}

	this.ontouchstart = function(event) {
		event.preventDefault();

		if( event.changedTouches.length > 0 ) {
			touchState.isDown = true;

			touchState.startX = touchState.curX = event.changedTouches[0].clientX;
			touchState.startY = touchState.curY = event.changedTouches[0].clientY;

			touchState.swipeDirection = Direction.None;
		}
	}

	this.ontouchmove = function(event) {
		event.preventDefault();

		if( touchState.isDown && event.changedTouches.length > 0 ) {
			touchState.curX = event.changedTouches[0].clientX;
			touchState.curY = event.changedTouches[0].clientY;

			var prevDirection = touchState.swipeDirection;

			if( touchState.curX - touchState.startX <= -touchState.swipeDistance ) {
				touchState.swipeDirection = Direction.Left;
			}
			else if( touchState.curX - touchState.startX >= touchState.swipeDistance ) {
				touchState.swipeDirection = Direction.Right;
			}
			else if( touchState.curY - touchState.startY <= -touchState.swipeDistance ) {
				touchState.swipeDirection = Direction.Up;
			}
			else if( touchState.curY - touchState.startY >= touchState.swipeDistance ) {
				touchState.swipeDirection = Direction.Down;
			}

			if( touchState.swipeDirection != prevDirection ) {
				// reset center so changing directions is easier
				touchState.startX = touchState.curX;
				touchState.startY = touchState.curY;
			}
		}
	}

	this.ontouchend = function(event) {
		event.preventDefault();

		touchState.isDown = false;

		if( touchState.swipeDirection == Direction.None ) {
			// tap!
			touchState.tapReleased = true;
		}

		touchState.swipeDirection = Direction.None;
	}

	this.isKeyDown = function(keyCode) {
		return pressed[keyCode] != null && pressed[keyCode] == true && (ignored[keyCode] == null || ignored[keyCode] == false);
	}

	this.anyKeyPressed = function() {
		return newKeyPress;
	}

	this.resetKeyPressed = function() {
		newKeyPress = false;
	}

	this.swipeLeft = function() {
		return touchState.swipeDirection == Direction.Left;
	}

	this.swipeRight = function() {
		return touchState.swipeDirection == Direction.Right;
	}

	this.swipeUp = function() {
		return touchState.swipeDirection == Direction.Up;
	}

	this.swipeDown = function() {
		return touchState.swipeDirection == Direction.Down;
	}

	this.isTapReleased = function() {
		return touchState.tapReleased;
	}

	this.resetTapReleased = function() {
		touchState.tapReleased = false;
	}

	this.onblur = function() {
		// console.log("~~~ BLUR ~~");
		resetAll();
	}
}
var input = null;

function movePlayer(direction) {
	if (player().room == null || !Object.keys(room).includes(player().room)) {
		return; // player room is missing or invalid.. can't move them!
	}

	var spr = null;

	if ( curPlayerDirection == Direction.Left && !(spr = getSpriteLeft()) && !isWallLeft()) {
		player().x -= 1;
		didPlayerMoveThisFrame = true;
	}
	else if ( curPlayerDirection == Direction.Right && !(spr = getSpriteRight()) && !isWallRight()) {
		player().x += 1;
		didPlayerMoveThisFrame = true;
	}
	else if ( curPlayerDirection == Direction.Up && !(spr = getSpriteUp()) && !isWallUp()) {
		player().y -= 1;
		didPlayerMoveThisFrame = true;
	}
	else if ( curPlayerDirection == Direction.Down && !(spr = getSpriteDown()) && !isWallDown()) {
		player().y += 1;
		didPlayerMoveThisFrame = true;
	}
	
	var ext = getExit( player().room, player().x, player().y );
	var end = getEnding( player().room, player().x, player().y );
	// TODO : vNext
	// var eff = getEffect( player().room, player().x, player().y );
	var itmIndex = getItemIndex( player().room, player().x, player().y );

	// do items first, because you can pick up an item AND go through a door
	if (itmIndex > -1) {
		// TODO pick up items (what about touch?)
		// console.log("HIT ITM ");
		// console.log( itmIndex );
		var itm = room[ player().room ].items[ itmIndex ];
		// console.log(itm);
		room[ player().room ].items.splice( itmIndex, 1 );
		if( player().inventory[ itm.id ] ) {
			player().inventory[ itm.id ] += 1;
		}
		else {
			player().inventory[ itm.id ] = 1;
		}

		if(onInventoryChanged != null) {
			onInventoryChanged( itm.id );
		}

		startItemDialog( itm.id  /*itemId*/ );

		// console.log( player().inventory );
	}

	if (end) {
		startNarrating( ending[end.id], true /*isEnding*/ );
	}
	else if (ext) {
		movePlayerThroughExit(ext);
	}
	// TODO : vNext
	// else if (eff) {
	// 	startDialog( script[eff.id].source, eff.id );
	// }
	else if (spr) {
		startSpriteDialog( spr /*spriteId*/ );
	}
}

var transition = new TransitionManager();

function movePlayerThroughExit(ext) {
	var GoToDest = function() {
		if (ext.transition_effect != null) {
			transition.BeginTransition(player().room, player().x, player().y, ext.dest.room, ext.dest.x, ext.dest.y, ext.transition_effect);
			transition.UpdateTransition(0);
		}

		player().room = ext.dest.room;
		player().x = ext.dest.x;
		player().y = ext.dest.y;
		curRoom = ext.dest.room;
	};

	// TODO : vNext
	// if(ext.script_id != null && script[ext.script_id]){
	// 	var scriptSourceStr = script[ext.script_id].source;
	// 	startDialog(scriptSourceStr, ext.script_id, function(isExitUnlocked) {
	// 		if (isExitUnlocked == true) {
	// 			GoToDest();
	// 		}
	// 	});
	// }
	// else {
	// 	GoToDest();
	// }

	GoToDest();
}

function getItemIndex( roomId, x, y ) {
	for( var i = 0; i < room[roomId].items.length; i++ ) {
		var itm = room[roomId].items[i];
		if ( itm.x == x && itm.y == y)
			return i;
	}
	return -1;
}

function getSpriteLeft() { //repetitive?
	return getSpriteAt( player().x - 1, player().y );
}

function getSpriteRight() {
	return getSpriteAt( player().x + 1, player().y );
}

function getSpriteUp() {
	return getSpriteAt( player().x, player().y - 1 );
}

function getSpriteDown() {
	return getSpriteAt( player().x, player().y + 1 );
}

function isWallLeft() {
	return (player().x - 1 < 0) || isWall( player().x - 1, player().y );
}

function isWallRight() {
	return (player().x + 1 >= 16) || isWall( player().x + 1, player().y );
}

function isWallUp() {
	return (player().y - 1 < 0) || isWall( player().x, player().y - 1 );
}

function isWallDown() {
	return (player().y + 1 >= 16) || isWall( player().x, player().y + 1 );
}

function isWall(x,y,roomId) {
	if(roomId == undefined || roomId == null)
		roomId = curRoom;

	var tileId = getTile( x, y );

	if( tileId === '0' )
		return false; // Blank spaces aren't walls, ya doofus

	if( tile[tileId].isWall === undefined || tile[tileId].isWall === null ) {
		// No wall-state defined: check room-specific walls
		var i = room[roomId].walls.indexOf( getTile(x,y) );
		return i > -1;
	}

	// Otherwise, use the tile's own wall-state
	return tile[tileId].isWall;
}

function getItem(roomId,x,y) {
	for (i in room[roomId].items) {
		var item = room[roomId].items[i];
		if (x == item.x && y == item.y) {
			return item;
		}
	}
	return null;
}

function getExit(roomId,x,y) {
	for (i in room[roomId].exits) {
		var e = room[roomId].exits[i];
		if (x == e.x && y == e.y) {
			return e;
		}
	}
	return null;
}

function getEnding(roomId,x,y) {
	for (i in room[roomId].endings) {
		var e = room[roomId].endings[i];
		if (x == e.x && y == e.y) {
			return e;
		}
	}
	return null;
}

// TODO : vNext
// function getEffect(roomId,x,y) {
// 	for (i in room[roomId].effects) {
// 		var e = room[roomId].effects[i];
// 		if (x == e.x && y == e.y) {
// 			return e;
// 		}
// 	}
// 	return null;
// }

function getTile(x,y) {
	// console.log(x + " " + y);
	var t = getRoom().tilemap[y][x];
	return t;
}

function player() {
	return sprite[playerId];
}

// Sort of a hack for legacy palette code (when it was just an array)
function getPal(id) {
	if (palette[id] === undefined) {
		id = "default";
	}

	return palette[ id ].colors;
}

function getRoom() {
	return room[curRoom];
}

function isSpriteOffstage(id) {
	return sprite[id].room == null;
}

function parseWorld(file) {
	// console.log("~~~ PARSE WORLD ~~~");
	// console.log(file);

	// var parseTimer = new Timer();

	spriteStartLocations = {};

	resetFlags();

	var versionNumber = 0;

	var lines = file.split("\n");
	var i = 0;
	while (i < lines.length) {
		var curLine = lines[i];

		// console.log(lines[i]);

		if (i == 0) {
			i = parseTitle(lines, i);
		}
		else if (curLine.length <= 0 || curLine.charAt(0) === "#") {
			// collect version number (from a comment.. hacky I know)
			if (curLine.indexOf("# BITSY VERSION ") != -1) {
				versionNumber = parseFloat(curLine.replace("# BITSY VERSION ", ""));
			}

			//skip blank lines & comments
			i++;
		}
		else if (getType(curLine) == "PAL") {
			i = parsePalette(lines, i);
		}
		else if (getType(curLine) === "ROOM" || getType(curLine) === "SET") { //SET for back compat
			i = parseRoom(lines, i);
		}
		else if (getType(curLine) === "TIL") {
			i = parseTile(lines, i);
		}
		else if (getType(curLine) === "SPR") {
			i = parseSprite(lines, i);
		}
		else if (getType(curLine) === "ITM") {
			i = parseItem(lines, i);
		}
		else if (getType(curLine) === "DRW") {
			i = parseDrawing(lines, i);
		}
		else if (getType(curLine) === "DLG") {
			i = parseDialog(lines, i);
		}
		else if (getType(curLine) === "END") {
			i = parseEnding(lines, i);
		}
		// TODO: vNext
		// else if (getType(curLine) === "PRG") {
		// 	i = parseScript(lines, i);
		// }
		else if (getType(curLine) === "VAR") {
			i = parseVariable(lines, i);
		}
		else if (getType(curLine) === "DEFAULT_FONT") {
			i = parseFontName(lines, i);
		}
		else if (getType(curLine) === "TEXT_DIRECTION") {
			i = parseTextDirection(lines, i);
		}
		else if (getType(curLine) === "FONT") {
			i = parseFontData(lines, i);
		}
		else if (getType(curLine) === "!") {
			i = parseFlag(lines, i);
		}
		else {
			i++;
		}
	}

	placeSprites();

	var roomIds = Object.keys(room);
	if (player() != undefined && player().room != null && roomIds.includes(player().room)) {
		// player has valid room
		curRoom = player().room;
	}
	else if (roomIds.length > 0) {
		// player not in any room! what the heck
		curRoom = roomIds[0];
	}
	else {
		// uh oh there are no rooms I guess???
		curRoom = null;
	}

	console.log("START ROOM " + curRoom);

	renderer.SetPalettes(palette);

	// console.log(names);

	// console.log("~~~~~ PARSE TIME " + parseTimer.Milliseconds());

	return versionNumber;
}

//TODO this is in progress and doesn't support all features
function serializeWorld(skipFonts) {
	if (skipFonts === undefined || skipFonts === null)
		skipFonts = false;

	var worldStr = "";
	/* TITLE */
	worldStr += title + "\n";
	worldStr += "\n";
	/* VERSION */
	worldStr += "# BITSY VERSION " + getEngineVersion() + "\n"; // add version as a comment for debugging purposes
	worldStr += "\n";
	/* FLAGS */
	for (f in flags) {
		worldStr += "! " + f + " " + flags[f] + "\n";
	}
	worldStr += "\n"
	/* FONT */
	if (fontName != defaultFontName) {
		worldStr += "DEFAULT_FONT " + fontName + "\n";
		worldStr += "\n"
	}
	if (textDirection != TextDirection.LeftToRight) {
		worldStr += "TEXT_DIRECTION " + textDirection + "\n";
		worldStr += "\n"
	}
	/* PALETTE */
	for (id in palette) {
		if (id != "default") {
			worldStr += "PAL " + id + "\n";
			if( palette[id].name != null )
				worldStr += "NAME " + palette[id].name + "\n";
			for (i in getPal(id)) {
				for (j in getPal(id)[i]) {
					worldStr += getPal(id)[i][j];
					if (j < 2) worldStr += ",";
				}
				worldStr += "\n";
			}
			worldStr += "\n";
		}
	}
	/* ROOM */
	for (id in room) {
		worldStr += "ROOM " + id + "\n";
		if ( flags.ROOM_FORMAT == 0 ) {
			// old non-comma separated format
			for (i in room[id].tilemap) {
				for (j in room[id].tilemap[i]) {
					worldStr += room[id].tilemap[i][j];	
				}
				worldStr += "\n";
			}
		}
		else if ( flags.ROOM_FORMAT == 1 ) {
			// new comma separated format
			for (i in room[id].tilemap) {
				for (j in room[id].tilemap[i]) {
					worldStr += room[id].tilemap[i][j];
					if (j < room[id].tilemap[i].length-1) worldStr += ","
				}
				worldStr += "\n";
			}
		}
		if (room[id].name != null) {
			/* NAME */
			worldStr += "NAME " + room[id].name + "\n";
		}
		if (room[id].walls.length > 0) {
			/* WALLS */
			worldStr += "WAL ";
			for (j in room[id].walls) {
				worldStr += room[id].walls[j];
				if (j < room[id].walls.length-1) {
					worldStr += ",";
				}
			}
			worldStr += "\n";
		}
		if (room[id].items.length > 0) {
			/* ITEMS */
			for (j in room[id].items) {
				var itm = room[id].items[j];
				worldStr += "ITM " + itm.id + " " + itm.x + "," + itm.y;
				worldStr += "\n";
			}
		}
		if (room[id].exits.length > 0) {
			/* EXITS */
			for (j in room[id].exits) {
				var e = room[id].exits[j];
				if ( isExitValid(e) ) {
					worldStr += "EXT " + e.x + "," + e.y + " " + e.dest.room + " " + e.dest.x + "," + e.dest.y;
					if (e.transition_effect != undefined && e.transition_effect != null) {
						worldStr += " FX " + e.transition_effect;
					}
					// TODO : vNext
					// if (e.script_id != undefined && e.script_id != null) {
					// 	worldStr += " PRG " + e.script_id;
					// }
					worldStr += "\n";
				}
			}
		}
		if (room[id].endings.length > 0) {
			/* ENDINGS */
			for (j in room[id].endings) {
				var e = room[id].endings[j];
				// todo isEndingValid
				worldStr += "END " + e.id + " " + e.x + "," + e.y;
				worldStr += "\n";
			}
		}
		// TODO : vNext
		// if (room[id].effects.length > 0) {
		// 	/* EFFECTS */
		// 	for (j in room[id].effects) {
		// 		var e = room[id].effects[j];
		// 		worldStr += "EFF " + e.id + " " + e.x + "," + e.y;
		// 		worldStr += "\n";
		// 	}
		// }
		if (room[id].pal != null && room[id].pal != "default") {
			/* PALETTE */
			worldStr += "PAL " + room[id].pal + "\n";
		}
		worldStr += "\n";
	}
	/* TILES */
	for (id in tile) {
		worldStr += "TIL " + id + "\n";
		worldStr += serializeDrawing( "TIL_" + id );
		if (tile[id].name != null && tile[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + tile[id].name + "\n";
		}
		if (tile[id].isWall != null && tile[id].isWall != undefined) {
			/* WALL */
			worldStr += "WAL " + tile[id].isWall + "\n";
		}
		if (tile[id].col != null && tile[id].col != undefined && tile[id].col != 1) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + tile[id].col + "\n";
		}
		worldStr += "\n";
	}
	/* SPRITES */
	for (id in sprite) {
		worldStr += "SPR " + id + "\n";
		worldStr += serializeDrawing( "SPR_" + id );
		if (sprite[id].name != null && sprite[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + sprite[id].name + "\n";
		}
		if (sprite[id].dlg != null) {
			worldStr += "DLG " + sprite[id].dlg + "\n";
		}
		if (sprite[id].room != null) {
			/* SPRITE POSITION */
			worldStr += "POS " + sprite[id].room + " " + sprite[id].x + "," + sprite[id].y + "\n";
		}
		if (sprite[id].inventory != null) {
			for(itemId in sprite[id].inventory) {
				worldStr += "ITM " + itemId + " " + sprite[id].inventory[itemId] + "\n";
			}
		}
		if (sprite[id].col != null && sprite[id].col != undefined && sprite[id].col != 2) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + sprite[id].col + "\n";
		}
		worldStr += "\n";
	}
	/* ITEMS */
	for (id in item) {
		worldStr += "ITM " + id + "\n";
		worldStr += serializeDrawing( "ITM_" + id );
		if (item[id].name != null && item[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + item[id].name + "\n";
		}
		if (item[id].dlg != null) {
			worldStr += "DLG " + item[id].dlg + "\n";
		}
		if (item[id].col != null && item[id].col != undefined && item[id].col != 2) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + item[id].col + "\n";
		}
		worldStr += "\n";
	}
	/* DIALOG */
	for (id in dialog) {
		worldStr += "DLG " + id + "\n";
		worldStr += dialog[id] + "\n";
		worldStr += "\n";
	}
	/* ENDINGS */
	for (id in ending) {
		worldStr += "END " + id + "\n";
		worldStr += ending[id] + "\n";
		worldStr += "\n";
	}
	// TODO : vNext
	// /* SCRIPTS */
	// for (id in script) {
	// 	if (script[id].type == ScriptType.Dialogue) {
	// 		worldStr += "DLG " + id + "\n";
	// 	}
	// 	else if (script[id].type == ScriptType.Ending) {
	// 		worldStr += "END " + id + "\n";
	// 	}
	// 	else {
	// 		worldStr += "PRG " + id + "\n";
	// 	}
	// 	worldStr += script[id].source + "\n";
	// 	worldStr += "\n";
	// }
	/* VARIABLES */
	for (id in variable) {
		worldStr += "VAR " + id + "\n";
		worldStr += variable[id] + "\n";
		worldStr += "\n";
	}
	/* FONT */
	// TODO : support multiple fonts
	if (fontName != defaultFontName && !skipFonts) {
		worldStr += fontManager.GetData(fontName);
	}

	return worldStr;
}

function serializeDrawing(drwId) {
	var imageSource = renderer.GetImageSource(drwId);
	var drwStr = "";
	for (f in imageSource) {
		for (y in imageSource[f]) {
			var rowStr = "";
			for (x in imageSource[f][y]) {
				rowStr += imageSource[f][y][x];
			}
			drwStr += rowStr + "\n";
		}
		if (f < (imageSource.length-1)) drwStr += ">\n";
	}
	return drwStr;
}

function isExitValid(e) {
	var hasValidStartPos = e.x >= 0 && e.x < 16 && e.y >= 0 && e.y < 16;
	var hasDest = e.dest != null;
	var hasValidRoomDest = (e.dest.room != null && e.dest.x >= 0 && e.dest.x < 16 && e.dest.y >= 0 && e.dest.y < 16);
	return hasValidStartPos && hasDest && hasValidRoomDest;
}

function placeSprites() {
	for (id in spriteStartLocations) {
		//console.log(id);
		//console.log( spriteStartLocations[id] );
		//console.log(sprite[id]);
		sprite[id].room = spriteStartLocations[id].room;
		sprite[id].x = spriteStartLocations[id].x;
		sprite[id].y = spriteStartLocations[id].y;
		//console.log(sprite[id]);
	}
}

/* ARGUMENT GETTERS */
function getType(line) {
	return getArg(line,0);
}

function getId(line) {
	return getArg(line,1);
}

function getArg(line,arg) {
	return line.split(" ")[arg];
}

function getCoord(line,arg) {
	return getArg(line,arg).split(",");
}

function parseTitle(lines, i) {
	title = lines[i];
	i++;
	return i;
}

function parseRoom(lines, i) {
	var id = getId(lines[i]);
	room[id] = {
		id : id,
		tilemap : [],
		walls : [],
		exits : [],
		endings : [],
		// effects : [], // TODO vNext
		items : [],
		pal : null,
		name : null
	};
	i++;

	// create tile map
	if ( flags.ROOM_FORMAT == 0 ) {
		// old way: no commas, single char tile ids
		var end = i + mapsize;
		var y = 0;
		for (; i<end; i++) {
			room[id].tilemap.push( [] );
			for (x = 0; x<mapsize; x++) {
				room[id].tilemap[y].push( lines[i].charAt(x) );
			}
			y++;
		}
	}
	else if ( flags.ROOM_FORMAT == 1 ) {
		// new way: comma separated, multiple char tile ids
		var end = i + mapsize;
		var y = 0;
		for (; i<end; i++) {
			room[id].tilemap.push( [] );
			var lineSep = lines[i].split(",");
			for (x = 0; x<mapsize; x++) {
				room[id].tilemap[y].push( lineSep[x] );
			}
			y++;
		}
	}

	while (i < lines.length && lines[i].length > 0) { //look for empty line
		// console.log(getType(lines[i]));
		if (getType(lines[i]) === "SPR") {
			/* NOTE SPRITE START LOCATIONS */
			var sprId = getId(lines[i]);
			if (sprId.indexOf(",") == -1 && lines[i].split(" ").length >= 3) { //second conditional checks for coords
				/* PLACE A SINGLE SPRITE */
				var sprCoord = lines[i].split(" ")[2].split(",");
				spriteStartLocations[sprId] = {
					room : id,
					x : parseInt(sprCoord[0]),
					y : parseInt(sprCoord[1])
				};
			}
			else if ( flags.ROOM_FORMAT == 0 ) { // TODO: right now this shortcut only works w/ the old comma separate format
				/* PLACE MULTIPLE SPRITES*/ 
				//Does find and replace in the tilemap (may be hacky, but its convenient)
				var sprList = sprId.split(",");
				for (row in room[id].tilemap) {
					for (s in sprList) {
						var col = room[id].tilemap[row].indexOf( sprList[s] );
						//if the sprite is in this row, replace it with the "null tile" and set its starting position
						if (col != -1) {
							room[id].tilemap[row][col] = "0";
							spriteStartLocations[ sprList[s] ] = {
								room : id,
								x : parseInt(col),
								y : parseInt(row)
							};
						}
					}
				}
			}
		}
		else if (getType(lines[i]) === "ITM") {
			var itmId = getId(lines[i]);
			var itmCoord = lines[i].split(" ")[2].split(",");
			var itm = {
				id: itmId,
				x : parseInt(itmCoord[0]),
				y : parseInt(itmCoord[1])
			};
			room[id].items.push( itm );
		}
		else if (getType(lines[i]) === "WAL") {
			/* DEFINE COLLISIONS (WALLS) */
			room[id].walls = getId(lines[i]).split(",");
		}
		else if (getType(lines[i]) === "EXT") {
			/* ADD EXIT */
			var exitArgs = lines[i].split(" ");
			//arg format: EXT 10,5 M 3,2 [AVA:7 LCK:a,9] [AVA 7 LCK a 9]
			var exitCoords = exitArgs[1].split(",");
			var destName = exitArgs[2];
			var destCoords = exitArgs[3].split(",");
			var ext = {
				x : parseInt(exitCoords[0]),
				y : parseInt(exitCoords[1]),
				dest : {
					room : destName,
					x : parseInt(destCoords[0]),
					y : parseInt(destCoords[1])
				},
				transition_effect : null,
				// TODO : vNext
				// script_id : null,
			};

			// optional arguments
			var exitArgIndex = 4;
			while (exitArgIndex < exitArgs.length) {
				if (exitArgs[exitArgIndex] == "FX") {
					ext.transition_effect = exitArgs[exitArgIndex+1];
					exitArgIndex += 2;
				}
				// TODO : vNext
				// else if (exitArgs[exitArgIndex] == "PRG") {
				// 	ext.script_id = exitArgs[exitArgIndex+1];
				// 	exitArgIndex += 2;
				// }
				else {
					exitArgIndex += 1;
				}
			}

			room[id].exits.push(ext);
		}
		else if (getType(lines[i]) === "END") {
			/* ADD ENDING */
			var endId = getId( lines[i] );
			var endCoords = getCoord( lines[i], 2 );
			var end = {
				id : endId,
				x : parseInt( endCoords[0] ),
				y : parseInt( endCoords[1] )
			};
			room[id].endings.push(end);
		}
		// TODO : vNext
		// else if (getType(lines[i]) === "EFF") {
		// 	/* ADD EFFECT */
		// 	var effectId = getId( lines[i] );
		// 	var effectCoords = getCoord( lines[i], 2 );
		// 	var effect = {
		// 		id : effectId,
		// 		x : parseInt( effectCoords[0] ),
		// 		y : parseInt( effectCoords[1] ),
		// 	};
		// 	room[id].effects.push(effect);
		// }
		else if (getType(lines[i]) === "PAL") {
			/* CHOOSE PALETTE (that's not default) */
			room[id].pal = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			var name = lines[i].split(/\s(.+)/)[1];
			room[id].name = name;
			names.room.set( name, id);
		}
		i++;
	}
	return i;
}

function parsePalette(lines,i) { //todo this has to go first right now :(
	var id = getId(lines[i]);
	i++;
	var colors = [];
	var name = null;
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		var args = lines[i].split(" ");
		if(args[0] === "NAME") {
			name = lines[i].split(/\s(.+)/)[1];
		}
		else {
			var col = [];
			lines[i].split(",").forEach(function(i) {
				col.push(parseInt(i));
			});
			colors.push(col);
		}
		i++;
	}
	palette[id] = {
		id : id,
		name : name,
		colors : colors
	};
	return i;
}

function parseTile(lines, i) {
	var id = getId(lines[i]);
	var drwId = null;
	var name = null;

	i++;

	if (getType(lines[i]) === "DRW") { //load existing drawing
		drwId = getId(lines[i]);
		i++;
	}
	else {
		// store tile source
		drwId = "TIL_" + id;
		i = parseDrawingCore( lines, i, drwId );
	}

	//other properties
	var colorIndex = 1; // default palette color index is 1
	var isWall = null; // null indicates it can vary from room to room (original version)
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		if (getType(lines[i]) === "COL") {
			colorIndex = parseInt( getId(lines[i]) );
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			name = lines[i].split(/\s(.+)/)[1];
			names.tile.set( name, id );
		}
		else if (getType(lines[i]) === "WAL") {
			var wallArg = getArg( lines[i], 1 );
			if( wallArg === "true" ) {
				isWall = true;
			}
			else if( wallArg === "false" ) {
				isWall = false;
			}
		}
		i++;
	}

	//tile data
	tile[id] = {
		id : id,
		drw : drwId, //drawing id
		col : colorIndex,
		animation : {
			isAnimated : (renderer.GetFrameCount(drwId) > 1),
			frameIndex : 0,
			frameCount : renderer.GetFrameCount(drwId)
		},
		name : name,
		isWall : isWall
	};

	return i;
}

function parseSprite(lines, i) {
	var id = getId(lines[i]);
	var drwId = null;
	var name = null;

	i++;

	if (getType(lines[i]) === "DRW") { //load existing drawing
		drwId = getId(lines[i]);
		i++;
	}
	else {
		// store sprite source
		drwId = "SPR_" + id;
		i = parseDrawingCore( lines, i, drwId );
	}

	//other properties
	var colorIndex = 2; //default palette color index is 2
	var dialogId = null;
	var startingInventory = {};
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		if (getType(lines[i]) === "COL") {
			/* COLOR OFFSET INDEX */
			colorIndex = parseInt( getId(lines[i]) );
		}
		else if (getType(lines[i]) === "POS") {
			/* STARTING POSITION */
			var posArgs = lines[i].split(" ");
			var roomId = posArgs[1];
			var coordArgs = posArgs[2].split(",");
			spriteStartLocations[id] = {
				room : roomId,
				x : parseInt(coordArgs[0]),
				y : parseInt(coordArgs[1])
			};
		}
		else if(getType(lines[i]) === "DLG") {
			dialogId = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			name = lines[i].split(/\s(.+)/)[1];
			names.sprite.set( name, id );
		}
		else if (getType(lines[i]) === "ITM") {
			/* ITEM STARTING INVENTORY */
			var itemId = getId(lines[i]);
			var itemCount = parseFloat( getArg(lines[i], 2) );
			startingInventory[itemId] = itemCount;
		}
		i++;
	}

	//sprite data
	sprite[id] = {
		id : id,
		drw : drwId, //drawing id
		col : colorIndex,
		dlg : dialogId,
		room : null, //default location is "offstage"
		x : -1,
		y : -1,
		walkingPath : [], //tile by tile movement path (isn't saved)
		animation : {
			isAnimated : (renderer.GetFrameCount(drwId) > 1),
			frameIndex : 0,
			frameCount : renderer.GetFrameCount(drwId)
		},
		inventory : startingInventory,
		name : name
	};
	return i;
}

function parseItem(lines, i) {
	var id = getId(lines[i]);
	var drwId = null;
	var name = null;

	i++;

	if (getType(lines[i]) === "DRW") { //load existing drawing
		drwId = getId(lines[i]);
		i++;
	}
	else {
		// store item source
		drwId = "ITM_" + id; // these prefixes are maybe a terrible way to differentiate drawing tyepes :/
		i = parseDrawingCore( lines, i, drwId );
	}

	//other properties
	var colorIndex = 2; //default palette color index is 2
	var dialogId = null;
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		if (getType(lines[i]) === "COL") {
			/* COLOR OFFSET INDEX */
			colorIndex = parseInt( getArg( lines[i], 1 ) );
		}
		// else if (getType(lines[i]) === "POS") {
		// 	/* STARTING POSITION */
		// 	var posArgs = lines[i].split(" ");
		// 	var roomId = posArgs[1];
		// 	var coordArgs = posArgs[2].split(",");
		// 	spriteStartLocations[id] = {
		// 		room : roomId,
		// 		x : parseInt(coordArgs[0]),
		// 		y : parseInt(coordArgs[1])
		// 	};
		// }
		else if(getType(lines[i]) === "DLG") {
			dialogId = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			name = lines[i].split(/\s(.+)/)[1];
			names.item.set( name, id );
		}
		i++;
	}

	//item data
	item[id] = {
		id : id,
		drw : drwId, //drawing id
		col : colorIndex,
		dlg : dialogId,
		// room : null, //default location is "offstage"
		// x : -1,
		// y : -1,
		animation : {
			isAnimated : (renderer.GetFrameCount(drwId) > 1),
			frameIndex : 0,
			frameCount : renderer.GetFrameCount(drwId)
		},
		name : name
	};

	// console.log("ITM " + id);
	// console.log(item[id]);

	return i;
}

function parseDrawing(lines, i) {
	// store drawing source
	var drwId = getId( lines[i] );
	return parseDrawingCore( lines, i, drwId );
}

function parseDrawingCore(lines, i, drwId) {
	var frameList = []; //init list of frames
	frameList.push( [] ); //init first frame
	var frameIndex = 0;
	var y = 0;
	while ( y < tilesize ) {
		var l = lines[i+y];
		var row = [];
		for (x = 0; x < tilesize; x++) {
			row.push( parseInt( l.charAt(x) ) );
		}
		frameList[frameIndex].push( row );
		y++;

		if (y === tilesize) {
			i = i + y;
			if ( lines[i] != undefined && lines[i].charAt(0) === ">" ) {
				// start next frame!
				frameList.push( [] );
				frameIndex++;
				//start the count over again for the next frame
				i++;
				y = 0;
			}
		}
	}

	renderer.SetImageSource(drwId, frameList);

	return i;
}

// TODO : vNext
// var ScriptType = {
// 	Script : 0,
// 	Dialogue : 1, // TODO : move everything to this spelling?
// 	Ending : 2,
// };

function parseScript(lines, i, objectStore) {
	// TODO : vNext
	// if (scriptType === undefined || scriptType === null) {
	// 	scriptType = ScriptType.Script;
	// }

	var id = getId(lines[i]);
	i++;

	var results = scriptUtils.ReadDialogScript(lines,i);

	// TODO : vNext
	// script[id] = {
	// 	source: results.script,
	// 	type: scriptType,
	// };

	objectStore[id] = results.script;

	i = results.index;

	return i;
}

function parseDialog(lines, i) {
	return parseScript(lines, i, dialog);
}

function parseEnding(lines, i) {
	return parseScript(lines, i, ending);
}

function parseVariable(lines, i) {
	var id = getId(lines[i]);
	i++;
	var value = lines[i];
	i++;
	variable[id] = value;
	return i;
}

function parseFontName(lines, i) {
	fontName = getArg(lines[i], 1);
	i++;
	return i;
}

function parseTextDirection(lines, i) {
	textDirection = getArg(lines[i], 1);
	i++;
	return i;
}

function parseFontData(lines, i) {
	// NOTE : we're not doing the actual parsing here --
	// just grabbing the block of text that represents the font
	// and giving it to the font manager to use later

	var localFontName = getId(lines[i]);
	var localFontData = lines[i];
	i++;

	while (i < lines.length && lines[i] != "") {
		localFontData += "\n" + lines[i];
		i++;
	}

	var localFontFilename = localFontName + fontManager.GetExtension();
	fontManager.AddResource( localFontFilename, localFontData );

	return i;
}

function parseFlag(lines, i) {
	var id = getId(lines[i]);
	var valStr = lines[i].split(" ")[2];
	flags[id] = parseInt( valStr );
	i++;
	return i;
}

function drawTile(img,x,y,context) {
	if (!context) { //optional pass in context; otherwise, use default
		context = ctx;
	}
	// NOTE: images are now canvases, instead of raw image data (for chrome performance reasons)
	context.drawImage(img,x*tilesize*scale,y*tilesize*scale,tilesize*scale,tilesize*scale);
}

function drawSprite(img,x,y,context) { //this may differ later (or not haha)
	drawTile(img,x,y,context);
}

function drawItem(img,x,y,context) {
	drawTile(img,x,y,context); //TODO these methods are dumb and repetitive
}

// var debugLastRoomDrawn = "0";

function drawRoom(room,context,frameIndex) { // context & frameIndex are optional
	if (!context) { //optional pass in context; otherwise, use default (ok this is REAL hacky isn't it)
		context = ctx;
	}

	// if (room.id != debugLastRoomDrawn) {
	// 	debugLastRoomDrawn = room.id;
	// 	console.log("DRAW ROOM " + debugLastRoomDrawn);
	// }

	var paletteId = "default";

	if (room === undefined) {
		// protect against invalid rooms
		context.fillStyle = "rgb(" + getPal(paletteId)[0][0] + "," + getPal(paletteId)[0][1] + "," + getPal(paletteId)[0][2] + ")";
		context.fillRect(0,0,canvas.width,canvas.height);
		return;
	}

	//clear screen
	if (room.pal != null && palette[paletteId] != undefined) {
		paletteId = room.pal;
	}
	context.fillStyle = "rgb(" + getPal(paletteId)[0][0] + "," + getPal(paletteId)[0][1] + "," + getPal(paletteId)[0][2] + ")";
	context.fillRect(0,0,canvas.width,canvas.height);

	//draw tiles
	for (i in room.tilemap) {
		for (j in room.tilemap[i]) {
			var id = room.tilemap[i][j];
			if (id != "0") {
				//console.log(id);
				if (tile[id] == null) { // hack-around to avoid corrupting files (not a solution though!)
					id = "0";
					room.tilemap[i][j] = id;
				}
				else {
					// console.log(id);
					drawTile( getTileImage(tile[id],paletteId,frameIndex), j, i, context );
				}
			}
		}
	}

	//draw items
	for (var i = 0; i < room.items.length; i++) {
		var itm = room.items[i];
		drawItem( getItemImage(item[itm.id],paletteId,frameIndex), itm.x, itm.y, context );
	}

	//draw sprites
	for (id in sprite) {
		var spr = sprite[id];
		if (spr.room === room.id) {
			drawSprite( getSpriteImage(spr,paletteId,frameIndex), spr.x, spr.y, context );
		}
	}
}

// TODO : remove these get*Image methods
function getTileImage(t,palId,frameIndex) {
	return renderer.GetImage(t,palId,frameIndex);
}

function getSpriteImage(s,palId,frameIndex) {
	return renderer.GetImage(s,palId,frameIndex);
}

function getItemImage(itm,palId,frameIndex) {
	return renderer.GetImage(itm,palId,frameIndex);
}

function curPal() {
	return getRoomPal(curRoom);
}

function getRoomPal(roomId) {
	var defaultId = "default";

	if (roomId == null) {
		return defaultId;
	}
	else if (room[roomId].pal != null) {
		//a specific palette was chosen
		return room[roomId].pal;
	}
	else {
		if (roomId in palette) {
			//there is a palette matching the name of the room
			return roomId;
		}
		else {
			//use the default palette
			return defaultId;
		}
	}
	return defaultId;
}

var isDialogMode = false;
var isNarrating = false;
var isEnding = false;
var dialogModule = new Dialog();
var dialogRenderer = dialogModule.CreateRenderer();
var dialogBuffer = dialogModule.CreateBuffer();
var fontManager = new FontManager();

function onExitDialog(scriptResult, dialogCallback) {
	isDialogMode = false;
	if (isNarrating) isNarrating = false;
	if (isDialogPreview) {
		isDialogPreview = false;
		if (onDialogPreviewEnd != null)
			onDialogPreviewEnd();
	}

	if (dialogCallback != undefined && dialogCallback != null) {
		dialogCallback(scriptResult);
	}
}

/*
TODO
- titles and endings should also take advantage of the script pre-compilation if possible??
- could there be a namespace collision?
- what about dialog NAMEs vs IDs?
- what about a special script block separate from DLG?
*/
function startNarrating(dialogStr,end) {
	console.log("NARRATE " + dialogStr);

	if(end === undefined) end = false;

	isNarrating = true;
	isEnding = end;
	startDialog(dialogStr);
}

function startItemDialog(itemId) {
	var dialogId = item[itemId].dlg;
	// console.log("START ITEM DIALOG " + dialogId);
	if(dialog[dialogId]){
		var dialogStr = dialog[dialogId];
		startDialog(dialogStr,dialogId);
	}
}

function startSpriteDialog(spriteId) {
	var spr = sprite[spriteId];
	var dialogId = spr.dlg ? spr.dlg : spriteId;
	// console.log("START SPRITE DIALOG " + dialogId);
	if(dialog[dialogId]){
		var dialogStr = dialog[dialogId];
		startDialog(dialogStr,dialogId);
	}
}

function startDialog(dialogStr,scriptId,dialogCallback) {
	// console.log("START DIALOG ");
	if(dialogStr.length <= 0) {
		// console.log("ON EXIT DIALOG -- startDialog 1");
		onExitDialog(dialogCallback);
		return;
	}

	isDialogMode = true;

	dialogRenderer.Reset();
	dialogRenderer.SetCentered( isNarrating /*centered*/ );
	dialogBuffer.Reset();
	scriptInterpreter.SetDialogBuffer( dialogBuffer );

	var onScriptEnd = function(scriptResult) {
		dialogBuffer.OnDialogEnd(function() {
			onExitDialog(scriptResult, dialogCallback);
		});
	};

	if(scriptId === undefined) {
		scriptInterpreter.Interpret( dialogStr, onScriptEnd );
	}
	else {
		if( !scriptInterpreter.HasScript(scriptId) ) {
			scriptInterpreter.Compile( scriptId, dialogStr );
		}
		scriptInterpreter.DebugVisualizeScriptTree(scriptId);
		scriptInterpreter.Run( scriptId, onScriptEnd );
	}

}

var isDialogPreview = false;
function startPreviewDialog(script, onScriptEnd) {
	isNarrating = true;

	isDialogMode = true;

	isDialogPreview = true;

	dialogRenderer.Reset();
	dialogRenderer.SetCentered( true );
	dialogBuffer.Reset();
	scriptInterpreter.SetDialogBuffer( dialogBuffer );

	onDialogPreviewEnd = onScriptEnd;

	scriptInterpreter.Eval( script, null );
}

/* NEW SCRIPT STUFF */
var scriptModule = new Script();
var scriptInterpreter = scriptModule.CreateInterpreter();
var scriptUtils = scriptModule.CreateUtils(); // TODO: move to editor.js?
// scriptInterpreter.SetDialogBuffer( dialogBuffer );
</script>

<!-- store default font in separate script tag for back compat-->
<script type="text/bitsyFontData" id="ascii_small">
FONT ascii_small
SIZE 6 8
CHAR 0
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 1
001110
010001
011011
010001
010101
010001
001110
000000
CHAR 2
001110
011111
010101
011111
010001
011111
001110
000000
CHAR 3
000000
001010
011111
011111
011111
001110
000100
000000
CHAR 4
000000
000000
001010
001110
001110
000100
000000
000000
CHAR 5
000100
001110
001110
000100
011111
011111
000100
000000
CHAR 6
000000
000100
001110
011111
011111
000100
001110
000000
CHAR 7
000000
000000
000000
001100
001100
000000
000000
000000
CHAR 8
111111
111111
111111
110011
110011
111111
111111
111111
CHAR 9
000000
000000
011110
010010
010010
011110
000000
000000
CHAR 10
111111
111111
100001
101101
101101
100001
111111
111111
CHAR 11
000000
000111
000011
001101
010010
010010
001100
000000
CHAR 12
001110
010001
010001
001110
000100
001110
000100
000000
CHAR 13
000100
000110
000101
000100
001100
011100
011000
000000
CHAR 14
000011
001101
001011
001101
001011
011011
011000
000000
CHAR 15
000000
010101
001110
011011
001110
010101
000000
000000
CHAR 16
001000
001100
001110
001111
001110
001100
001000
000000
CHAR 17
000010
000110
001110
011110
001110
000110
000010
000000
CHAR 18
000100
001110
011111
000100
011111
001110
000100
000000
CHAR 19
001010
001010
001010
001010
001010
000000
001010
000000
CHAR 20
001111
010101
010101
001101
000101
000101
000101
000000
CHAR 21
001110
010001
001100
001010
000110
010001
001110
000000
CHAR 22
000000
000000
000000
000000
000000
011110
011110
000000
CHAR 23
000100
001110
011111
000100
011111
001110
000100
001110
CHAR 24
000100
001110
011111
000100
000100
000100
000100
000000
CHAR 25
000100
000100
000100
000100
011111
001110
000100
000000
CHAR 26
000000
000100
000110
011111
000110
000100
000000
000000
CHAR 27
000000
000100
001100
011111
001100
000100
000000
000000
CHAR 28
000000
000000
000000
010000
010000
010000
011111
000000
CHAR 29
000000
001010
001010
011111
001010
001010
000000
000000
CHAR 30
000100
000100
001110
001110
011111
011111
000000
000000
CHAR 31
011111
011111
001110
001110
000100
000100
000000
000000
CHAR 32
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 33
000100
001110
001110
000100
000100
000000
000100
000000
CHAR 34
011011
011011
010010
000000
000000
000000
000000
000000
CHAR 35
000000
001010
011111
001010
001010
011111
001010
000000
CHAR 36
001000
001110
010000
001100
000010
011100
000100
000000
CHAR 37
011001
011001
000010
000100
001000
010011
010011
000000
CHAR 38
001000
010100
010100
001000
010101
010010
001101
000000
CHAR 39
001100
001100
001000
000000
000000
000000
000000
000000
CHAR 40
000100
001000
001000
001000
001000
001000
000100
000000
CHAR 41
001000
000100
000100
000100
000100
000100
001000
000000
CHAR 42
000000
001010
001110
011111
001110
001010
000000
000000
CHAR 43
000000
000100
000100
011111
000100
000100
000000
000000
CHAR 44
000000
000000
000000
000000
000000
001100
001100
001000
CHAR 45
000000
000000
000000
011111
000000
000000
000000
000000
CHAR 46
000000
000000
000000
000000
000000
001100
001100
000000
CHAR 47
000000
000001
000010
000100
001000
010000
000000
000000
CHAR 48
001110
010001
010011
010101
011001
010001
001110
000000
CHAR 49
000100
001100
000100
000100
000100
000100
001110
000000
CHAR 50
001110
010001
000001
000110
001000
010000
011111
000000
CHAR 51
001110
010001
000001
001110
000001
010001
001110
000000
CHAR 52
000010
000110
001010
010010
011111
000010
000010
000000
CHAR 53
011111
010000
010000
011110
000001
010001
001110
000000
CHAR 54
000110
001000
010000
011110
010001
010001
001110
000000
CHAR 55
011111
000001
000010
000100
001000
001000
001000
000000
CHAR 56
001110
010001
010001
001110
010001
010001
001110
000000
CHAR 57
001110
010001
010001
001111
000001
000010
001100
000000
CHAR 58
000000
000000
001100
001100
000000
001100
001100
000000
CHAR 59
000000
000000
001100
001100
000000
001100
001100
001000
CHAR 60
000010
000100
001000
010000
001000
000100
000010
000000
CHAR 61
000000
000000
011111
000000
000000
011111
000000
000000
CHAR 62
001000
000100
000010
000001
000010
000100
001000
000000
CHAR 63
001110
010001
000001
000110
000100
000000
000100
000000
CHAR 64
001110
010001
010111
010101
010111
010000
001110
000000
CHAR 65
001110
010001
010001
010001
011111
010001
010001
000000
CHAR 66
011110
010001
010001
011110
010001
010001
011110
000000
CHAR 67
001110
010001
010000
010000
010000
010001
001110
000000
CHAR 68
011110
010001
010001
010001
010001
010001
011110
000000
CHAR 69
011111
010000
010000
011110
010000
010000
011111
000000
CHAR 70
011111
010000
010000
011110
010000
010000
010000
000000
CHAR 71
001110
010001
010000
010111
010001
010001
001111
000000
CHAR 72
010001
010001
010001
011111
010001
010001
010001
000000
CHAR 73
001110
000100
000100
000100
000100
000100
001110
000000
CHAR 74
000001
000001
000001
000001
010001
010001
001110
000000
CHAR 75
010001
010010
010100
011000
010100
010010
010001
000000
CHAR 76
010000
010000
010000
010000
010000
010000
011111
000000
CHAR 77
010001
011011
010101
010001
010001
010001
010001
000000
CHAR 78
010001
011001
010101
010011
010001
010001
010001
000000
CHAR 79
001110
010001
010001
010001
010001
010001
001110
000000
CHAR 80
011110
010001
010001
011110
010000
010000
010000
000000
CHAR 81
001110
010001
010001
010001
010101
010010
001101
000000
CHAR 82
011110
010001
010001
011110
010010
010001
010001
000000
CHAR 83
001110
010001
010000
001110
000001
010001
001110
000000
CHAR 84
011111
000100
000100
000100
000100
000100
000100
000000
CHAR 85
010001
010001
010001
010001
010001
010001
001110
000000
CHAR 86
010001
010001
010001
010001
010001
001010
000100
000000
CHAR 87
010001
010001
010101
010101
010101
010101
001010
000000
CHAR 88
010001
010001
001010
000100
001010
010001
010001
000000
CHAR 89
010001
010001
010001
001010
000100
000100
000100
000000
CHAR 90
011110
000010
000100
001000
010000
010000
011110
000000
CHAR 91
001110
001000
001000
001000
001000
001000
001110
000000
CHAR 92
000000
010000
001000
000100
000010
000001
000000
000000
CHAR 93
001110
000010
000010
000010
000010
000010
001110
000000
CHAR 94
000100
001010
010001
000000
000000
000000
000000
000000
CHAR 95
000000
000000
000000
000000
000000
000000
000000
111111
CHAR 96
001100
001100
000100
000000
000000
000000
000000
000000
CHAR 97
000000
000000
001110
000001
001111
010001
001111
000000
CHAR 98
010000
010000
011110
010001
010001
010001
011110
000000
CHAR 99
000000
000000
001110
010001
010000
010001
001110
000000
CHAR 100
000001
000001
001111
010001
010001
010001
001111
000000
CHAR 101
000000
000000
001110
010001
011110
010000
001110
000000
CHAR 102
000110
001000
001000
011110
001000
001000
001000
000000
CHAR 103
000000
000000
001111
010001
010001
001111
000001
001110
CHAR 104
010000
010000
011100
010010
010010
010010
010010
000000
CHAR 105
000100
000000
000100
000100
000100
000100
000110
000000
CHAR 106
000010
000000
000110
000010
000010
000010
010010
001100
CHAR 107
010000
010000
010010
010100
011000
010100
010010
000000
CHAR 108
000100
000100
000100
000100
000100
000100
000110
000000
CHAR 109
000000
000000
011010
010101
010101
010001
010001
000000
CHAR 110
000000
000000
011100
010010
010010
010010
010010
000000
CHAR 111
000000
000000
001110
010001
010001
010001
001110
000000
CHAR 112
000000
000000
011110
010001
010001
010001
011110
010000
CHAR 113
000000
000000
001111
010001
010001
010001
001111
000001
CHAR 114
000000
000000
010110
001001
001000
001000
011100
000000
CHAR 115
000000
000000
001110
010000
001110
000001
001110
000000
CHAR 116
000000
001000
011110
001000
001000
001010
000100
000000
CHAR 117
000000
000000
010010
010010
010010
010110
001010
000000
CHAR 118
000000
000000
010001
010001
010001
001010
000100
000000
CHAR 119
000000
000000
010001
010001
010101
011111
001010
000000
CHAR 120
000000
000000
010010
010010
001100
010010
010010
000000
CHAR 121
000000
000000
010010
010010
010010
001110
000100
011000
CHAR 122
000000
000000
011110
000010
001100
010000
011110
000000
CHAR 123
000110
001000
001000
011000
001000
001000
000110
000000
CHAR 124
000100
000100
000100
000100
000100
000100
000100
000100
CHAR 125
001100
000010
000010
000011
000010
000010
001100
000000
CHAR 126
001010
010100
000000
000000
000000
000000
000000
000000
CHAR 127
000100
001110
011011
010001
010001
011111
000000
000000
CHAR 128
001110
010001
010000
010000
010001
001110
000100
001100
CHAR 129
010010
000000
010010
010010
010010
010110
001010
000000
CHAR 130
000011
000000
001110
010001
011110
010000
001110
000000
CHAR 131
001110
000000
001110
000001
001111
010001
001111
000000
CHAR 132
001010
000000
001110
000001
001111
010001
001111
000000
CHAR 133
001100
000000
001110
000001
001111
010001
001111
000000
CHAR 134
001110
001010
001110
000001
001111
010001
001111
000000
CHAR 135
000000
001110
010001
010000
010001
001110
000100
001100
CHAR 136
001110
000000
001110
010001
011110
010000
001110
000000
CHAR 137
001010
000000
001110
010001
011110
010000
001110
000000
CHAR 138
001100
000000
001110
010001
011110
010000
001110
000000
CHAR 139
001010
000000
000100
000100
000100
000100
000110
000000
CHAR 140
000100
001010
000000
000100
000100
000100
000110
000000
CHAR 141
001000
000000
000100
000100
000100
000100
000110
000000
CHAR 142
001010
000000
000100
001010
010001
011111
010001
000000
CHAR 143
001110
001010
001110
011011
010001
011111
010001
000000
CHAR 144
000011
000000
011111
010000
011110
010000
011111
000000
CHAR 145
000000
000000
011110
000101
011111
010100
001111
000000
CHAR 146
001111
010100
010100
011111
010100
010100
010111
000000
CHAR 147
001110
000000
001100
010010
010010
010010
001100
000000
CHAR 148
001010
000000
001100
010010
010010
010010
001100
000000
CHAR 149
011000
000000
001100
010010
010010
010010
001100
000000
CHAR 150
001110
000000
010010
010010
010010
010110
001010
000000
CHAR 151
011000
000000
010010
010010
010010
010110
001010
000000
CHAR 152
001010
000000
010010
010010
010010
001110
000100
011000
CHAR 153
010010
001100
010010
010010
010010
010010
001100
000000
CHAR 154
001010
000000
010010
010010
010010
010010
001100
000000
CHAR 155
000000
000100
001110
010000
010000
001110
000100
000000
CHAR 156
000110
001001
001000
011110
001000
001001
010111
000000
CHAR 157
010001
001010
000100
011111
000100
011111
000100
000000
CHAR 158
011000
010100
010100
011010
010111
010010
010010
000000
CHAR 159
000010
000101
000100
001110
000100
000100
010100
001000
CHAR 160
000110
000000
001110
000001
001111
010001
001111
000000
CHAR 161
000110
000000
000100
000100
000100
000100
000110
000000
CHAR 162
000110
000000
001100
010010
010010
010010
001100
000000
CHAR 163
000110
000000
010010
010010
010010
010110
001010
000000
CHAR 164
001010
010100
000000
011100
010010
010010
010010
000000
CHAR 165
001010
010100
000000
010010
011010
010110
010010
000000
CHAR 166
001110
000001
001111
010001
001111
000000
001111
000000
CHAR 167
001100
010010
010010
010010
001100
000000
011110
000000
CHAR 168
000100
000000
000100
001100
010000
010001
001110
000000
CHAR 169
000000
000000
011111
010000
010000
010000
000000
000000
CHAR 170
000000
000000
111111
000001
000001
000000
000000
000000
CHAR 171
010000
010010
010100
001110
010001
000010
000111
000000
CHAR 172
010000
010010
010100
001011
010101
000111
000001
000000
CHAR 173
000100
000000
000100
000100
001110
001110
000100
000000
CHAR 174
000000
000000
001001
010010
001001
000000
000000
000000
CHAR 175
000000
000000
010010
001001
010010
000000
000000
000000
CHAR 176
010101
000000
101010
000000
010101
000000
101010
000000
CHAR 177
010101
101010
010101
101010
010101
101010
010101
101010
CHAR 178
101010
111111
010101
111111
101010
111111
010101
111111
CHAR 179
000100
000100
000100
000100
000100
000100
000100
000100
CHAR 180
000100
000100
000100
111100
000100
000100
000100
000100
CHAR 181
000000
000000
010010
010010
010010
011100
010000
010000
CHAR 182
010100
010100
010100
110100
010100
010100
010100
010100
CHAR 183
000000
000000
000000
111100
010100
010100
010100
010100
CHAR 184
000000
111100
000100
111100
000100
000100
000100
000100
CHAR 185
010100
110100
000100
110100
010100
010100
010100
010100
CHAR 186
010100
010100
010100
010100
010100
010100
010100
010100
CHAR 187
000000
111100
000100
110100
010100
010100
010100
010100
CHAR 188
010100
110100
000100
111100
000000
000000
000000
000000
CHAR 189
010100
010100
010100
111100
000000
000000
000000
000000
CHAR 190
000100
111100
000100
111100
000000
000000
000000
000000
CHAR 191
000000
000000
000000
111100
000100
000100
000100
000100
CHAR 192
000100
000100
000100
000111
000000
000000
000000
000000
CHAR 193
000100
000100
000100
111111
000000
000000
000000
000000
CHAR 194
000000
000000
000000
111111
000100
000100
000100
000100
CHAR 195
000100
000100
000100
000111
000100
000100
000100
000100
CHAR 196
000000
000000
000000
111111
000000
000000
000000
000000
CHAR 197
000100
000100
000100
111111
000100
000100
000100
000100
CHAR 198
000100
000111
000100
000111
000100
000100
000100
000100
CHAR 199
010100
010100
010100
010111
010100
010100
010100
010100
CHAR 200
010100
010111
010000
011111
000000
000000
000000
000000
CHAR 201
000000
011111
010000
010111
010100
010100
010100
010100
CHAR 202
010100
110111
000000
111111
000000
000000
000000
000000
CHAR 203
000000
111111
000000
110111
010100
010100
010100
010100
CHAR 204
010100
010111
010000
010111
010100
010100
010100
010100
CHAR 205
000000
111111
000000
111111
000000
000000
000000
000000
CHAR 206
010100
110111
000000
110111
010100
010100
010100
010100
CHAR 207
000100
111111
000000
111111
000000
000000
000000
000000
CHAR 208
010100
010100
010100
111111
000000
000000
000000
000000
CHAR 209
000000
111111
000000
111111
000100
000100
000100
000100
CHAR 210
000000
000000
000000
111111
010100
010100
010100
010100
CHAR 211
010100
010100
010100
011111
000000
000000
000000
000000
CHAR 212
000000
000000
000000
000000
000000
000000
000000
111111
CHAR 213
000000
000000
000000
000000
000000
000000
111111
111111
CHAR 214
000000
000000
000000
000000
000000
111111
111111
111111
CHAR 215
000000
000000
000000
000000
111111
111111
111111
111111
CHAR 216
000000
000000
000000
111111
111111
111111
111111
111111
CHAR 217
000000
000000
111111
111111
111111
111111
111111
111111
CHAR 218
000000
111111
111111
111111
111111
111111
111111
111111
CHAR 219
111111
111111
111111
111111
111111
111111
111111
111111
CHAR 220
100000
100000
100000
100000
100000
100000
100000
100000
CHAR 221
110000
110000
110000
110000
110000
110000
110000
110000
CHAR 222
111000
111000
111000
111000
111000
111000
111000
111000
CHAR 223
111100
111100
111100
111100
111100
111100
111100
111100
CHAR 224
111110
111110
111110
111110
111110
111110
111110
111110
CHAR 225
000000
011100
010010
011100
010010
010010
011100
010000
CHAR 226
011110
010010
010000
010000
010000
010000
010000
000000
CHAR 227
000000
011111
001010
001010
001010
001010
001010
000000
CHAR 228
001010
000000
001110
000001
001111
010001
001111
000000
CHAR 229
000000
000000
001111
010010
010010
001100
000000
000000
CHAR 230
000000
000000
010010
010010
010010
011100
010000
010000
CHAR 231
000000
000000
001010
010100
000100
000100
000100
000000
CHAR 232
001110
000100
001110
010001
001110
000100
001110
000000
CHAR 233
001100
010010
010010
011110
010010
010010
001100
000000
CHAR 234
000000
001110
010001
010001
001010
001010
011011
000000
CHAR 235
001100
010000
001000
000100
001110
010010
001100
000000
CHAR 236
000000
000000
001010
010101
010101
001010
000000
000000
CHAR 237
000000
000100
001110
010101
010101
001110
000100
000000
CHAR 238
000000
001110
010000
011110
010000
001110
000000
000000
CHAR 239
000000
001100
010010
010010
010010
010010
000000
000000
CHAR 240
000000
011110
000000
011110
000000
011110
000000
000000
CHAR 241
000000
000100
001110
000100
000000
001110
000000
000000
CHAR 242
010000
001100
000010
001100
010000
000000
011110
000000
CHAR 243
000000
000000
111111
111000
100110
100001
100000
111111
CHAR 244
000000
000000
111111
000111
011001
100001
000001
111111
CHAR 245
000100
000100
000100
000100
000100
010100
001000
000000
CHAR 246
001010
000000
001110
010001
010001
010001
001110
000000
CHAR 247
111110
111110
111110
111110
111110
111110
111110
111110
CHAR 248
111100
111100
111100
111100
111100
111100
111100
111100
CHAR 249
111000
111000
111000
111000
111000
111000
111000
111000
CHAR 250
110000
110000
110000
110000
110000
110000
110000
110000
CHAR 251
100000
100000
100000
100000
100000
100000
100000
100000
CHAR 252
001010
000000
010010
010010
010010
010110
001010
000000
CHAR 253
011000
000100
001000
011100
000000
000000
000000
000000
CHAR 254
000000
000000
000000
011110
110010
110011
111110
001111
CHAR 255
010010
111111
010010
010010
111111
010010
000000
000000
</script>

<script>
    /**

@file transparent sprites
@summary makes all sprites have transparent backgrounds
@license MIT
@version 4.0.2
@requires Bitsy Version: 6.1
@author Sean S. LeBlanc

@description
Makes all sprites have transparent backgrounds.
i.e. tiles can be seen underneath the player, sprites, and items.

HOW TO USE:
1. Copy-paste this script into a script tag after the bitsy source
2. Edit hackOptions below as needed
*/
this.hacks = this.hacks || {};
this.hacks.transparent_sprites = (function (exports,bitsy) {
'use strict';
var hackOptions = {
isTransparent: function (drawing) {
	//return drawing.name == 'tea'; // specific transparent drawing
	//return ['tea', 'flower', 'hat'].indexOf(drawing.name) !== -1; // specific transparent drawing list
	//return drawing.name.indexOf('TRANSPARENT') !== -1; // transparent drawing flag in name
	return true; // all drawings are transparent
},
};

bitsy = bitsy && bitsy.hasOwnProperty('default') ? bitsy['default'] : bitsy;

/**
@file utils
@summary miscellaneous bitsy utilities
@author Sean S. LeBlanc
*/

/*
Helper used to replace code in a script tag based on a search regex
To inject code without erasing original string, using capturing groups; e.g.
	inject(/(some string)/,'injected before $1 injected after')
*/
function inject(searchRegex, replaceString) {
	// find the relevant script tag
	var scriptTags = document.getElementsByTagName('script');
	var scriptTag;
	var code;
	for (var i = 0; i < scriptTags.length; ++i) {
		scriptTag = scriptTags[i];
		var matchesSearch = scriptTag.textContent.search(searchRegex) !== -1;
		var isCurrentScript = scriptTag === document.currentScript;
		if (matchesSearch && !isCurrentScript) {
			code = scriptTag.textContent;
			break;
		}
	}

	// error-handling
	if (!code) {
		throw 'Couldn\'t find "' + searchRegex + '" in script tags';
	}

	// modify the content
	code = code.replace(searchRegex, replaceString);

	// replace the old script tag with a new one using our modified code
	var newScriptTag = document.createElement('script');
	newScriptTag.textContent = code;
	scriptTag.insertAdjacentElement('afterend', newScriptTag);
	scriptTag.remove();
}

/**
 * Helper for getting an array with unique elements 
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
	return array.filter(function (item, idx) {
		return array.indexOf(item) === idx;
	});
}

/**

@file kitsy-script-toolkit
@summary makes it easier and cleaner to run code before and after Bitsy functions or to inject new code into Bitsy script tags
@license WTFPL (do WTF you want)
@version 4.0.0
@requires Bitsy Version: 4.5, 4.6
@author @mildmojo

@description
HOW TO USE:
  import {before, after, inject, addDialogTag, addDeferredDialogTag} from "./helpers/kitsy-script-toolkit";

  before(targetFuncName, beforeFn);
  after(targetFuncName, afterFn);
  inject(searchRegex, replaceString);
  addDialogTag(tagName, dialogFn);
  addDeferredDialogTag(tagName, dialogFn);

  For more info, see the documentation at:
  https://github.com/seleb/bitsy-hacks/wiki/Coding-with-kitsy
*/

// Ex: before('load_game', function run() { alert('Loading!'); });
//     before('show_text', function run(text) { return text.toUpperCase(); });
//     before('show_text', function run(text, done) { done(text.toUpperCase()); });
function before(targetFuncName, beforeFn) {
	var kitsy = kitsyInit();
	kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
	kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
}

function kitsyInit() {
	// return already-initialized kitsy
	if (bitsy.kitsy) {
		return bitsy.kitsy;
	}

	// Initialize kitsy
	bitsy.kitsy = {
		queuedInjectScripts: [],
		queuedBeforeScripts: {},
		queuedAfterScripts: {}
	};

	var oldStartFunc = bitsy.startExportedGame;
	bitsy.startExportedGame = function doAllInjections() {
		// Only do this once.
		bitsy.startExportedGame = oldStartFunc;

		// Rewrite scripts and hook everything up.
		doInjects();
		applyAllHooks();

		// Start the game
		bitsy.startExportedGame.apply(this, arguments);
	};

	return bitsy.kitsy;
}


function doInjects() {
	bitsy.kitsy.queuedInjectScripts.forEach(function (injectScript) {
		inject(injectScript.searchRegex, injectScript.replaceString);
	});
	_reinitEngine();
}

function applyAllHooks() {
	var allHooks = unique(Object.keys(bitsy.kitsy.queuedBeforeScripts).concat(Object.keys(bitsy.kitsy.queuedAfterScripts)));
	allHooks.forEach(applyHook);
}

function applyHook(functionName) {
	var functionNameSegments = functionName.split('.');
	var obj = bitsy;
	while (functionNameSegments.length > 1) {
		obj = obj[functionNameSegments.shift()];
	}
	var lastSegment = functionNameSegments[0];
	var superFn = obj[lastSegment];
	var superFnLength = superFn ? superFn.length : 0;
	var functions = [];
	// start with befores
	functions = functions.concat(bitsy.kitsy.queuedBeforeScripts[functionName] || []);
	// then original
	if (superFn) {
		functions.push(superFn);
	}
	// then afters
	functions = functions.concat(bitsy.kitsy.queuedAfterScripts[functionName] || []);

	// overwrite original with one which will call each in order
	obj[lastSegment] = function () {
		var returnVal;
		var args;
		var i = 0;

		function runBefore() {
			// All outta functions? Finish
			if (i === functions.length) {
				return returnVal;
			}

			// Update args if provided.
			if (arguments.length > 0) {
				args = [].slice.call(arguments);
			}

			if (functions[i].length > superFnLength) {
				// Assume funcs that accept more args than the original are
				// async and accept a callback as an additional argument.
				return functions[i++].apply(this, args.concat(runBefore.bind(this)));
			} else {
				// run synchronously
				returnVal = functions[i++].apply(this, args);
				if (returnVal && returnVal.length) {
					args = returnVal;
				}
				return runBefore.apply(this, args);
			}
		}

		return runBefore.apply(this, arguments);
	};
}

function _reinitEngine() {
	// recreate the script and dialog objects so that they'll be
	// referencing the code with injections instead of the original
	bitsy.scriptModule = new bitsy.Script();
	bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

	bitsy.dialogModule = new bitsy.Dialog();
	bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
	bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
}





var madeTransparent;
var makeTransparent;
before('onready', function() {
	madeTransparent = {};
	makeTransparent = false;
});
before('renderer.GetImage', function (drawing, paletteId, frameOverride) {
	// check cache first
	var cache = madeTransparent[drawing.drw] = madeTransparent[drawing.drw] || {};
	var p = cache[paletteId] = cache[paletteId] || {};
	var frameIndex = frameOverride || drawing.animation.frameIndex;
	var source = bitsy.renderer.GetImageSource(drawing.drw);
	if (p[frameIndex] === source) {
		// already made this transparent
		return;
	}

	// flag the next draw as needing to be made transparent
	p[frameIndex] = source;
	makeTransparent = hackOptions.isTransparent(drawing);
});

before('drawTile', function (canvas) {
	if (makeTransparent) {
		// redraw with all bg pixels transparent
		var ctx = canvas.getContext('2d');
		var data = ctx.getImageData(0, 0, canvas.width, canvas.height);
		var bg = bitsy.getPal(bitsy.getRoomPal(bitsy.player().room))[0];
		for (let i = 0; i < data.data.length; i += 4) {
			var r = data.data[i];
			var g = data.data[i + 1];
			var b = data.data[i + 2];
			if (r === bg[0] && g === bg[1] && b === bg[2]) {
				data.data[i + 3] = 0;
			}
		}
		ctx.putImageData(data, 0, 0);
		// clear the flag
		makeTransparent = false;
	}
});

exports.hackOptions = hackOptions;

return exports;

}({},window));
</script>

</head>


<!-- DOCUMENT BODY -->
<body onload='startExportedGame()'>
	<!-- GAME CANVAS -->
    <canvas id='game'></canvas>

<audio src="lallorona.mp3" autoplay loop></audio>
<script>document.addEventListener('mousedown', function(){ Array.prototype.slice.call(document.getElementsByTagName("audio")).forEach(function(element){ element.play(); }); });</script></body>


</html>